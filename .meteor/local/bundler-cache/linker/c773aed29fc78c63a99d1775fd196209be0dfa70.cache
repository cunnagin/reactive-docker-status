[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar meteorInstall = Package['modules-runtime'].meteorInstall;\n\n/* Package-scope variables */\nvar Buffer, process, opts, exports, stream;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"modules\":{\"client.js\":[\"./install-packages.js\",\"./stubs.js\",\"./buffer.js\",\"./process.js\",\"reify/lib/runtime\",\"./css\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/client.js                                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"./install-packages.js\");                                                                                    // 1\nrequire(\"./stubs.js\");                                                                                               // 2\nrequire(\"./buffer.js\");                                                                                              // 3\nrequire(\"./process.js\");                                                                                             // 4\nrequire(\"reify/lib/runtime\").enable(module.constructor);                                                             // 5\n                                                                                                                     // 6\nexports.addStyles = require(\"./css\").addStyles;                                                                      // 7\n                                                                                                                     // 8\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"buffer.js\":[\"buffer\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/buffer.js                                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\ntry {                                                                                                                // 1\n  Buffer = global.Buffer || require(\"buffer\").Buffer;                                                                // 2\n} catch (noBuffer) {}                                                                                                // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"css.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/css.js                                                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar doc = document;                                                                                                  // 1\nvar head = doc.getElementsByTagName(\"head\").item(0);                                                                 // 2\n                                                                                                                     // 3\nexports.addStyles = function (css) {                                                                                 // 4\n  var style = doc.createElement(\"style\");                                                                            // 5\n                                                                                                                     // 6\n  style.setAttribute(\"type\", \"text/css\");                                                                            // 7\n                                                                                                                     // 8\n  // https://msdn.microsoft.com/en-us/library/ms535871(v=vs.85).aspx                                                 // 9\n  var internetExplorerSheetObject =                                                                                  // 10\n    style.sheet || // Edge/IE11.                                                                                     // 11\n    style.styleSheet; // Older IEs.                                                                                  // 12\n                                                                                                                     // 13\n  if (internetExplorerSheetObject) {                                                                                 // 14\n    internetExplorerSheetObject.cssText = css;                                                                       // 15\n  } else {                                                                                                           // 16\n    style.appendChild(doc.createTextNode(css));                                                                      // 17\n  }                                                                                                                  // 18\n                                                                                                                     // 19\n  return head.appendChild(style);                                                                                    // 20\n};                                                                                                                   // 21\n                                                                                                                     // 22\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"install-packages.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/install-packages.js                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nfunction install(name, mainModule) {                                                                                 // 1\n  var meteorDir = {};                                                                                                // 2\n                                                                                                                     // 3\n  // Given a package name <name>, install a stub module in the                                                       // 4\n  // /node_modules/meteor directory called <name>.js, so that                                                        // 5\n  // require.resolve(\"meteor/<name>\") will always return                                                             // 6\n  // /node_modules/meteor/<name>.js instead of something like                                                        // 7\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event                                            // 8\n  // that the package contains a file called index.js (#6590).                                                       // 9\n                                                                                                                     // 10\n  if (mainModule) {                                                                                                  // 11\n    meteorDir[name + \".js\"] = [mainModule, function (require, e, module) {                                           // 12\n      module.exports = require(mainModule);                                                                          // 13\n    }];                                                                                                              // 14\n  } else {                                                                                                           // 15\n    // back compat with old Meteor packages                                                                          // 16\n    meteorDir[name + \".js\"] = function (r, e, module) {                                                              // 17\n      module.exports = Package[name];                                                                                // 18\n    };                                                                                                               // 19\n  }                                                                                                                  // 20\n                                                                                                                     // 21\n  meteorInstall({                                                                                                    // 22\n    node_modules: {                                                                                                  // 23\n      meteor: meteorDir                                                                                              // 24\n    }                                                                                                                // 25\n  });                                                                                                                // 26\n}                                                                                                                    // 27\n                                                                                                                     // 28\n// This file will be modified during computeJsOutputFilesMap to include                                              // 29\n// install(<name>) calls for every Meteor package.                                                                   // 30\n                                                                                                                     // 31\ninstall(\"underscore\");                                                                                               // 32\ninstall(\"meteor\");                                                                                                   // 33\ninstall(\"meteor-base\");                                                                                              // 34\ninstall(\"mobile-experience\");                                                                                        // 35\ninstall(\"modules-runtime\");                                                                                          // 36\ninstall(\"modules\", \"meteor/modules/client.js\");                                                                      // 37\ninstall(\"es5-shim\", \"meteor/es5-shim/client.js\");                                                                    // 38\ninstall(\"promise\", \"meteor/promise/client.js\");                                                                      // 39\ninstall(\"ecmascript-runtime\", \"meteor/ecmascript-runtime/runtime.js\");                                               // 40\ninstall(\"babel-compiler\");                                                                                           // 41\ninstall(\"ecmascript\");                                                                                               // 42\ninstall(\"base64\");                                                                                                   // 43\ninstall(\"ejson\");                                                                                                    // 44\ninstall(\"id-map\");                                                                                                   // 45\ninstall(\"ordered-dict\");                                                                                             // 46\ninstall(\"tracker\");                                                                                                  // 47\ninstall(\"babel-runtime\");                                                                                            // 48\ninstall(\"random\");                                                                                                   // 49\ninstall(\"mongo-id\");                                                                                                 // 50\ninstall(\"diff-sequence\");                                                                                            // 51\ninstall(\"geojson-utils\", \"meteor/geojson-utils/main.js\");                                                            // 52\ninstall(\"minimongo\");                                                                                                // 53\ninstall(\"check\", \"meteor/check/match.js\");                                                                           // 54\ninstall(\"retry\");                                                                                                    // 55\ninstall(\"ddp-common\");                                                                                               // 56\ninstall(\"reload\");                                                                                                   // 57\ninstall(\"ddp-client\");                                                                                               // 58\ninstall(\"ddp\");                                                                                                      // 59\ninstall(\"ddp-server\");                                                                                               // 60\ninstall(\"allow-deny\");                                                                                               // 61\ninstall(\"insecure\");                                                                                                 // 62\ninstall(\"mongo\");                                                                                                    // 63\ninstall(\"blaze-html-templates\");                                                                                     // 64\ninstall(\"reactive-var\");                                                                                             // 65\ninstall(\"jquery\", \"meteor/jquery/main.js\");                                                                          // 66\ninstall(\"standard-minifier-css\");                                                                                    // 67\ninstall(\"standard-minifier-js\");                                                                                     // 68\ninstall(\"autopublish\");                                                                                              // 69\ninstall(\"webapp\");                                                                                                   // 70\ninstall(\"livedata\");                                                                                                 // 71\ninstall(\"hot-code-push\");                                                                                            // 72\ninstall(\"deps\");                                                                                                     // 73\ninstall(\"htmljs\");                                                                                                   // 74\ninstall(\"observe-sequence\");                                                                                         // 75\ninstall(\"blaze\");                                                                                                    // 76\ninstall(\"spacebars\");                                                                                                // 77\ninstall(\"templating\");                                                                                               // 78\ninstall(\"launch-screen\");                                                                                            // 79\ninstall(\"ui\");                                                                                                       // 80\ninstall(\"autoupdate\");                                                                                               // 81\n                                                                                                                     // 82\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"process.js\":[\"process\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/process.js                                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\ntry {                                                                                                                // 1\n  // The application can run `npm install process` to provide its own                                                // 2\n  // process stub; otherwise this module will provide a partial stub.                                                // 3\n  process = global.process || require(\"process\");                                                                    // 4\n} catch (noProcess) {                                                                                                // 5\n  process = {};                                                                                                      // 6\n}                                                                                                                    // 7\n                                                                                                                     // 8\nif (Meteor.isServer) {                                                                                               // 9\n  // Make require(\"process\") work on the server in all versions of Node.                                             // 10\n  meteorInstall({                                                                                                    // 11\n    node_modules: {                                                                                                  // 12\n      \"process.js\": function (r, e, module) {                                                                        // 13\n        module.exports = process;                                                                                    // 14\n      }                                                                                                              // 15\n    }                                                                                                                // 16\n  });                                                                                                                // 17\n} else {                                                                                                             // 18\n  process.platform = \"browser\";                                                                                      // 19\n  process.nextTick = process.nextTick || Meteor._setImmediate;                                                       // 20\n}                                                                                                                    // 21\n                                                                                                                     // 22\nif (typeof process.env !== \"object\") {                                                                               // 23\n  process.env = {};                                                                                                  // 24\n}                                                                                                                    // 25\n                                                                                                                     // 26\n_.extend(process.env, meteorEnv);                                                                                    // 27\n                                                                                                                     // 28\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"stubs.js\":[\"meteor-node-stubs\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/stubs.js                                                                                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\ntry {                                                                                                                // 1\n  // When meteor-node-stubs is installed in the application's root                                                   // 2\n  // node_modules directory, requiring it here installs aliases for stubs                                            // 3\n  // for all Node built-in modules, such as fs, util, and http.                                                      // 4\n  require(\"meteor-node-stubs\");                                                                                      // 5\n} catch (noStubs) {}                                                                                                 // 6\n                                                                                                                     // 7\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"reify\":{\"lib\":{\"runtime.js\":[\"./entry.js\",\"./utils.js\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor/modules/node_modules/reify/lib/runtime.js                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar Entry = require(\"./entry.js\").Entry;                                                                             // 1\nvar utils = require(\"./utils.js\");                                                                                   // 2\n                                                                                                                     // 3\nexports.enable = function (Module) {                                                                                 // 4\n  var Mp = Module.prototype;                                                                                         // 5\n                                                                                                                     // 6\n  if (typeof Mp.import === \"function\" &&                                                                             // 7\n      typeof Mp.export === \"function\") {                                                                             // 8\n    // If the Mp.{import,export} methods have already been                                                           // 9\n    // defined, abandon reification immediately.                                                                     // 10\n    return Module;                                                                                                   // 11\n  }                                                                                                                  // 12\n                                                                                                                     // 13\n  // Platform-specific code should implement this method however                                                     // 14\n  // appropriate. Module.prototype.resolve(id) should return an absolute                                             // 15\n  // version of the given module identifier, like require.resolve.                                                   // 16\n  Mp.resolve = Mp.resolve || function resolve(id) {                                                                  // 17\n    throw new Error(\"Module.prototype.resolve not implemented\");                                                     // 18\n  };                                                                                                                 // 19\n                                                                                                                     // 20\n  // Platform-specific code should find a way to call this method whenever                                           // 21\n  // the module system is about to return module.exports from require. This                                          // 22\n  // might happen more than once per module, in case of dependency cycles,                                           // 23\n  // so we want Module.prototype.runModuleSetters to run each time.                                                  // 24\n  Mp.runModuleSetters = function runModuleSetters(valueToPassThrough) {                                              // 25\n    var entry = Entry.get(this.id);                                                                                  // 26\n    if (entry) {                                                                                                     // 27\n      entry.runModuleSetters(this);                                                                                  // 28\n    }                                                                                                                // 29\n                                                                                                                     // 30\n    // Assignments to exported local variables get wrapped with calls to                                             // 31\n    // module.runModuleSetters, so module.runModuleSetters returns the                                               // 32\n    // valueToPassThrough parameter to allow the value of the original                                               // 33\n    // expression to pass through. For example,                                                                      // 34\n    //                                                                                                               // 35\n    //   export var a = 1;                                                                                           // 36\n    //   console.log(a += 3);                                                                                        // 37\n    //                                                                                                               // 38\n    // becomes                                                                                                       // 39\n    //                                                                                                               // 40\n    //   module.export(\"a\", () => a);                                                                                // 41\n    //   var a = 1;                                                                                                  // 42\n    //   console.log(module.runModuleSetters(a += 3));                                                               // 43\n    //                                                                                                               // 44\n    // This ensures module.runModuleSetters runs immediately after the                                               // 45\n    // assignment, and does not interfere with the larger computation.                                               // 46\n    return valueToPassThrough;                                                                                       // 47\n  };                                                                                                                 // 48\n                                                                                                                     // 49\n  function setESModule(module) {                                                                                     // 50\n    var exports = module.exports;                                                                                    // 51\n    if (exports && typeof exports === \"object\") {                                                                    // 52\n      exports.__esModule = true;                                                                                     // 53\n    }                                                                                                                // 54\n  }                                                                                                                  // 55\n                                                                                                                     // 56\n  Mp.import = function (id, setters) {                                                                               // 57\n    var module = this;                                                                                               // 58\n    setESModule(module);                                                                                             // 59\n                                                                                                                     // 60\n    var absoluteId = module.resolve(id);                                                                             // 61\n                                                                                                                     // 62\n    if (setters && typeof setters === \"object\") {                                                                    // 63\n      var entry = Entry.getOrCreate(absoluteId);                                                                     // 64\n      entry.addSetters(module, setters);                                                                             // 65\n    }                                                                                                                // 66\n                                                                                                                     // 67\n    var countBefore = entry && entry.runCount;                                                                       // 68\n    var exports = typeof module.require === \"function\"                                                               // 69\n      ? module.require(absoluteId)                                                                                   // 70\n      : require(absoluteId);                                                                                         // 71\n                                                                                                                     // 72\n    if (entry && entry.runCount === countBefore) {                                                                   // 73\n      // If require(absoluteId) didn't run any setters for this entry,                                               // 74\n      // perhaps because it's not the first time this module has been                                                // 75\n      // required, run the setters now using an object that passes as the                                            // 76\n      // real module object.                                                                                         // 77\n      entry.runModuleSetters({                                                                                       // 78\n        id: absoluteId,                                                                                              // 79\n        exports: exports,                                                                                            // 80\n        getExportByName: Mp.getExportByName                                                                          // 81\n      });                                                                                                            // 82\n    }                                                                                                                // 83\n  };                                                                                                                 // 84\n                                                                                                                     // 85\n  // Register getter functions for local variables in the scope of an                                                // 86\n  // export statement. The keys of the getters object are exported names,                                            // 87\n  // and the values are functions that return local values.                                                          // 88\n  Mp.export = function (getters) {                                                                                   // 89\n    var module = this;                                                                                               // 90\n    setESModule(module);                                                                                             // 91\n                                                                                                                     // 92\n    if (utils.isPlainObject(getters)) {                                                                              // 93\n      Entry.getOrCreate(module.id).addGetters(getters);                                                              // 94\n    }                                                                                                                // 95\n                                                                                                                     // 96\n    if (module.loaded) {                                                                                             // 97\n      // If the module has already been evaluated, then we need to trigger                                           // 98\n      // another round of entry.runModuleSetters calls, which begins by                                              // 99\n      // calling entry.runModuleGetters(module).                                                                     // 100\n      module.runModuleSetters();                                                                                     // 101\n    }                                                                                                                // 102\n  };                                                                                                                 // 103\n                                                                                                                     // 104\n  // This method can be overridden by client code to implement custom export                                         // 105\n  // naming logic. The current implementation works well with Babel's                                                // 106\n  // __esModule convention.                                                                                          // 107\n  Mp.getExportByName = function (name) {                                                                             // 108\n    var exports = this.exports;                                                                                      // 109\n                                                                                                                     // 110\n    if (name === \"*\") {                                                                                              // 111\n      return exports;                                                                                                // 112\n    }                                                                                                                // 113\n                                                                                                                     // 114\n    if (name === \"default\" &&                                                                                        // 115\n        ! (exports &&                                                                                                // 116\n           typeof exports === \"object\" &&                                                                            // 117\n           exports.__esModule &&                                                                                     // 118\n           \"default\" in exports)) {                                                                                  // 119\n      return exports;                                                                                                // 120\n    }                                                                                                                // 121\n                                                                                                                     // 122\n    return exports && exports[name];                                                                                 // 123\n  };                                                                                                                 // 124\n                                                                                                                     // 125\n  return Module;                                                                                                     // 126\n};                                                                                                                   // 127\n                                                                                                                     // 128\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"entry.js\":[\"./utils.js\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor/modules/node_modules/reify/lib/entry.js                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar hasOwn = Object.prototype.hasOwnProperty;                                                                        // 1\nvar entryMap = Object.create(null);                                                                                  // 2\nvar utils = require(\"./utils.js\");                                                                                   // 3\n                                                                                                                     // 4\nfunction Entry(id) {                                                                                                 // 5\n  // Same as module.id for this module.                                                                              // 6\n  this.id = id;                                                                                                      // 7\n  // The number of times this.runModuleSetters has been called.                                                      // 8\n  this.runCount = 0;                                                                                                 // 9\n  // Setters for assigning to local variables in parent modules.                                                     // 10\n  this.setters = Object.create(null);                                                                                // 11\n  // Getters for local variables exported from this module.                                                          // 12\n  this.getters = Object.create(null);                                                                                // 13\n}                                                                                                                    // 14\n                                                                                                                     // 15\nvar Ep = Entry.prototype;                                                                                            // 16\n                                                                                                                     // 17\nEntry.get = function (id) {                                                                                          // 18\n  return entryMap[id] || null;                                                                                       // 19\n};                                                                                                                   // 20\n                                                                                                                     // 21\nEntry.getOrCreate = function (id) {                                                                                  // 22\n  return entryMap[id] = entryMap[id] || new Entry(id);                                                               // 23\n};                                                                                                                   // 24\n                                                                                                                     // 25\nEp.addSetters = function (parent, setters) {                                                                         // 26\n  var entry = this;                                                                                                  // 27\n                                                                                                                     // 28\n  Object.keys(setters).forEach(function (name) {                                                                     // 29\n    var setter = setters[name];                                                                                      // 30\n    if (typeof setter === \"function\" &&                                                                              // 31\n        // Ignore any requests for the exports.__esModule property.\"                                                 // 32\n        name !== \"__esModule\") {                                                                                     // 33\n      setter.parent = parent;                                                                                        // 34\n      (entry.setters[name] =                                                                                         // 35\n       entry.setters[name] || []                                                                                     // 36\n      ).push(setter);                                                                                                // 37\n    }                                                                                                                // 38\n  });                                                                                                                // 39\n};                                                                                                                   // 40\n                                                                                                                     // 41\nEp.addGetters = function (getters) {                                                                                 // 42\n  var entry = this;                                                                                                  // 43\n  Object.keys(getters).forEach(function (name) {                                                                     // 44\n    var getter = getters[name];                                                                                      // 45\n    if (typeof getter === \"function\" &&                                                                              // 46\n        // Ignore any requests for the exports.__esModule property.\"                                                 // 47\n        name !== \"__esModule\") {                                                                                     // 48\n      // Should this throw if hasOwn.call(this.getters, name)?                                                       // 49\n      entry.getters[name] = getter;                                                                                  // 50\n    }                                                                                                                // 51\n  });                                                                                                                // 52\n};                                                                                                                   // 53\n                                                                                                                     // 54\nfunction runModuleSetters(module) {                                                                                  // 55\n  var entry = entryMap[module.id];                                                                                   // 56\n  if (entry) {                                                                                                       // 57\n    entry.runModuleSetters(module);                                                                                  // 58\n  }                                                                                                                  // 59\n}                                                                                                                    // 60\n                                                                                                                     // 61\nfunction runModuleGetters(module) {                                                                                  // 62\n  var entry = entryMap[module.id];                                                                                   // 63\n  return entry ? entry.runModuleGetters(module) : 0;                                                                 // 64\n}                                                                                                                    // 65\n                                                                                                                     // 66\nEp.runModuleGetters = function (module) {                                                                            // 67\n  var entry = this;                                                                                                  // 68\n  var changeCount = 0;                                                                                               // 69\n                                                                                                                     // 70\n  Object.keys(entry.getters).forEach(function (name) {                                                               // 71\n    if (entry.runGetter(module, name)) {                                                                             // 72\n      ++changeCount;                                                                                                 // 73\n    }                                                                                                                // 74\n  });                                                                                                                // 75\n                                                                                                                     // 76\n  return changeCount;                                                                                                // 77\n};                                                                                                                   // 78\n                                                                                                                     // 79\n// Returns true iff the getter updated module.exports with a new value.                                              // 80\nEp.runGetter = function (module, name) {                                                                             // 81\n  if (! hasOwn.call(this.getters, name)) {                                                                           // 82\n    return false;                                                                                                    // 83\n  }                                                                                                                  // 84\n                                                                                                                     // 85\n  var getter = this.getters[name];                                                                                   // 86\n  try {                                                                                                              // 87\n    var value = getter.call(module);                                                                                 // 88\n  } catch (e) {}                                                                                                     // 89\n  var exports = module.exports;                                                                                      // 90\n                                                                                                                     // 91\n  if (! hasOwn.call(exports, name) ||                                                                                // 92\n      exports[name] !== value) {                                                                                     // 93\n    // We update module.exports[name] with the current value so that                                                 // 94\n    // CommonJS require calls remain consistent with module.import.                                                  // 95\n    exports[name] = value;                                                                                           // 96\n    return true;                                                                                                     // 97\n  }                                                                                                                  // 98\n                                                                                                                     // 99\n  return false;                                                                                                      // 100\n};                                                                                                                   // 101\n                                                                                                                     // 102\n// Called whenever module.exports might have changed, to trigger any                                                 // 103\n// setters associated with the newly exported values.                                                                // 104\nEp.runModuleSetters = function (module) {                                                                            // 105\n  var entry = this;                                                                                                  // 106\n  var names = Object.keys(entry.setters);                                                                            // 107\n                                                                                                                     // 108\n  // Make sure module.exports is up to date before we call                                                           // 109\n  // module.getExportByName(name).                                                                                   // 110\n  entry.runModuleGetters(module);                                                                                    // 111\n                                                                                                                     // 112\n  // Invoke the given callback once for every (setter, value, name) triple                                           // 113\n  // that needs to be called. Note that forEachSetter does not call any                                              // 114\n  // setters itself, only the given callback.                                                                        // 115\n  function forEachSetter(callback, context) {                                                                        // 116\n    names.forEach(function (name) {                                                                                  // 117\n      entry.setters[name].forEach(function (setter) {                                                                // 118\n        var value = module.getExportByName(name);                                                                    // 119\n        if (name === \"*\") {                                                                                          // 120\n          Object.keys(value).forEach(function (name) {                                                               // 121\n            call(setter, value[name], name);                                                                         // 122\n          });                                                                                                        // 123\n        } else {                                                                                                     // 124\n          call(setter, value, name);                                                                                 // 125\n        }                                                                                                            // 126\n      });                                                                                                            // 127\n    });                                                                                                              // 128\n                                                                                                                     // 129\n    function call(setter, value, name) {                                                                             // 130\n      if (name === \"__esModule\") {                                                                                   // 131\n        // Ignore setters asking for module.exports.__esModule.                                                      // 132\n        return;                                                                                                      // 133\n      }                                                                                                              // 134\n                                                                                                                     // 135\n      setter.last = setter.last || Object.create(null);                                                              // 136\n                                                                                                                     // 137\n      if (! hasOwn.call(setter.last, name) ||                                                                        // 138\n          setter.last[name] !== value) {                                                                             // 139\n        // Only invoke the callback if we have not called this setter                                                // 140\n        // (with a value of this name) before, or the current value is                                               // 141\n        // different from the last value we passed to this setter.                                                   // 142\n        return callback.apply(context, arguments);                                                                   // 143\n      }                                                                                                              // 144\n    }                                                                                                                // 145\n  }                                                                                                                  // 146\n                                                                                                                     // 147\n  // Every three elements of this list form a (setter, value, name) triple                                           // 148\n  // that needs to be invoked.                                                                                       // 149\n  var settersToCall = [];                                                                                            // 150\n                                                                                                                     // 151\n  // Lazily-initialized objects mapping parent module identifiers to                                                 // 152\n  // relevant parent module objects and snapshots of their exports.                                                  // 153\n  var relevantParents;                                                                                               // 154\n  var parentSnapshots;                                                                                               // 155\n                                                                                                                     // 156\n  // Take snapshots of setter.parent.exports for any setters that we are                                             // 157\n  // planning to call, so that we can later determine if calling the                                                 // 158\n  // setters modified any of those exports objects.                                                                  // 159\n  forEachSetter(function (setter, value, name) {                                                                     // 160\n    var parent = setter.parent;                                                                                      // 161\n    parentSnapshots = parentSnapshots || Object.create(null);                                                        // 162\n    if (! hasOwn.call(parentSnapshots, parent.id)) {                                                                 // 163\n      relevantParents = relevantParents || Object.create(null);                                                      // 164\n      relevantParents[parent.id] = parent;                                                                           // 165\n      if (utils.isPlainObject(parent.exports)) {                                                                     // 166\n        // If parent.exports is an object, make a shallow clone of it so                                             // 167\n        // that we can see if it changes as a result of calling setters.                                             // 168\n        parentSnapshots[parent.id] = utils.assign({}, parent.exports);                                               // 169\n      } else {                                                                                                       // 170\n        // If parent.exports is not an object, the \"snapshot\" is just the                                            // 171\n        // value of parent.exports.                                                                                  // 172\n        parentSnapshots[parent.id] = parent.exports;                                                                 // 173\n      }                                                                                                              // 174\n    }                                                                                                                // 175\n                                                                                                                     // 176\n    // Push three elements at a time to avoid creating wrapper arrays for                                            // 177\n    // each (setter, value, name) triple. Note the i += 3 below.                                                     // 178\n    settersToCall.push(setter, value, name);                                                                         // 179\n  });                                                                                                                // 180\n                                                                                                                     // 181\n  // Now call all the setters that we decided we need to call.                                                       // 182\n  for (var i = 0; i < settersToCall.length; i += 3) {                                                                // 183\n    var setter = settersToCall[i];                                                                                   // 184\n    var value = settersToCall[i + 1];                                                                                // 185\n    var name = settersToCall[i + 2];                                                                                 // 186\n    setter.call(module, setter.last[name] = value, name);                                                            // 187\n  }                                                                                                                  // 188\n                                                                                                                     // 189\n  ++entry.runCount;                                                                                                  // 190\n                                                                                                                     // 191\n  if (! relevantParents) {                                                                                           // 192\n    // If we never called takeSnapshot, then we can avoid checking                                                   // 193\n    // relevantParents and parentSnapshots below.                                                                    // 194\n    return;                                                                                                          // 195\n  }                                                                                                                  // 196\n                                                                                                                     // 197\n  // If any of the setters updated the module.exports of a parent module,                                            // 198\n  // or updated local variables that are exported by that parent module,                                             // 199\n  // then we must re-run any setters registered by that parent module.                                               // 200\n  Object.keys(relevantParents).forEach(function (id) {                                                               // 201\n    var parent = relevantParents[id];                                                                                // 202\n                                                                                                                     // 203\n    if (runModuleGetters(parent) > 0) {                                                                              // 204\n      return runModuleSetters(parent);                                                                               // 205\n    }                                                                                                                // 206\n                                                                                                                     // 207\n    var exports = parent.exports;                                                                                    // 208\n    var snapshot = parentSnapshots[parent.id];                                                                       // 209\n    if (utils.shallowObjEqual(exports, snapshot)) {                                                                  // 210\n      // If parent.exports have not changed since we took the snapshot,                                              // 211\n      // then we do not need to run the parent's setters.                                                            // 212\n      return;                                                                                                        // 213\n    }                                                                                                                // 214\n                                                                                                                     // 215\n    runModuleSetters(parent);                                                                                        // 216\n  });                                                                                                                // 217\n};                                                                                                                   // 218\n                                                                                                                     // 219\nexports.Entry = Entry;                                                                                               // 220\n                                                                                                                     // 221\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"utils.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor/modules/node_modules/reify/lib/utils.js                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar hasOwn = Object.prototype.hasOwnProperty;                                                                        // 1\nvar objToStr = Object.prototype.toString;                                                                            // 2\nvar objStr = objToStr.call({});                                                                                      // 3\n                                                                                                                     // 4\nfunction isPlainObject(value) {                                                                                      // 5\n  return objToStr.call(value) === objStr;                                                                            // 6\n}                                                                                                                    // 7\nexports.isPlainObject = isPlainObject;                                                                               // 8\n                                                                                                                     // 9\nexports.assign = Object.assign || function (obj) {                                                                   // 10\n  var argc = arguments.length;                                                                                       // 11\n  for (var i = 1; i < argc; ++i) {                                                                                   // 12\n    var arg = arguments[i];                                                                                          // 13\n    if (arg && typeof arg === \"object\") {                                                                            // 14\n      var keys = Object.keys(arg);                                                                                   // 15\n      for (var k = 0; k < keys.length; ++k) {                                                                        // 16\n        var key = keys[k];                                                                                           // 17\n        obj[key] = arg[key];                                                                                         // 18\n      }                                                                                                              // 19\n    }                                                                                                                // 20\n  }                                                                                                                  // 21\n  return obj;                                                                                                        // 22\n};                                                                                                                   // 23\n                                                                                                                     // 24\nexports.shallowObjEqual = function(a, b) {                                                                           // 25\n  if (a === b) {                                                                                                     // 26\n    return true;                                                                                                     // 27\n  }                                                                                                                  // 28\n                                                                                                                     // 29\n  if (! isPlainObject(a) ||                                                                                          // 30\n      ! isPlainObject(b)) {                                                                                          // 31\n    return false;                                                                                                    // 32\n  }                                                                                                                  // 33\n                                                                                                                     // 34\n  var aKeys = Object.keys(a);                                                                                        // 35\n  var bKeys = Object.keys(b);                                                                                        // 36\n                                                                                                                     // 37\n  if (aKeys.length !== bKeys.length) {                                                                               // 38\n    return false;                                                                                                    // 39\n  }                                                                                                                  // 40\n                                                                                                                     // 41\n  return aKeys.every(function (key) {                                                                                // 42\n    return hasOwn.call(b, key) &&                                                                                    // 43\n      a[key] === b[key];                                                                                             // 44\n  });                                                                                                                // 45\n};                                                                                                                   // 46\n                                                                                                                     // 47\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}},\"dockerode\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/package.json                                                                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"dockerode\";                                                                                          // 1\nexports.version = \"2.2.10\";                                                                                          // 2\nexports.main = \"./lib/docker\";                                                                                       // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lib\":{\"docker.js\":[\"events\",\"docker-modem\",\"./container\",\"./image\",\"./volume\",\"./network\",\"./exec\",\"./util\",\"meteor-node-stubs/deps/events\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/docker.js                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar EventEmitter = require('events').EventEmitter,                                                                   // 1\n  Modem = require('docker-modem'),                                                                                   // 2\n  Container = require('./container'),                                                                                // 3\n  Image = require('./image'),                                                                                        // 4\n  Volume = require('./volume'),                                                                                      // 5\n  Network = require('./network'),                                                                                    // 6\n  Exec = require('./exec'),                                                                                          // 7\n  util = require('./util'),                                                                                          // 8\n  extend = util.extend;                                                                                              // 9\n                                                                                                                     // 10\nvar Docker = function(opts) {                                                                                        // 11\n  if (!(this instanceof Docker)) return new Docker(opts);                                                            // 12\n  this.modem = new Modem(opts);                                                                                      // 13\n};                                                                                                                   // 14\n                                                                                                                     // 15\n/**                                                                                                                  // 16\n * Creates a new container                                                                                           // 17\n * @param {Object}   opts     Create options                                                                         // 18\n * @param {Function} callback Callback                                                                               // 19\n */                                                                                                                  // 20\nDocker.prototype.createContainer = function(opts, callback) {                                                        // 21\n  var self = this;                                                                                                   // 22\n  var optsf = {                                                                                                      // 23\n    path: '/containers/create?',                                                                                     // 24\n    method: 'POST',                                                                                                  // 25\n    options: opts,                                                                                                   // 26\n    statusCodes: {                                                                                                   // 27\n      200: true, // unofficial, but proxies may return it                                                            // 28\n      201: true,                                                                                                     // 29\n      404: 'no such container',                                                                                      // 30\n      406: 'impossible to attach',                                                                                   // 31\n      500: 'server error'                                                                                            // 32\n    }                                                                                                                // 33\n  };                                                                                                                 // 34\n                                                                                                                     // 35\n  this.modem.dial(optsf, function(err, data) {                                                                       // 36\n    if (err) return callback(err, data);                                                                             // 37\n    callback(err, self.getContainer(data.Id));                                                                       // 38\n  });                                                                                                                // 39\n};                                                                                                                   // 40\n                                                                                                                     // 41\n/**                                                                                                                  // 42\n * Creates a new image                                                                                               // 43\n * @param {Object}   auth     Authentication (optional)                                                              // 44\n * @param {Object}   opts     Create options                                                                         // 45\n * @param {Function} callback Callback                                                                               // 46\n */                                                                                                                  // 47\nDocker.prototype.createImage = function(auth, opts, callback) {                                                      // 48\n  if (!callback && typeof opts === 'function') {                                                                     // 49\n    callback = opts;                                                                                                 // 50\n    opts = auth;                                                                                                     // 51\n    auth = opts.authconfig || undefined;                                                                             // 52\n  }                                                                                                                  // 53\n                                                                                                                     // 54\n  var self = this;                                                                                                   // 55\n  var optsf = {                                                                                                      // 56\n    path: '/images/create?',                                                                                         // 57\n    method: 'POST',                                                                                                  // 58\n    options: opts,                                                                                                   // 59\n    authconfig: auth,                                                                                                // 60\n    isStream: true,                                                                                                  // 61\n    statusCodes: {                                                                                                   // 62\n      200: true,                                                                                                     // 63\n      500: 'server error'                                                                                            // 64\n    }                                                                                                                // 65\n  };                                                                                                                 // 66\n                                                                                                                     // 67\n  this.modem.dial(optsf, function(err, data) {                                                                       // 68\n    callback(err, data);                                                                                             // 69\n  });                                                                                                                // 70\n};                                                                                                                   // 71\n                                                                                                                     // 72\n/**                                                                                                                  // 73\n * Load image                                                                                                        // 74\n * @param {String}   file     File                                                                                   // 75\n * @param {Object}   opts     Options (optional)                                                                     // 76\n * @param {Function} callback Callback                                                                               // 77\n */                                                                                                                  // 78\nDocker.prototype.loadImage = function(file, opts, callback) {                                                        // 79\n  if (!callback && typeof opts === 'function') {                                                                     // 80\n    callback = opts;                                                                                                 // 81\n    opts = null;                                                                                                     // 82\n  }                                                                                                                  // 83\n                                                                                                                     // 84\n  var self = this;                                                                                                   // 85\n  var optsf = {                                                                                                      // 86\n    path: '/images/load?',                                                                                           // 87\n    method: 'POST',                                                                                                  // 88\n    options: opts,                                                                                                   // 89\n    file: file,                                                                                                      // 90\n    isStream: true,                                                                                                  // 91\n    statusCodes: {                                                                                                   // 92\n      200: true,                                                                                                     // 93\n      500: 'server error'                                                                                            // 94\n    }                                                                                                                // 95\n  };                                                                                                                 // 96\n                                                                                                                     // 97\n  this.modem.dial(optsf, function(err, data) {                                                                       // 98\n    callback(err, data);                                                                                             // 99\n  });                                                                                                                // 100\n};                                                                                                                   // 101\n                                                                                                                     // 102\n/**                                                                                                                  // 103\n * Import image from a tar archive                                                                                   // 104\n * @param {String}   file     File                                                                                   // 105\n * @param {Object}   opts     Options (optional)                                                                     // 106\n * @param {Function} callback Callback                                                                               // 107\n */                                                                                                                  // 108\nDocker.prototype.importImage = function(file, opts, callback) {                                                      // 109\n  if (!callback && typeof opts === 'function') {                                                                     // 110\n    callback = opts;                                                                                                 // 111\n    opts = {};                                                                                                       // 112\n  }                                                                                                                  // 113\n                                                                                                                     // 114\n  opts.fromSrc = '-'                                                                                                 // 115\n                                                                                                                     // 116\n  var self = this;                                                                                                   // 117\n  var optsf = {                                                                                                      // 118\n    path: '/images/create?',                                                                                         // 119\n    method: 'POST',                                                                                                  // 120\n    options: opts,                                                                                                   // 121\n    file: file,                                                                                                      // 122\n    isStream: true,                                                                                                  // 123\n    statusCodes: {                                                                                                   // 124\n      200: true,                                                                                                     // 125\n      500: 'server error'                                                                                            // 126\n    }                                                                                                                // 127\n  };                                                                                                                 // 128\n                                                                                                                     // 129\n  this.modem.dial(optsf, function(err, data) {                                                                       // 130\n    callback(err, data);                                                                                             // 131\n  });                                                                                                                // 132\n};                                                                                                                   // 133\n                                                                                                                     // 134\n/**                                                                                                                  // 135\n * Verifies auth                                                                                                     // 136\n * @param {Object}   opts     Options                                                                                // 137\n * @param {Function} callback Callback                                                                               // 138\n */                                                                                                                  // 139\nDocker.prototype.checkAuth = function(opts, callback) {                                                              // 140\n  var self = this;                                                                                                   // 141\n  var optsf = {                                                                                                      // 142\n    path: '/auth',                                                                                                   // 143\n    method: 'POST',                                                                                                  // 144\n    options: opts,                                                                                                   // 145\n    statusCodes: {                                                                                                   // 146\n      200: true,                                                                                                     // 147\n      204: true,                                                                                                     // 148\n      500: 'server error'                                                                                            // 149\n    }                                                                                                                // 150\n  };                                                                                                                 // 151\n                                                                                                                     // 152\n  this.modem.dial(optsf, function(err, data) {                                                                       // 153\n    callback(err, data);                                                                                             // 154\n  });                                                                                                                // 155\n};                                                                                                                   // 156\n                                                                                                                     // 157\n/**                                                                                                                  // 158\n * Builds an image                                                                                                   // 159\n * @param {String}   file     File                                                                                   // 160\n * @param {Object}   opts     Options (optional)                                                                     // 161\n * @param {Function} callback Callback                                                                               // 162\n */                                                                                                                  // 163\nDocker.prototype.buildImage = function(file, opts, callback) {                                                       // 164\n  if (!callback && typeof opts === 'function') {                                                                     // 165\n    callback = opts;                                                                                                 // 166\n    opts = null;                                                                                                     // 167\n  }                                                                                                                  // 168\n                                                                                                                     // 169\n  var self = this;                                                                                                   // 170\n  var optsf = {                                                                                                      // 171\n    path: '/build?',                                                                                                 // 172\n    method: 'POST',                                                                                                  // 173\n    file: file,                                                                                                      // 174\n    options: opts,                                                                                                   // 175\n    isStream: true,                                                                                                  // 176\n    statusCodes: {                                                                                                   // 177\n      200: true,                                                                                                     // 178\n      500: 'server error'                                                                                            // 179\n    }                                                                                                                // 180\n  };                                                                                                                 // 181\n                                                                                                                     // 182\n  if (opts) {                                                                                                        // 183\n    if (opts.registryconfig) {                                                                                       // 184\n      optsf.registryconfig = optsf.options.registryconfig;                                                           // 185\n      delete optsf.options.registryconfig;                                                                           // 186\n    }                                                                                                                // 187\n                                                                                                                     // 188\n    //undocumented?                                                                                                  // 189\n    if (opts.authconfig) {                                                                                           // 190\n      optsf.authconfig = optsf.options.authconfig;                                                                   // 191\n      delete optsf.options.authconfig;                                                                               // 192\n    }                                                                                                                // 193\n  }                                                                                                                  // 194\n                                                                                                                     // 195\n  this.modem.dial(optsf, function(err, data) {                                                                       // 196\n    callback(err, data);                                                                                             // 197\n  });                                                                                                                // 198\n};                                                                                                                   // 199\n                                                                                                                     // 200\n/**                                                                                                                  // 201\n * Fetches a Container by ID                                                                                         // 202\n * @param {String} id Container's ID                                                                                 // 203\n */                                                                                                                  // 204\nDocker.prototype.getContainer = function(id) {                                                                       // 205\n  return new Container(this.modem, id);                                                                              // 206\n};                                                                                                                   // 207\n                                                                                                                     // 208\n/**                                                                                                                  // 209\n * Fetches an Image by name                                                                                          // 210\n * @param {String} name Image's name                                                                                 // 211\n */                                                                                                                  // 212\nDocker.prototype.getImage = function(name) {                                                                         // 213\n  return new Image(this.modem, name);                                                                                // 214\n};                                                                                                                   // 215\n                                                                                                                     // 216\n/**                                                                                                                  // 217\n * Fetches a Volume by name                                                                                          // 218\n * @param {String} name Volume's name                                                                                // 219\n */                                                                                                                  // 220\nDocker.prototype.getVolume = function(name) {                                                                        // 221\n  return new Volume(this.modem, name);                                                                               // 222\n};                                                                                                                   // 223\n                                                                                                                     // 224\n/**                                                                                                                  // 225\n * Fetches a Network by id                                                                                           // 226\n * @param {String} id network's id                                                                                   // 227\n */                                                                                                                  // 228\nDocker.prototype.getNetwork = function(id) {                                                                         // 229\n  return new Network(this.modem, id);                                                                                // 230\n};                                                                                                                   // 231\n                                                                                                                     // 232\n/**                                                                                                                  // 233\n * Fetches an Exec instance by ID                                                                                    // 234\n * @param {String} id Exec instance's ID                                                                             // 235\n */                                                                                                                  // 236\nDocker.prototype.getExec = function(id) {                                                                            // 237\n  return new Exec(this.modem, id);                                                                                   // 238\n};                                                                                                                   // 239\n                                                                                                                     // 240\n/**                                                                                                                  // 241\n * Lists containers                                                                                                  // 242\n * @param {Options}   opts     Options (optional)                                                                    // 243\n * @param {Function} callback Callback                                                                               // 244\n */                                                                                                                  // 245\nDocker.prototype.listContainers = function(opts, callback) {                                                         // 246\n  var args = util.processArgs(opts, callback);                                                                       // 247\n                                                                                                                     // 248\n  var optsf = {                                                                                                      // 249\n    path: '/containers/json?',                                                                                       // 250\n    method: 'GET',                                                                                                   // 251\n    options: args.opts,                                                                                              // 252\n    statusCodes: {                                                                                                   // 253\n      200: true,                                                                                                     // 254\n      400: 'bad parameter',                                                                                          // 255\n      500: 'server error'                                                                                            // 256\n    }                                                                                                                // 257\n  };                                                                                                                 // 258\n                                                                                                                     // 259\n  this.modem.dial(optsf, function(err, data) {                                                                       // 260\n    args.callback(err, data);                                                                                        // 261\n  });                                                                                                                // 262\n};                                                                                                                   // 263\n                                                                                                                     // 264\n/**                                                                                                                  // 265\n * Lists images                                                                                                      // 266\n * @param {Options}   opts     Options (optional)                                                                    // 267\n * @param {Function} callback Callback                                                                               // 268\n */                                                                                                                  // 269\nDocker.prototype.listImages = function(opts, callback) {                                                             // 270\n  var args = util.processArgs(opts, callback);                                                                       // 271\n                                                                                                                     // 272\n  var optsf = {                                                                                                      // 273\n    path: '/images/json?',                                                                                           // 274\n    method: 'GET',                                                                                                   // 275\n    options: args.opts,                                                                                              // 276\n    statusCodes: {                                                                                                   // 277\n      200: true,                                                                                                     // 278\n      400: 'bad parameter',                                                                                          // 279\n      500: 'server error'                                                                                            // 280\n    }                                                                                                                // 281\n  };                                                                                                                 // 282\n                                                                                                                     // 283\n  this.modem.dial(optsf, function(err, data) {                                                                       // 284\n    args.callback(err, data);                                                                                        // 285\n  });                                                                                                                // 286\n};                                                                                                                   // 287\n                                                                                                                     // 288\n/**                                                                                                                  // 289\n * Creates a new volume                                                                                              // 290\n * @param {Object}   opts     Create options                                                                         // 291\n * @param {Function} callback Callback                                                                               // 292\n */                                                                                                                  // 293\nDocker.prototype.createVolume = function(opts, callback) {                                                           // 294\n  var args = util.processArgs(opts, callback);                                                                       // 295\n  var self = this;                                                                                                   // 296\n  var optsf = {                                                                                                      // 297\n    path: '/volumes/create?',                                                                                        // 298\n    method: 'POST',                                                                                                  // 299\n    options: args.opts,                                                                                              // 300\n    statusCodes: {                                                                                                   // 301\n      200: true, // unofficial, but proxies may return it                                                            // 302\n      201: true,                                                                                                     // 303\n      500: 'server error'                                                                                            // 304\n    }                                                                                                                // 305\n  };                                                                                                                 // 306\n                                                                                                                     // 307\n  this.modem.dial(optsf, function(err, data) {                                                                       // 308\n    if (err) return args.callback(err, data);                                                                        // 309\n    args.callback(err, self.getVolume(data.Name));                                                                   // 310\n  });                                                                                                                // 311\n};                                                                                                                   // 312\n                                                                                                                     // 313\n/**                                                                                                                  // 314\n * Lists volumes                                                                                                     // 315\n * @param {Options}   opts     Options (optional)                                                                    // 316\n * @param {Function} callback Callback                                                                               // 317\n */                                                                                                                  // 318\nDocker.prototype.listVolumes = function(opts, callback) {                                                            // 319\n  var args = util.processArgs(opts, callback);                                                                       // 320\n                                                                                                                     // 321\n  var optsf = {                                                                                                      // 322\n    path: '/volumes?',                                                                                               // 323\n    method: 'GET',                                                                                                   // 324\n    options: args.opts,                                                                                              // 325\n    statusCodes: {                                                                                                   // 326\n      200: true,                                                                                                     // 327\n      400: 'bad parameter',                                                                                          // 328\n      500: 'server error'                                                                                            // 329\n    }                                                                                                                // 330\n  };                                                                                                                 // 331\n                                                                                                                     // 332\n  this.modem.dial(optsf, function(err, data) {                                                                       // 333\n    args.callback(err, data);                                                                                        // 334\n  });                                                                                                                // 335\n};                                                                                                                   // 336\n                                                                                                                     // 337\n/**                                                                                                                  // 338\n * Creates a new network                                                                                             // 339\n * @param {Object}   opts     Create options                                                                         // 340\n * @param {Function} callback Callback                                                                               // 341\n */                                                                                                                  // 342\nDocker.prototype.createNetwork = function(opts, callback) {                                                          // 343\n  var args = util.processArgs(opts, callback);                                                                       // 344\n  var self = this;                                                                                                   // 345\n  var optsf = {                                                                                                      // 346\n    path: '/networks/create?',                                                                                       // 347\n    method: 'POST',                                                                                                  // 348\n    options: args.opts,                                                                                              // 349\n    statusCodes: {                                                                                                   // 350\n      200: true, // unofficial, but proxies may return it                                                            // 351\n      201: true,                                                                                                     // 352\n      404: 'driver not found',                                                                                       // 353\n      500: 'server error'                                                                                            // 354\n    }                                                                                                                // 355\n  };                                                                                                                 // 356\n                                                                                                                     // 357\n  this.modem.dial(optsf, function(err, data) {                                                                       // 358\n    if (err) return args.callback(err, data);                                                                        // 359\n    args.callback(err, self.getNetwork(data.Id));                                                                    // 360\n  });                                                                                                                // 361\n};                                                                                                                   // 362\n                                                                                                                     // 363\n/**                                                                                                                  // 364\n * Lists networkss                                                                                                   // 365\n * @param {Options}   opts     Options (optional)                                                                    // 366\n * @param {Function} callback Callback                                                                               // 367\n */                                                                                                                  // 368\nDocker.prototype.listNetworks = function(opts, callback) {                                                           // 369\n  var args = util.processArgs(opts, callback);                                                                       // 370\n                                                                                                                     // 371\n  var optsf = {                                                                                                      // 372\n    path: '/networks?',                                                                                              // 373\n    method: 'GET',                                                                                                   // 374\n    options: args.opts,                                                                                              // 375\n    statusCodes: {                                                                                                   // 376\n      200: true,                                                                                                     // 377\n      400: 'bad parameter',                                                                                          // 378\n      500: 'server error'                                                                                            // 379\n    }                                                                                                                // 380\n  };                                                                                                                 // 381\n                                                                                                                     // 382\n  this.modem.dial(optsf, function(err, data) {                                                                       // 383\n    args.callback(err, data);                                                                                        // 384\n  });                                                                                                                // 385\n};                                                                                                                   // 386\n                                                                                                                     // 387\n/**                                                                                                                  // 388\n * Search images                                                                                                     // 389\n * @param {Object}   opts     Options                                                                                // 390\n * @param {Function} callback Callback                                                                               // 391\n */                                                                                                                  // 392\nDocker.prototype.searchImages = function(opts, callback) {                                                           // 393\n  var optsf = {                                                                                                      // 394\n    path: '/images/search?',                                                                                         // 395\n    method: 'GET',                                                                                                   // 396\n    options: opts,                                                                                                   // 397\n    statusCodes: {                                                                                                   // 398\n      200: true,                                                                                                     // 399\n      500: 'server error'                                                                                            // 400\n    }                                                                                                                // 401\n  };                                                                                                                 // 402\n                                                                                                                     // 403\n  this.modem.dial(optsf, function(err, data) {                                                                       // 404\n    callback(err, data);                                                                                             // 405\n  });                                                                                                                // 406\n};                                                                                                                   // 407\n                                                                                                                     // 408\n/**                                                                                                                  // 409\n * Info                                                                                                              // 410\n * @param  {Function} callback Callback with info                                                                    // 411\n */                                                                                                                  // 412\nDocker.prototype.info = function(callback) {                                                                         // 413\n  var opts = {                                                                                                       // 414\n    path: '/info',                                                                                                   // 415\n    method: 'GET',                                                                                                   // 416\n    statusCodes: {                                                                                                   // 417\n      200: true,                                                                                                     // 418\n      500: 'server error'                                                                                            // 419\n    }                                                                                                                // 420\n  };                                                                                                                 // 421\n                                                                                                                     // 422\n  this.modem.dial(opts, function(err, data) {                                                                        // 423\n    callback(err, data);                                                                                             // 424\n  });                                                                                                                // 425\n};                                                                                                                   // 426\n                                                                                                                     // 427\n/**                                                                                                                  // 428\n * Version                                                                                                           // 429\n * @param  {Function} callback Callback                                                                              // 430\n */                                                                                                                  // 431\nDocker.prototype.version = function(callback) {                                                                      // 432\n  var opts = {                                                                                                       // 433\n    path: '/version',                                                                                                // 434\n    method: 'GET',                                                                                                   // 435\n    statusCodes: {                                                                                                   // 436\n      200: true,                                                                                                     // 437\n      500: 'server error'                                                                                            // 438\n    }                                                                                                                // 439\n  };                                                                                                                 // 440\n                                                                                                                     // 441\n  this.modem.dial(opts, function(err, data) {                                                                        // 442\n    callback(err, data);                                                                                             // 443\n  });                                                                                                                // 444\n};                                                                                                                   // 445\n                                                                                                                     // 446\n/**                                                                                                                  // 447\n * Ping                                                                                                              // 448\n * @param  {Function} callback Callback                                                                              // 449\n */                                                                                                                  // 450\nDocker.prototype.ping = function(callback) {                                                                         // 451\n  if (!callback && typeof opts === 'function') {                                                                     // 452\n    callback = opts;                                                                                                 // 453\n    opts = null;                                                                                                     // 454\n  }                                                                                                                  // 455\n                                                                                                                     // 456\n  var optsf = {                                                                                                      // 457\n    path: '/_ping',                                                                                                  // 458\n    method: 'GET',                                                                                                   // 459\n    statusCodes: {                                                                                                   // 460\n      200: true,                                                                                                     // 461\n      500: 'server error'                                                                                            // 462\n    }                                                                                                                // 463\n  };                                                                                                                 // 464\n                                                                                                                     // 465\n  this.modem.dial(optsf, function(err, data) {                                                                       // 466\n    callback(err, data);                                                                                             // 467\n  });                                                                                                                // 468\n};                                                                                                                   // 469\n                                                                                                                     // 470\n/**                                                                                                                  // 471\n * Events                                                                                                            // 472\n * @param {Object}   opts     Events options, like 'since' (optional)                                                // 473\n * @param {Function} callback Callback                                                                               // 474\n */                                                                                                                  // 475\nDocker.prototype.getEvents = function(opts, callback) {                                                              // 476\n  var args = util.processArgs(opts, callback);                                                                       // 477\n                                                                                                                     // 478\n  var optsf = {                                                                                                      // 479\n    path: '/events?',                                                                                                // 480\n    method: 'GET',                                                                                                   // 481\n    options: args.opts,                                                                                              // 482\n    isStream: true,                                                                                                  // 483\n    statusCodes: {                                                                                                   // 484\n      200: true,                                                                                                     // 485\n      500: 'server error'                                                                                            // 486\n    }                                                                                                                // 487\n  };                                                                                                                 // 488\n                                                                                                                     // 489\n  this.modem.dial(optsf, function(err, data) {                                                                       // 490\n    args.callback(err, data);                                                                                        // 491\n  });                                                                                                                // 492\n};                                                                                                                   // 493\n                                                                                                                     // 494\n/**                                                                                                                  // 495\n * Pull is a wrapper around parsing out the tag from the image                                                       // 496\n * (which create image cannot do but run can for whatever reasons) and create image overloading.                     // 497\n * @param  {String}   repoTag  Repository tag                                                                        // 498\n * @param  {Object}   opts     Options (optional)                                                                    // 499\n * @param  {Function} callback Callback                                                                              // 500\n * @param  {Object}   auth     Authentication (optional)                                                             // 501\n * @return {Object}            Image                                                                                 // 502\n */                                                                                                                  // 503\nDocker.prototype.pull = function(repoTag, opts, callback, auth) {                                                    // 504\n  var args = util.processArgs(opts, callback);                                                                       // 505\n                                                                                                                     // 506\n  var imageSrc = util.parseRepositoryTag(repoTag);                                                                   // 507\n  args.opts.fromImage = imageSrc.repository;                                                                         // 508\n  args.opts.tag = imageSrc.tag;                                                                                      // 509\n                                                                                                                     // 510\n  var argsf = [args.opts, args.callback];                                                                            // 511\n  if (auth) {                                                                                                        // 512\n    argsf = [auth, args.opts, args.callback];                                                                        // 513\n  }                                                                                                                  // 514\n  return this.createImage.apply(this, argsf);                                                                        // 515\n};                                                                                                                   // 516\n                                                                                                                     // 517\n/**                                                                                                                  // 518\n * Like run command from Docker's CLI                                                                                // 519\n * @param  {String}   image         Image name to be used.                                                           // 520\n * @param  {Array}   cmd           Command to run in array format.                                                   // 521\n * @param  {Object}   streamo       Output stream                                                                    // 522\n * @param  {Object}   createOptions Container create options (optional)                                              // 523\n * @param  {Object}   startOptions  Container start options (optional)                                               // 524\n * @param  {Function} callback      Callback                                                                         // 525\n * @return {Object}                 EventEmitter                                                                     // 526\n */                                                                                                                  // 527\nDocker.prototype.run = function(image, cmd, streamo, createOptions, startOptions, callback) {                        // 528\n  if (!callback && typeof createOptions === 'function') {                                                            // 529\n    callback = createOptions;                                                                                        // 530\n    createOptions = {};                                                                                              // 531\n    startOptions = {};                                                                                               // 532\n  } else if (!callback && typeof startOptions === 'function') {                                                      // 533\n    callback = startOptions;                                                                                         // 534\n    startOptions = {};                                                                                               // 535\n  }                                                                                                                  // 536\n                                                                                                                     // 537\n  var hub = new EventEmitter();                                                                                      // 538\n                                                                                                                     // 539\n  function handler(err, container) {                                                                                 // 540\n    if (err) return callback(err, null, container);                                                                  // 541\n                                                                                                                     // 542\n    hub.emit('container', container);                                                                                // 543\n                                                                                                                     // 544\n    container.attach({                                                                                               // 545\n      stream: true,                                                                                                  // 546\n      stdout: true,                                                                                                  // 547\n      stderr: true                                                                                                   // 548\n    }, function handler(err, stream) {                                                                               // 549\n      if (err) return callback(err, null, container);                                                                // 550\n                                                                                                                     // 551\n      hub.emit('stream', stream);                                                                                    // 552\n                                                                                                                     // 553\n      if (streamo) {                                                                                                 // 554\n        if (streamo instanceof Array) {                                                                              // 555\n          stream.on('end', function() {                                                                              // 556\n            try {                                                                                                    // 557\n              streamo[0].end();                                                                                      // 558\n            } catch (e) {}                                                                                           // 559\n            try {                                                                                                    // 560\n              streamo[1].end();                                                                                      // 561\n            } catch (e) {}                                                                                           // 562\n          });                                                                                                        // 563\n          container.modem.demuxStream(stream, streamo[0], streamo[1]);                                               // 564\n        } else {                                                                                                     // 565\n          stream.setEncoding('utf8');                                                                                // 566\n          stream.pipe(streamo, {                                                                                     // 567\n            end: true                                                                                                // 568\n          });                                                                                                        // 569\n        }                                                                                                            // 570\n      }                                                                                                              // 571\n                                                                                                                     // 572\n      container.start(startOptions, function(err, data) {                                                            // 573\n        if (err) return callback(err, data, container);                                                              // 574\n                                                                                                                     // 575\n        container.wait(function(err, data) {                                                                         // 576\n          hub.emit('data', data);                                                                                    // 577\n          callback(err, data, container);                                                                            // 578\n        });                                                                                                          // 579\n      });                                                                                                            // 580\n    });                                                                                                              // 581\n  }                                                                                                                  // 582\n                                                                                                                     // 583\n  var optsc = {                                                                                                      // 584\n    'Hostname': '',                                                                                                  // 585\n    'User': '',                                                                                                      // 586\n    'AttachStdin': false,                                                                                            // 587\n    'AttachStdout': true,                                                                                            // 588\n    'AttachStderr': true,                                                                                            // 589\n    'Tty': true,                                                                                                     // 590\n    'OpenStdin': false,                                                                                              // 591\n    'StdinOnce': false,                                                                                              // 592\n    'Env': null,                                                                                                     // 593\n    'Cmd': cmd,                                                                                                      // 594\n    'Image': image,                                                                                                  // 595\n    'Volumes': {},                                                                                                   // 596\n    'VolumesFrom': []                                                                                                // 597\n  };                                                                                                                 // 598\n                                                                                                                     // 599\n  extend(optsc, createOptions);                                                                                      // 600\n                                                                                                                     // 601\n  this.createContainer(optsc, handler);                                                                              // 602\n                                                                                                                     // 603\n  return hub;                                                                                                        // 604\n};                                                                                                                   // 605\n                                                                                                                     // 606\nmodule.exports = Docker;                                                                                             // 607\n                                                                                                                     // 608\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"container.js\":[\"./util\",\"./exec\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/container.js                                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar extend = require('./util').extend,                                                                               // 1\n  Exec = require('./exec'),                                                                                          // 2\n  util = require('./util');                                                                                          // 3\n                                                                                                                     // 4\n/**                                                                                                                  // 5\n * Represents a Container                                                                                            // 6\n * @param {Object} modem docker-modem                                                                                // 7\n * @param {String} id    Container's ID                                                                              // 8\n */                                                                                                                  // 9\nvar Container = function(modem, id) {                                                                                // 10\n  this.modem = modem;                                                                                                // 11\n  this.id = id;                                                                                                      // 12\n                                                                                                                     // 13\n  this.defaultOptions = {                                                                                            // 14\n    top: {},                                                                                                         // 15\n    start: {},                                                                                                       // 16\n    commit: {},                                                                                                      // 17\n    stop: {},                                                                                                        // 18\n    pause: {},                                                                                                       // 19\n    unpause: {},                                                                                                     // 20\n    restart: {},                                                                                                     // 21\n    resize: {},                                                                                                      // 22\n    attach: {},                                                                                                      // 23\n    remove: {},                                                                                                      // 24\n    copy: {},                                                                                                        // 25\n    kill: {},                                                                                                        // 26\n    exec: {},                                                                                                        // 27\n    rename: {},                                                                                                      // 28\n    log: {},                                                                                                         // 29\n    stats: {},                                                                                                       // 30\n    getArchive: {},                                                                                                  // 31\n    infoArchive: {},                                                                                                 // 32\n    putArchive: {},                                                                                                  // 33\n    update: {}                                                                                                       // 34\n  };                                                                                                                 // 35\n};                                                                                                                   // 36\n                                                                                                                     // 37\n/**                                                                                                                  // 38\n * Inspect                                                                                                           // 39\n * @param  {Options}  opts     Options (optional)                                                                    // 40\n * @param  {Function} callback Callback, if supplied will query Docker.                                              // 41\n * @return {Object}            ID only and only if callback isn't supplied.                                          // 42\n */                                                                                                                  // 43\nContainer.prototype.inspect = function(opts, callback) {                                                             // 44\n  var args = util.processArgs(opts, callback);                                                                       // 45\n                                                                                                                     // 46\n  if (typeof args.callback === 'function') {                                                                         // 47\n    var optsf = {                                                                                                    // 48\n      path: '/containers/' + this.id + '/json?',                                                                     // 49\n      method: 'GET',                                                                                                 // 50\n      options: args.opts,                                                                                            // 51\n      statusCodes: {                                                                                                 // 52\n        200: true,                                                                                                   // 53\n        404: 'no such container',                                                                                    // 54\n        500: 'server error'                                                                                          // 55\n      }                                                                                                              // 56\n    };                                                                                                               // 57\n                                                                                                                     // 58\n    this.modem.dial(optsf, function(err, data) {                                                                     // 59\n      args.callback(err, data);                                                                                      // 60\n    });                                                                                                              // 61\n  } else {                                                                                                           // 62\n    return JSON.stringify({                                                                                          // 63\n      id: this.id                                                                                                    // 64\n    });                                                                                                              // 65\n  }                                                                                                                  // 66\n};                                                                                                                   // 67\n                                                                                                                     // 68\n/**                                                                                                                  // 69\n * Rename                                                                                                            // 70\n * @param  {Object}   opts     Rename options                                                                        // 71\n * @param  {Function} callback Callback                                                                              // 72\n */                                                                                                                  // 73\nContainer.prototype.rename = function(opts, callback) {                                                              // 74\n  var args = util.processArgs(opts, callback, this.defaultOptions.rename);                                           // 75\n                                                                                                                     // 76\n  var optsf = {                                                                                                      // 77\n    path: '/containers/' + this.id + '/rename?',                                                                     // 78\n    method: 'POST',                                                                                                  // 79\n    statusCodes: {                                                                                                   // 80\n      200: true,                                                                                                     // 81\n      204: true,                                                                                                     // 82\n      404: 'no such container',                                                                                      // 83\n      500: 'server error'                                                                                            // 84\n    },                                                                                                               // 85\n    options: args.opts                                                                                               // 86\n  };                                                                                                                 // 87\n                                                                                                                     // 88\n  this.modem.dial(optsf, function(err, data) {                                                                       // 89\n    args.callback(err, data);                                                                                        // 90\n  });                                                                                                                // 91\n};                                                                                                                   // 92\n                                                                                                                     // 93\n/**                                                                                                                  // 94\n * Update                                                                                                            // 95\n * @param  {Object}   opts     Update options                                                                        // 96\n * @param  {Function} callback Callback                                                                              // 97\n */                                                                                                                  // 98\nContainer.prototype.update = function(opts, callback) {                                                              // 99\n  var args = util.processArgs(opts, callback, this.defaultOptions.update);                                           // 100\n                                                                                                                     // 101\n  var optsf = {                                                                                                      // 102\n    path: '/containers/' + this.id + '/update',                                                                      // 103\n    method: 'POST',                                                                                                  // 104\n    statusCodes: {                                                                                                   // 105\n      200: true,                                                                                                     // 106\n      204: true,                                                                                                     // 107\n      400: 'bad parameter',                                                                                          // 108\n      404: 'no such container',                                                                                      // 109\n      500: 'server error'                                                                                            // 110\n    },                                                                                                               // 111\n    options: args.opts                                                                                               // 112\n  };                                                                                                                 // 113\n                                                                                                                     // 114\n  this.modem.dial(optsf, function(err, data) {                                                                       // 115\n    args.callback(err, data);                                                                                        // 116\n  });                                                                                                                // 117\n};                                                                                                                   // 118\n                                                                                                                     // 119\n/**                                                                                                                  // 120\n * Top                                                                                                               // 121\n * @param  {Object}   Options like 'ps_args' (optional)                                                              // 122\n * @param  {Function} callback Callback                                                                              // 123\n */                                                                                                                  // 124\nContainer.prototype.top = function(opts, callback) {                                                                 // 125\n  var args = util.processArgs(opts, callback, this.defaultOptions.top);                                              // 126\n                                                                                                                     // 127\n  var optsf = {                                                                                                      // 128\n    path: '/containers/' + this.id + '/top?',                                                                        // 129\n    method: 'GET',                                                                                                   // 130\n    statusCodes: {                                                                                                   // 131\n      200: true,                                                                                                     // 132\n      404: 'no such container',                                                                                      // 133\n      500: 'server error'                                                                                            // 134\n    },                                                                                                               // 135\n    options: args.opts                                                                                               // 136\n  };                                                                                                                 // 137\n                                                                                                                     // 138\n  this.modem.dial(optsf, function(err, data) {                                                                       // 139\n    args.callback(err, data);                                                                                        // 140\n  });                                                                                                                // 141\n};                                                                                                                   // 142\n                                                                                                                     // 143\n/**                                                                                                                  // 144\n * Containers changes                                                                                                // 145\n * @param  {Function} callback Callback                                                                              // 146\n */                                                                                                                  // 147\nContainer.prototype.changes = function(callback) {                                                                   // 148\n  var optsf = {                                                                                                      // 149\n    path: '/containers/' + this.id + '/changes',                                                                     // 150\n    method: 'GET',                                                                                                   // 151\n    statusCodes: {                                                                                                   // 152\n      200: true,                                                                                                     // 153\n      404: 'no such container',                                                                                      // 154\n      500: 'server error'                                                                                            // 155\n    }                                                                                                                // 156\n  };                                                                                                                 // 157\n                                                                                                                     // 158\n  this.modem.dial(optsf, function(err, data) {                                                                       // 159\n    callback(err, data);                                                                                             // 160\n  });                                                                                                                // 161\n};                                                                                                                   // 162\n                                                                                                                     // 163\n/**                                                                                                                  // 164\n * Export                                                                                                            // 165\n * @param  {Function} callback Callback with the octet-stream.                                                       // 166\n */                                                                                                                  // 167\nContainer.prototype.export = function(callback) {                                                                    // 168\n  var optsf = {                                                                                                      // 169\n    path: '/containers/' + this.id + '/export',                                                                      // 170\n    method: 'GET',                                                                                                   // 171\n    isStream: true,                                                                                                  // 172\n    statusCodes: {                                                                                                   // 173\n      200: true,                                                                                                     // 174\n      404: 'no such container',                                                                                      // 175\n      500: 'server error'                                                                                            // 176\n    }                                                                                                                // 177\n  };                                                                                                                 // 178\n                                                                                                                     // 179\n  this.modem.dial(optsf, function(err, data) {                                                                       // 180\n    callback(err, data);                                                                                             // 181\n  });                                                                                                                // 182\n};                                                                                                                   // 183\n                                                                                                                     // 184\n/**                                                                                                                  // 185\n * Start                                                                                                             // 186\n * @param  {Object}   opts     Container start options (optional)                                                    // 187\n * @param  {Function} callback Callback                                                                              // 188\n */                                                                                                                  // 189\nContainer.prototype.start = function(opts, callback) {                                                               // 190\n  var args = util.processArgs(opts, callback, this.defaultOptions.start);                                            // 191\n                                                                                                                     // 192\n  var optsf = {                                                                                                      // 193\n    path: '/containers/' + this.id + '/start',                                                                       // 194\n    method: 'POST',                                                                                                  // 195\n    statusCodes: {                                                                                                   // 196\n      200: true, // unofficial, but proxies may return it                                                            // 197\n      204: true,                                                                                                     // 198\n      304: 'container already started',                                                                              // 199\n      404: 'no such container',                                                                                      // 200\n      500: 'server error'                                                                                            // 201\n    },                                                                                                               // 202\n    options: args.opts                                                                                               // 203\n  };                                                                                                                 // 204\n                                                                                                                     // 205\n  this.modem.dial(optsf, function(err, data) {                                                                       // 206\n    args.callback(err, data);                                                                                        // 207\n  });                                                                                                                // 208\n};                                                                                                                   // 209\n                                                                                                                     // 210\n/**                                                                                                                  // 211\n * Pause                                                                                                             // 212\n * @param  {Object}   opts     Pause options (optional)                                                              // 213\n * @param  {Function} callback Callback                                                                              // 214\n */                                                                                                                  // 215\nContainer.prototype.pause = function(opts, callback) {                                                               // 216\n  var args = util.processArgs(opts, callback, this.defaultOptions.pause);                                            // 217\n                                                                                                                     // 218\n  var optsf = {                                                                                                      // 219\n    path: '/containers/' + this.id + '/pause',                                                                       // 220\n    method: 'POST',                                                                                                  // 221\n    statusCodes: {                                                                                                   // 222\n      200: true, // unofficial, but proxies may return it                                                            // 223\n      204: true,                                                                                                     // 224\n      500: 'server error'                                                                                            // 225\n    },                                                                                                               // 226\n    options: args.opts                                                                                               // 227\n  };                                                                                                                 // 228\n                                                                                                                     // 229\n  this.modem.dial(optsf, function(err, data) {                                                                       // 230\n    args.callback(err, data);                                                                                        // 231\n  });                                                                                                                // 232\n};                                                                                                                   // 233\n                                                                                                                     // 234\n/**                                                                                                                  // 235\n * Unpause                                                                                                           // 236\n * @param  {Object}   opts     Unpause options (optional)                                                            // 237\n * @param  {Function} callback Callback                                                                              // 238\n */                                                                                                                  // 239\nContainer.prototype.unpause = function(opts, callback) {                                                             // 240\n  var args = util.processArgs(opts, callback, this.defaultOptions.unpause);                                          // 241\n                                                                                                                     // 242\n  var optsf = {                                                                                                      // 243\n    path: '/containers/' + this.id + '/unpause',                                                                     // 244\n    method: 'POST',                                                                                                  // 245\n    statusCodes: {                                                                                                   // 246\n      200: true, // unofficial, but proxies may return it                                                            // 247\n      204: true,                                                                                                     // 248\n      404: 'no such container',                                                                                      // 249\n      500: 'server error'                                                                                            // 250\n    },                                                                                                               // 251\n    options: args.opts                                                                                               // 252\n  };                                                                                                                 // 253\n                                                                                                                     // 254\n  this.modem.dial(optsf, function(err, data) {                                                                       // 255\n    args.callback(err, data);                                                                                        // 256\n  });                                                                                                                // 257\n};                                                                                                                   // 258\n                                                                                                                     // 259\n/**                                                                                                                  // 260\n * Setup an exec call to a running container                                                                         // 261\n *                                                                                                                   // 262\n * @param {object} opts                                                                                              // 263\n * @param {function} callback                                                                                        // 264\n */                                                                                                                  // 265\nContainer.prototype.exec = function(opts, callback) {                                                                // 266\n  var args = util.processArgs(opts, callback, this.defaultOptions.exec);                                             // 267\n                                                                                                                     // 268\n  var optsf = {                                                                                                      // 269\n    path: '/containers/' + this.id + '/exec',                                                                        // 270\n    method: 'POST',                                                                                                  // 271\n    statusCodes: {                                                                                                   // 272\n      200: true, // unofficial, but proxies may return it                                                            // 273\n      201: true,                                                                                                     // 274\n      404: 'no such container',                                                                                      // 275\n      500: 'server error'                                                                                            // 276\n    },                                                                                                               // 277\n    options: args.opts                                                                                               // 278\n  };                                                                                                                 // 279\n                                                                                                                     // 280\n  var self = this;                                                                                                   // 281\n  this.modem.dial(optsf, function(err, data) {                                                                       // 282\n    if (err) return args.callback(err, data);                                                                        // 283\n    args.callback(err, new Exec(self.modem, data.Id));                                                               // 284\n  });                                                                                                                // 285\n};                                                                                                                   // 286\n                                                                                                                     // 287\n/**                                                                                                                  // 288\n * Commit                                                                                                            // 289\n * @param  {Object}   opts     Commit options like 'Hostname' (optional)                                             // 290\n * @param  {Function} callback Callback                                                                              // 291\n */                                                                                                                  // 292\nContainer.prototype.commit = function(opts, callback) {                                                              // 293\n  var args = util.processArgs(opts, callback, this.defaultOptions.commit);                                           // 294\n                                                                                                                     // 295\n  args.opts.container = this.id;                                                                                     // 296\n                                                                                                                     // 297\n  var optsf = {                                                                                                      // 298\n    path: '/commit?',                                                                                                // 299\n    method: 'POST',                                                                                                  // 300\n    statusCodes: {                                                                                                   // 301\n      200: true, // unofficial, but proxies may return it                                                            // 302\n      201: true,                                                                                                     // 303\n      404: 'no such container',                                                                                      // 304\n      500: 'server error'                                                                                            // 305\n    },                                                                                                               // 306\n    options: args.opts                                                                                               // 307\n  };                                                                                                                 // 308\n                                                                                                                     // 309\n  this.modem.dial(optsf, function(err, data) {                                                                       // 310\n    args.callback(err, data);                                                                                        // 311\n  });                                                                                                                // 312\n};                                                                                                                   // 313\n                                                                                                                     // 314\n/**                                                                                                                  // 315\n * Stop                                                                                                              // 316\n * @param  {Object}   opts     Container stop options, like 't' (optional)                                           // 317\n * @param  {Function} callback Callback                                                                              // 318\n */                                                                                                                  // 319\nContainer.prototype.stop = function(opts, callback) {                                                                // 320\n  var args = util.processArgs(opts, callback, this.defaultOptions.stop);                                             // 321\n                                                                                                                     // 322\n  var optsf = {                                                                                                      // 323\n    path: '/containers/' + this.id + '/stop?',                                                                       // 324\n    method: 'POST',                                                                                                  // 325\n    statusCodes: {                                                                                                   // 326\n      200: true, // unofficial, but proxies may return it                                                            // 327\n      204: true,                                                                                                     // 328\n      304: 'container already stopped',                                                                              // 329\n      404: 'no such container',                                                                                      // 330\n      500: 'server error'                                                                                            // 331\n    },                                                                                                               // 332\n    options: args.opts                                                                                               // 333\n  };                                                                                                                 // 334\n                                                                                                                     // 335\n  this.modem.dial(optsf, function(err, data) {                                                                       // 336\n    args.callback(err, data);                                                                                        // 337\n  });                                                                                                                // 338\n};                                                                                                                   // 339\n                                                                                                                     // 340\n/**                                                                                                                  // 341\n * Restart                                                                                                           // 342\n * @param  {Object}   opts     Container restart options, like 't' (optional)                                        // 343\n * @param  {Function} callback Callback                                                                              // 344\n */                                                                                                                  // 345\nContainer.prototype.restart = function(opts, callback) {                                                             // 346\n  var args = util.processArgs(opts, callback, this.defaultOptions.restart);                                          // 347\n                                                                                                                     // 348\n  var optsf = {                                                                                                      // 349\n    path: '/containers/' + this.id + '/restart',                                                                     // 350\n    method: 'POST',                                                                                                  // 351\n    statusCodes: {                                                                                                   // 352\n      200: true, // unofficial, but proxies may return it                                                            // 353\n      204: true,                                                                                                     // 354\n      404: 'no such container',                                                                                      // 355\n      500: 'server error'                                                                                            // 356\n    },                                                                                                               // 357\n    options: args.opts                                                                                               // 358\n  };                                                                                                                 // 359\n                                                                                                                     // 360\n  this.modem.dial(optsf, function(err, data) {                                                                       // 361\n    args.callback(err, data);                                                                                        // 362\n  });                                                                                                                // 363\n};                                                                                                                   // 364\n                                                                                                                     // 365\n/**                                                                                                                  // 366\n * Kill                                                                                                              // 367\n * @param  {Object}   opts     Container kill options, like 'signal' (optional)                                      // 368\n * @param  {Function} callback Callback                                                                              // 369\n */                                                                                                                  // 370\nContainer.prototype.kill = function(opts, callback) {                                                                // 371\n  var args = util.processArgs(opts, callback, this.defaultOptions.kill);                                             // 372\n                                                                                                                     // 373\n  var optsf = {                                                                                                      // 374\n    path: '/containers/' + this.id + '/kill?',                                                                       // 375\n    method: 'POST',                                                                                                  // 376\n    statusCodes: {                                                                                                   // 377\n      200: true, // unofficial, but proxies may return it                                                            // 378\n      204: true,                                                                                                     // 379\n      404: 'no such container',                                                                                      // 380\n      500: 'server error'                                                                                            // 381\n    },                                                                                                               // 382\n    options: args.opts                                                                                               // 383\n  };                                                                                                                 // 384\n                                                                                                                     // 385\n  this.modem.dial(optsf, function(err, data) {                                                                       // 386\n    args.callback(err, data);                                                                                        // 387\n  });                                                                                                                // 388\n};                                                                                                                   // 389\n                                                                                                                     // 390\n/**                                                                                                                  // 391\n * Container resize                                                                                                  // 392\n * @param  {[type]}   opts     Resize options. (optional)                                                            // 393\n * @param  {Function} callback Callback                                                                              // 394\n */                                                                                                                  // 395\nContainer.prototype.resize = function(opts, callback) {                                                              // 396\n  var args = util.processArgs(opts, callback, this.defaultOptions.resize);                                           // 397\n                                                                                                                     // 398\n  var optsf = {                                                                                                      // 399\n    path: '/containers/' + this.id + '/resize?',                                                                     // 400\n    method: 'POST',                                                                                                  // 401\n    statusCodes: {                                                                                                   // 402\n      200: true,                                                                                                     // 403\n      400: 'bad parameter',                                                                                          // 404\n      404: 'no such container',                                                                                      // 405\n      500: 'server error'                                                                                            // 406\n    },                                                                                                               // 407\n    options: args.opts                                                                                               // 408\n  };                                                                                                                 // 409\n                                                                                                                     // 410\n  this.modem.dial(optsf, function(err, data) {                                                                       // 411\n    args.callback(err, data);                                                                                        // 412\n  });                                                                                                                // 413\n};                                                                                                                   // 414\n                                                                                                                     // 415\n/**                                                                                                                  // 416\n * Attach                                                                                                            // 417\n * @param  {Object}   opts     Attach options, like 'logs' (optional)                                                // 418\n * @param  {Function} callback Callback with stream.                                                                 // 419\n */                                                                                                                  // 420\nContainer.prototype.attach = function(opts, callback) {                                                              // 421\n  var args = util.processArgs(opts, callback, this.defaultOptions.attach);                                           // 422\n                                                                                                                     // 423\n  var optsf = {                                                                                                      // 424\n    path: '/containers/' + this.id + '/attach?',                                                                     // 425\n    method: 'POST',                                                                                                  // 426\n    isStream: true,                                                                                                  // 427\n    hijack: args.opts.hijack,                                                                                        // 428\n    openStdin: args.opts.stdin,                                                                                      // 429\n    statusCodes: {                                                                                                   // 430\n      200: true,                                                                                                     // 431\n      404: 'no such container',                                                                                      // 432\n      500: 'server error'                                                                                            // 433\n    },                                                                                                               // 434\n    options: args.opts                                                                                               // 435\n  };                                                                                                                 // 436\n                                                                                                                     // 437\n  this.modem.dial(optsf, function(err, stream) {                                                                     // 438\n    args.callback(err, stream);                                                                                      // 439\n  });                                                                                                                // 440\n};                                                                                                                   // 441\n                                                                                                                     // 442\n/**                                                                                                                  // 443\n * Waits for a container to end.                                                                                     // 444\n * @param  {Function} callback Callback                                                                              // 445\n */                                                                                                                  // 446\nContainer.prototype.wait = function(callback) {                                                                      // 447\n  var optsf = {                                                                                                      // 448\n    path: '/containers/' + this.id + '/wait',                                                                        // 449\n    method: 'POST',                                                                                                  // 450\n    statusCodes: {                                                                                                   // 451\n      200: true,                                                                                                     // 452\n      400: 'bad parameter',                                                                                          // 453\n      404: 'no such container',                                                                                      // 454\n      500: 'server error'                                                                                            // 455\n    }                                                                                                                // 456\n  };                                                                                                                 // 457\n                                                                                                                     // 458\n  this.modem.dial(optsf, function(err, data) {                                                                       // 459\n    callback(err, data);                                                                                             // 460\n  });                                                                                                                // 461\n};                                                                                                                   // 462\n                                                                                                                     // 463\n/**                                                                                                                  // 464\n * Removes a container                                                                                               // 465\n * @param  {Object}   opts     Remove options, like 'force' (optional)                                               // 466\n * @param  {Function} callback Callback                                                                              // 467\n */                                                                                                                  // 468\nContainer.prototype.remove = function(opts, callback) {                                                              // 469\n  var args = util.processArgs(opts, callback, this.defaultOptions.remove);                                           // 470\n                                                                                                                     // 471\n  var optsf = {                                                                                                      // 472\n    path: '/containers/' + this.id + '?',                                                                            // 473\n    method: 'DELETE',                                                                                                // 474\n    statusCodes: {                                                                                                   // 475\n      200: true, // unofficial, but proxies may return it                                                            // 476\n      204: true,                                                                                                     // 477\n      400: 'bad parameter',                                                                                          // 478\n      404: 'no such container',                                                                                      // 479\n      500: 'server error'                                                                                            // 480\n    },                                                                                                               // 481\n    options: args.opts                                                                                               // 482\n  };                                                                                                                 // 483\n                                                                                                                     // 484\n  this.modem.dial(optsf, function(err, data) {                                                                       // 485\n    args.callback(err, data);                                                                                        // 486\n  });                                                                                                                // 487\n};                                                                                                                   // 488\n                                                                                                                     // 489\n/**                                                                                                                  // 490\n * Copy (WARNING: DEPRECATED since RAPI v1.20)                                                                       // 491\n * @param  {Object}   opts     Copy options, like 'Resource' (optional)                                              // 492\n * @param  {Function} callback Callback with stream.                                                                 // 493\n */                                                                                                                  // 494\nContainer.prototype.copy = function(opts, callback) {                                                                // 495\n  console.log('container.copy is deprecated since Docker v1.8.x');                                                   // 496\n  var args = util.processArgs(opts, callback, this.defaultOptions.copy);                                             // 497\n                                                                                                                     // 498\n  var optsf = {                                                                                                      // 499\n    path: '/containers/' + this.id + '/copy',                                                                        // 500\n    method: 'POST',                                                                                                  // 501\n    isStream: true,                                                                                                  // 502\n    statusCodes: {                                                                                                   // 503\n      200: true,                                                                                                     // 504\n      404: 'no such container',                                                                                      // 505\n      500: 'server error'                                                                                            // 506\n    },                                                                                                               // 507\n    options: args.opts                                                                                               // 508\n  };                                                                                                                 // 509\n                                                                                                                     // 510\n  this.modem.dial(optsf, function(err, data) {                                                                       // 511\n    args.callback(err, data);                                                                                        // 512\n  });                                                                                                                // 513\n};                                                                                                                   // 514\n                                                                                                                     // 515\n/**                                                                                                                  // 516\n * getArchive                                                                                                        // 517\n * @param  {Object}   opts     Archive options, like 'path'                                                          // 518\n * @param  {Function} callback Callback with stream.                                                                 // 519\n */                                                                                                                  // 520\nContainer.prototype.getArchive = function(opts, callback) {                                                          // 521\n  var args = util.processArgs(opts, callback, this.defaultOptions.getArchive);                                       // 522\n                                                                                                                     // 523\n  var optsf = {                                                                                                      // 524\n    path: '/containers/' + this.id + '/archive?',                                                                    // 525\n    method: 'GET',                                                                                                   // 526\n    isStream: true,                                                                                                  // 527\n    statusCodes: {                                                                                                   // 528\n      200: true,                                                                                                     // 529\n      400: 'client error, bad parameters',                                                                           // 530\n      404: 'no such container',                                                                                      // 531\n      500: 'server error'                                                                                            // 532\n    },                                                                                                               // 533\n    options: args.opts                                                                                               // 534\n  };                                                                                                                 // 535\n                                                                                                                     // 536\n  this.modem.dial(optsf, function(err, data) {                                                                       // 537\n    args.callback(err, data);                                                                                        // 538\n  });                                                                                                                // 539\n};                                                                                                                   // 540\n                                                                                                                     // 541\n/**                                                                                                                  // 542\n * infoArchive                                                                                                       // 543\n * @param  {Object}   opts     Archive options, like 'path'                                                          // 544\n * @param  {Function} callback Callback with stream.                                                                 // 545\n */                                                                                                                  // 546\nContainer.prototype.infoArchive = function(opts, callback) {                                                         // 547\n  var args = util.processArgs(opts, callback, this.defaultOptions.infoArchive);                                      // 548\n                                                                                                                     // 549\n  var optsf = {                                                                                                      // 550\n    path: '/containers/' + this.id + '/archive?',                                                                    // 551\n    method: 'HEAD',                                                                                                  // 552\n    isStream: true,                                                                                                  // 553\n    statusCodes: {                                                                                                   // 554\n      200: true,                                                                                                     // 555\n      400: 'client error, bad parameters',                                                                           // 556\n      404: 'no such container',                                                                                      // 557\n      500: 'server error'                                                                                            // 558\n    },                                                                                                               // 559\n    options: args.opts                                                                                               // 560\n  };                                                                                                                 // 561\n                                                                                                                     // 562\n  this.modem.dial(optsf, function(err, data) {                                                                       // 563\n    args.callback(err, data);                                                                                        // 564\n  });                                                                                                                // 565\n};                                                                                                                   // 566\n                                                                                                                     // 567\n/**                                                                                                                  // 568\n * putArchive                                                                                                        // 569\n * @param  {Object}   opts     Archive options, like 'path'                                                          // 570\n * @param  {Function} callback Callback with stream.                                                                 // 571\n */                                                                                                                  // 572\nContainer.prototype.putArchive = function(file, opts, callback) {                                                    // 573\n  var args = util.processArgs(opts, callback, this.defaultOptions.putArchive);                                       // 574\n                                                                                                                     // 575\n  var optsf = {                                                                                                      // 576\n    path: '/containers/' + this.id + '/archive?',                                                                    // 577\n    method: 'PUT',                                                                                                   // 578\n    file: file,                                                                                                      // 579\n    isStream: true,                                                                                                  // 580\n    statusCodes: {                                                                                                   // 581\n      200: true,                                                                                                     // 582\n      400: 'client error, bad parameters',                                                                           // 583\n      403: 'client error, permission denied',                                                                        // 584\n      404: 'no such container',                                                                                      // 585\n      500: 'server error'                                                                                            // 586\n    },                                                                                                               // 587\n    options: args.opts                                                                                               // 588\n  };                                                                                                                 // 589\n                                                                                                                     // 590\n  this.modem.dial(optsf, function(err, data) {                                                                       // 591\n    args.callback(err, data);                                                                                        // 592\n  });                                                                                                                // 593\n};                                                                                                                   // 594\n                                                                                                                     // 595\n/**                                                                                                                  // 596\n * Container logs                                                                                                    // 597\n * @param  {Object}   opts     Logs options. (optional)                                                              // 598\n * @param  {Function} callback Callback with data                                                                    // 599\n */                                                                                                                  // 600\nContainer.prototype.logs = function(opts, callback) {                                                                // 601\n  var args = util.processArgs(opts, callback, this.defaultOptions.log);                                              // 602\n                                                                                                                     // 603\n  var optsf = {                                                                                                      // 604\n    path: '/containers/' + this.id + '/logs?',                                                                       // 605\n    method: 'GET',                                                                                                   // 606\n    isStream: true,                                                                                                  // 607\n    statusCodes: {                                                                                                   // 608\n      200: true,                                                                                                     // 609\n      404: 'no such container',                                                                                      // 610\n      500: 'server error'                                                                                            // 611\n    },                                                                                                               // 612\n    options: args.opts                                                                                               // 613\n  };                                                                                                                 // 614\n                                                                                                                     // 615\n  this.modem.dial(optsf, function(err, data) {                                                                       // 616\n    args.callback(err, data);                                                                                        // 617\n  });                                                                                                                // 618\n};                                                                                                                   // 619\n                                                                                                                     // 620\n/**                                                                                                                  // 621\n * Container stats                                                                                                   // 622\n * @param  {Object}   opts     Stats options. (optional)                                                             // 623\n * @param  {Function} callback Callback with data                                                                    // 624\n */                                                                                                                  // 625\nContainer.prototype.stats = function(opts, callback) {                                                               // 626\n  var args = util.processArgs(opts, callback, this.defaultOptions.stats);                                            // 627\n                                                                                                                     // 628\n  var optsf = {                                                                                                      // 629\n    path: '/containers/' + this.id + '/stats?',                                                                      // 630\n    method: 'GET',                                                                                                   // 631\n    isStream: true,                                                                                                  // 632\n    statusCodes: {                                                                                                   // 633\n      200: true,                                                                                                     // 634\n      404: 'no such container',                                                                                      // 635\n      500: 'server error'                                                                                            // 636\n    },                                                                                                               // 637\n    options: args.opts                                                                                               // 638\n  };                                                                                                                 // 639\n                                                                                                                     // 640\n  this.modem.dial(optsf, function(err, data) {                                                                       // 641\n    args.callback(err, data);                                                                                        // 642\n  });                                                                                                                // 643\n};                                                                                                                   // 644\n                                                                                                                     // 645\nmodule.exports = Container;                                                                                          // 646\n                                                                                                                     // 647\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"util.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/util.js                                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// https://github.com/HenrikJoreteg/extend-object/blob/v0.1.0/extend-object.js                                       // 1\n                                                                                                                     // 2\nvar arr = [];                                                                                                        // 3\nvar each = arr.forEach;                                                                                              // 4\nvar slice = arr.slice;                                                                                               // 5\n                                                                                                                     // 6\nmodule.exports.extend = function(obj) {                                                                              // 7\n  each.call(slice.call(arguments, 1), function(source) {                                                             // 8\n    if (source) {                                                                                                    // 9\n      for (var prop in source) {                                                                                     // 10\n        obj[prop] = source[prop];                                                                                    // 11\n      }                                                                                                              // 12\n    }                                                                                                                // 13\n  });                                                                                                                // 14\n  return obj;                                                                                                        // 15\n};                                                                                                                   // 16\n                                                                                                                     // 17\nmodule.exports.processArgs = function(opts, callback, defaultOpts) {                                                 // 18\n  if (!callback && typeof opts === 'function') {                                                                     // 19\n    callback = opts;                                                                                                 // 20\n    opts = null;                                                                                                     // 21\n  }                                                                                                                  // 22\n  return {                                                                                                           // 23\n    callback: callback,                                                                                              // 24\n    opts: module.exports.extend({}, defaultOpts, opts)                                                               // 25\n  };                                                                                                                 // 26\n};                                                                                                                   // 27\n                                                                                                                     // 28\n/**                                                                                                                  // 29\n * Parse the given repo tag name (as a string) and break it out into repo/tag pair.                                  // 30\n * // if given the input http://localhost:8080/woot:latest                                                           // 31\n * {                                                                                                                 // 32\n *   repository: 'http://localhost:8080/woot',                                                                       // 33\n *   tag: 'latest'                                                                                                   // 34\n * }                                                                                                                 // 35\n * @param {String} input Input e.g: 'repo/foo', 'ubuntu', 'ubuntu:latest'                                            // 36\n * @return {Object} input parsed into the repo and tag.                                                              // 37\n */                                                                                                                  // 38\nmodule.exports.parseRepositoryTag = function(input) {                                                                // 39\n  var separatorPos;                                                                                                  // 40\n  var digestPos = input.indexOf('@');                                                                                // 41\n  var colonPos = input.lastIndexOf(':');                                                                             // 42\n  // @ symbol is more important                                                                                      // 43\n  if (digestPos >= 0) {                                                                                              // 44\n    separatorPos = digestPos;                                                                                        // 45\n  } else if (colonPos >= 0) {                                                                                        // 46\n    separatorPos = colonPos;                                                                                         // 47\n  } else {                                                                                                           // 48\n    // no colon nor @                                                                                                // 49\n    return {                                                                                                         // 50\n      repository: input                                                                                              // 51\n    };                                                                                                               // 52\n  }                                                                                                                  // 53\n                                                                                                                     // 54\n  // last colon is either the tag (or part of a port designation)                                                    // 55\n  var tag = input.slice(separatorPos + 1);                                                                           // 56\n                                                                                                                     // 57\n  // if it contains a / its not a tag and is part of the url                                                         // 58\n  if (tag.indexOf('/') === -1) {                                                                                     // 59\n    return {                                                                                                         // 60\n      repository: input.slice(0, separatorPos),                                                                      // 61\n      tag: tag                                                                                                       // 62\n    };                                                                                                               // 63\n  }                                                                                                                  // 64\n                                                                                                                     // 65\n  return {                                                                                                           // 66\n    repository: input                                                                                                // 67\n  };                                                                                                                 // 68\n};                                                                                                                   // 69\n                                                                                                                     // 70\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"exec.js\":[\"./util\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/exec.js                                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar util = require('./util');                                                                                        // 1\n                                                                                                                     // 2\n/**                                                                                                                  // 3\n * Represents an Exec                                                                                                // 4\n * @param {Object} modem docker-modem                                                                                // 5\n * @param {String} id    Exec's ID                                                                                   // 6\n */                                                                                                                  // 7\nvar Exec = function(modem, id) {                                                                                     // 8\n  this.modem = modem;                                                                                                // 9\n  this.id = id;                                                                                                      // 10\n};                                                                                                                   // 11\n                                                                                                                     // 12\n/**                                                                                                                  // 13\n * Start the exec call that was setup.                                                                               // 14\n *                                                                                                                   // 15\n * @param {object} options                                                                                           // 16\n * @param {function} callback                                                                                        // 17\n */                                                                                                                  // 18\nExec.prototype.start = function(opts, callback) {                                                                    // 19\n  var args = util.processArgs(opts, callback);                                                                       // 20\n                                                                                                                     // 21\n  var optsf = {                                                                                                      // 22\n    path: '/exec/' + this.id + '/start',                                                                             // 23\n    method: 'POST',                                                                                                  // 24\n    isStream: true,                                                                                                  // 25\n    hijack: args.opts.hijack,                                                                                        // 26\n    openStdin: args.opts.stdin,                                                                                      // 27\n    statusCodes: {                                                                                                   // 28\n      200: true,                                                                                                     // 29\n      204: true,                                                                                                     // 30\n      404: 'no such exec',                                                                                           // 31\n      409: 'container stopped/paused',                                                                               // 32\n      500: 'container not running'                                                                                   // 33\n    },                                                                                                               // 34\n    options: args.opts                                                                                               // 35\n  };                                                                                                                 // 36\n                                                                                                                     // 37\n  this.modem.dial(optsf, function(err, data) {                                                                       // 38\n    args.callback(err, data);                                                                                        // 39\n  });                                                                                                                // 40\n};                                                                                                                   // 41\n                                                                                                                     // 42\n/**                                                                                                                  // 43\n * Resize the exec call that was setup.                                                                              // 44\n *                                                                                                                   // 45\n * @param {object} options                                                                                           // 46\n * @param {function} callback                                                                                        // 47\n */                                                                                                                  // 48\nExec.prototype.resize = function(opts, callback) {                                                                   // 49\n  var args = util.processArgs(opts, callback);                                                                       // 50\n                                                                                                                     // 51\n  var optsf = {                                                                                                      // 52\n    path: '/exec/' + this.id + '/resize?',                                                                           // 53\n    method: 'POST',                                                                                                  // 54\n    statusCodes: {                                                                                                   // 55\n      200: true,                                                                                                     // 56\n      404: 'no such exec',                                                                                           // 57\n      500: 'container not running'                                                                                   // 58\n    },                                                                                                               // 59\n    options: args.opts                                                                                               // 60\n  };                                                                                                                 // 61\n                                                                                                                     // 62\n  this.modem.dial(optsf, function(err, data) {                                                                       // 63\n    args.callback(err, data);                                                                                        // 64\n  });                                                                                                                // 65\n};                                                                                                                   // 66\n                                                                                                                     // 67\n/**                                                                                                                  // 68\n * Get low-level information about the exec call.                                                                    // 69\n *                                                                                                                   // 70\n * @param {function} callback                                                                                        // 71\n */                                                                                                                  // 72\nExec.prototype.inspect = function(callback) {                                                                        // 73\n  var optsf = {                                                                                                      // 74\n    path: '/exec/' + this.id + '/json',                                                                              // 75\n    method: 'GET',                                                                                                   // 76\n    statusCodes: {                                                                                                   // 77\n      200: true,                                                                                                     // 78\n      404: 'no such exec',                                                                                           // 79\n      500: 'server error'                                                                                            // 80\n    }                                                                                                                // 81\n  };                                                                                                                 // 82\n                                                                                                                     // 83\n  this.modem.dial(optsf, function(err, data) {                                                                       // 84\n    callback(err, data);                                                                                             // 85\n  });                                                                                                                // 86\n};                                                                                                                   // 87\n                                                                                                                     // 88\n                                                                                                                     // 89\nmodule.exports = Exec;                                                                                               // 90\n                                                                                                                     // 91\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"image.js\":[\"./util\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/image.js                                                                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar util = require('./util');                                                                                        // 1\n                                                                                                                     // 2\n/**                                                                                                                  // 3\n * Represents an image                                                                                               // 4\n * @param {Object} modem docker-modem                                                                                // 5\n * @param {String} name  Image's name                                                                                // 6\n */                                                                                                                  // 7\nvar Image = function(modem, name) {                                                                                  // 8\n  this.modem = modem;                                                                                                // 9\n  this.name = name;                                                                                                  // 10\n};                                                                                                                   // 11\n                                                                                                                     // 12\n/**                                                                                                                  // 13\n * Inspect                                                                                                           // 14\n * @param  {Function} callback Callback, if specified Docker will be queried.                                        // 15\n * @return {Object}            Name only if callback isn't specified.                                                // 16\n */                                                                                                                  // 17\nImage.prototype.inspect = function(callback) {                                                                       // 18\n  if (typeof callback === 'function') {                                                                              // 19\n    var opts = {                                                                                                     // 20\n      path: '/images/' + this.name + '/json',                                                                        // 21\n      method: 'GET',                                                                                                 // 22\n      statusCodes: {                                                                                                 // 23\n        200: true,                                                                                                   // 24\n        404: 'no such image',                                                                                        // 25\n        500: 'server error'                                                                                          // 26\n      }                                                                                                              // 27\n    };                                                                                                               // 28\n                                                                                                                     // 29\n    this.modem.dial(opts, function(err, data) {                                                                      // 30\n      callback(err, data);                                                                                           // 31\n    });                                                                                                              // 32\n  } else {                                                                                                           // 33\n    return JSON.stringify({name: this.name});                                                                        // 34\n  }                                                                                                                  // 35\n};                                                                                                                   // 36\n                                                                                                                     // 37\n/**                                                                                                                  // 38\n * History                                                                                                           // 39\n * @param  {Function} callback Callback                                                                              // 40\n */                                                                                                                  // 41\nImage.prototype.history = function(callback) {                                                                       // 42\n  var opts = {                                                                                                       // 43\n    path: '/images/' + this.name + '/history',                                                                       // 44\n    method: 'GET',                                                                                                   // 45\n    statusCodes: {                                                                                                   // 46\n      200: true,                                                                                                     // 47\n      404: 'no such image',                                                                                          // 48\n      500: 'server error'                                                                                            // 49\n    }                                                                                                                // 50\n  };                                                                                                                 // 51\n                                                                                                                     // 52\n  this.modem.dial(opts, function(err, data) {                                                                        // 53\n    callback(err, data);                                                                                             // 54\n  });                                                                                                                // 55\n};                                                                                                                   // 56\n                                                                                                                     // 57\n/**                                                                                                                  // 58\n * Get                                                                                                               // 59\n * @param  {Function} callback Callback with data stream.                                                            // 60\n */                                                                                                                  // 61\nImage.prototype.get = function(callback) {                                                                           // 62\n  var opts = {                                                                                                       // 63\n    path: '/images/' + this.name + '/get',                                                                           // 64\n    method: 'GET',                                                                                                   // 65\n    isStream: true,                                                                                                  // 66\n    statusCodes: {                                                                                                   // 67\n      200: true,                                                                                                     // 68\n      500: 'server error'                                                                                            // 69\n    }                                                                                                                // 70\n  };                                                                                                                 // 71\n                                                                                                                     // 72\n  this.modem.dial(opts, function(err, data) {                                                                        // 73\n    callback(err, data);                                                                                             // 74\n  });                                                                                                                // 75\n};                                                                                                                   // 76\n                                                                                                                     // 77\n/**                                                                                                                  // 78\n * Push                                                                                                              // 79\n * @param  {Object}   opts     Push options, like 'registry' (optional)                                              // 80\n * @param  {Function} callback Callback with stream.                                                                 // 81\n * @param  {Object}   auth     Registry authentication                                                               // 82\n */                                                                                                                  // 83\nImage.prototype.push = function(opts, callback, auth) {                                                              // 84\n  var self = this;                                                                                                   // 85\n  var optsf = {                                                                                                      // 86\n    path: '/images/' + this.name + '/push?',                                                                         // 87\n    method: 'POST',                                                                                                  // 88\n    options: opts,                                                                                                   // 89\n    authconfig: opts.authconfig || auth,                                                                             // 90\n    isStream: true,                                                                                                  // 91\n    statusCodes: {                                                                                                   // 92\n      200: true,                                                                                                     // 93\n      404: 'no such image',                                                                                          // 94\n      500: 'server error'                                                                                            // 95\n    }                                                                                                                // 96\n  };                                                                                                                 // 97\n                                                                                                                     // 98\n  delete optsf.options.authconfig;                                                                                   // 99\n                                                                                                                     // 100\n  this.modem.dial(optsf, function(err, data) {                                                                       // 101\n    callback(err, data);                                                                                             // 102\n  });                                                                                                                // 103\n};                                                                                                                   // 104\n                                                                                                                     // 105\n/**                                                                                                                  // 106\n * Tag                                                                                                               // 107\n * @param  {Object}   opts     Tag options, like 'repo' (optional)                                                   // 108\n * @param  {Function} callback Callback                                                                              // 109\n */                                                                                                                  // 110\nImage.prototype.tag = function(opts, callback) {                                                                     // 111\n  var self = this;                                                                                                   // 112\n  var optsf = {                                                                                                      // 113\n    path: '/images/' + this.name + '/tag?',                                                                          // 114\n    method: 'POST',                                                                                                  // 115\n    options: opts,                                                                                                   // 116\n    statusCodes: {                                                                                                   // 117\n      200: true, // unofficial, but proxies may return it                                                            // 118\n      201: true,                                                                                                     // 119\n      400: 'bad parameter',                                                                                          // 120\n      404: 'no such image',                                                                                          // 121\n      409: 'conflict',                                                                                               // 122\n      500: 'server error'                                                                                            // 123\n    }                                                                                                                // 124\n  };                                                                                                                 // 125\n                                                                                                                     // 126\n  this.modem.dial(optsf, function(err, data) {                                                                       // 127\n    callback(err, data);                                                                                             // 128\n  });                                                                                                                // 129\n};                                                                                                                   // 130\n                                                                                                                     // 131\n/**                                                                                                                  // 132\n * Removes the image                                                                                                 // 133\n * @param  {[Object]}   opts     Remove options (optional)                                                           // 134\n * @param  {Function} callback Callback                                                                              // 135\n */                                                                                                                  // 136\nImage.prototype.remove = function(opts, callback) {                                                                  // 137\n  var args = util.processArgs(opts, callback);                                                                       // 138\n                                                                                                                     // 139\n                                                                                                                     // 140\n  var optsf = {                                                                                                      // 141\n    path: '/images/' + this.name + '?',                                                                              // 142\n    method: 'DELETE',                                                                                                // 143\n    statusCodes: {                                                                                                   // 144\n      200: true,                                                                                                     // 145\n      404: 'no such image',                                                                                          // 146\n      409: 'conflict',                                                                                               // 147\n      500: 'server error'                                                                                            // 148\n    },                                                                                                               // 149\n    options: args.opts                                                                                               // 150\n  };                                                                                                                 // 151\n                                                                                                                     // 152\n  this.modem.dial(optsf, function(err, data) {                                                                       // 153\n    args.callback(err, data);                                                                                        // 154\n  });                                                                                                                // 155\n};                                                                                                                   // 156\n                                                                                                                     // 157\nmodule.exports = Image;                                                                                              // 158\n                                                                                                                     // 159\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"volume.js\":[\"./util\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/volume.js                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar util = require('./util');                                                                                        // 1\n                                                                                                                     // 2\n/**                                                                                                                  // 3\n * Represents an volume                                                                                              // 4\n * @param {Object} modem docker-modem                                                                                // 5\n * @param {String} name  Volume's name                                                                               // 6\n */                                                                                                                  // 7\nvar Volume = function(modem, name) {                                                                                 // 8\n  this.modem = modem;                                                                                                // 9\n  this.name = name;                                                                                                  // 10\n};                                                                                                                   // 11\n                                                                                                                     // 12\n/**                                                                                                                  // 13\n * Inspect                                                                                                           // 14\n * @param  {Function} callback Callback, if specified Docker will be queried.                                        // 15\n * @return {Object}            Name only if callback isn't specified.                                                // 16\n */                                                                                                                  // 17\nVolume.prototype.inspect = function(callback) {                                                                      // 18\n  if (typeof callback === 'function') {                                                                              // 19\n    var opts = {                                                                                                     // 20\n      path: '/volumes/' + this.name,                                                                                 // 21\n      method: 'GET',                                                                                                 // 22\n      statusCodes: {                                                                                                 // 23\n        200: true,                                                                                                   // 24\n        404: 'no such volume',                                                                                       // 25\n        500: 'server error'                                                                                          // 26\n      }                                                                                                              // 27\n    };                                                                                                               // 28\n                                                                                                                     // 29\n    this.modem.dial(opts, function(err, data) {                                                                      // 30\n      callback(err, data);                                                                                           // 31\n    });                                                                                                              // 32\n  } else {                                                                                                           // 33\n    return JSON.stringify({name: this.name});                                                                        // 34\n  }                                                                                                                  // 35\n};                                                                                                                   // 36\n                                                                                                                     // 37\n/**                                                                                                                  // 38\n * Removes the volume                                                                                                // 39\n * @param  {[Object]}   opts     Remove options (optional)                                                           // 40\n * @param  {Function} callback Callback                                                                              // 41\n */                                                                                                                  // 42\nVolume.prototype.remove = function(opts, callback) {                                                                 // 43\n  var args = util.processArgs(opts, callback);                                                                       // 44\n                                                                                                                     // 45\n  var optsf = {                                                                                                      // 46\n    path: '/volumes/' + this.name,                                                                                   // 47\n    method: 'DELETE',                                                                                                // 48\n    statusCodes: {                                                                                                   // 49\n      204: true,                                                                                                     // 50\n      404: 'no such volume',                                                                                         // 51\n      409: 'conflict',                                                                                               // 52\n      500: 'server error'                                                                                            // 53\n    },                                                                                                               // 54\n    options: args.opts                                                                                               // 55\n  };                                                                                                                 // 56\n                                                                                                                     // 57\n  this.modem.dial(optsf, function(err, data) {                                                                       // 58\n    args.callback(err, data);                                                                                        // 59\n  });                                                                                                                // 60\n};                                                                                                                   // 61\n                                                                                                                     // 62\nmodule.exports = Volume;                                                                                             // 63\n                                                                                                                     // 64\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"network.js\":[\"./util\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/network.js                                                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar util = require('./util');                                                                                        // 1\n                                                                                                                     // 2\n/**                                                                                                                  // 3\n * Represents an network                                                                                             // 4\n * @param {Object} modem docker-modem                                                                                // 5\n * @param {String} id  Network's id                                                                                  // 6\n */                                                                                                                  // 7\nvar Network = function(modem, id) {                                                                                  // 8\n  this.modem = modem;                                                                                                // 9\n  this.id = id;                                                                                                      // 10\n};                                                                                                                   // 11\n                                                                                                                     // 12\n/**                                                                                                                  // 13\n * Inspect                                                                                                           // 14\n * @param  {Function} callback Callback, if specified Docker will be queried.                                        // 15\n * @return {Object}            Id only if callback isn't specified.                                                  // 16\n */                                                                                                                  // 17\nNetwork.prototype.inspect = function(callback) {                                                                     // 18\n  if (typeof callback === 'function') {                                                                              // 19\n    var opts = {                                                                                                     // 20\n      path: '/networks/' + this.id,                                                                                  // 21\n      method: 'GET',                                                                                                 // 22\n      statusCodes: {                                                                                                 // 23\n        200: true,                                                                                                   // 24\n        404: 'no such network',                                                                                      // 25\n        500: 'server error'                                                                                          // 26\n      }                                                                                                              // 27\n    };                                                                                                               // 28\n                                                                                                                     // 29\n    this.modem.dial(opts, function(err, data) {                                                                      // 30\n      callback(err, data);                                                                                           // 31\n    });                                                                                                              // 32\n  } else {                                                                                                           // 33\n    return JSON.stringify({Id: this.id});                                                                            // 34\n  }                                                                                                                  // 35\n};                                                                                                                   // 36\n                                                                                                                     // 37\n/**                                                                                                                  // 38\n * Removes the network                                                                                               // 39\n * @param  {[Object]}   opts     Remove options (optional)                                                           // 40\n * @param  {Function} callback Callback                                                                              // 41\n */                                                                                                                  // 42\nNetwork.prototype.remove = function(opts, callback) {                                                                // 43\n  var args = util.processArgs(opts, callback);                                                                       // 44\n                                                                                                                     // 45\n  var optsf = {                                                                                                      // 46\n    path: '/networks/' + this.id,                                                                                    // 47\n    method: 'DELETE',                                                                                                // 48\n    statusCodes: {                                                                                                   // 49\n      200: true,                                                                                                     // 50\n      204: true,                                                                                                     // 51\n      404: 'no such network',                                                                                        // 52\n      409: 'conflict',                                                                                               // 53\n      500: 'server error'                                                                                            // 54\n    },                                                                                                               // 55\n    options: args.opts                                                                                               // 56\n  };                                                                                                                 // 57\n                                                                                                                     // 58\n  this.modem.dial(optsf, function(err, data) {                                                                       // 59\n    args.callback(err, data);                                                                                        // 60\n  });                                                                                                                // 61\n};                                                                                                                   // 62\n                                                                                                                     // 63\n/**                                                                                                                  // 64\n * Connects a container to a network                                                                                 // 65\n * @param  {[Object]}   opts     Connect options (optional)                                                          // 66\n * @param  {Function} callback Callback                                                                              // 67\n */                                                                                                                  // 68\nNetwork.prototype.connect = function(opts, callback) {                                                               // 69\n  var args = util.processArgs(opts, callback);                                                                       // 70\n                                                                                                                     // 71\n  var optsf = {                                                                                                      // 72\n    path: '/networks/' + this.id + '/connect',                                                                       // 73\n    method: 'POST',                                                                                                  // 74\n    statusCodes: {                                                                                                   // 75\n      200: true,                                                                                                     // 76\n      201: true,                                                                                                     // 77\n      404: 'network or container is not found',                                                                      // 78\n      500: 'server error'                                                                                            // 79\n    },                                                                                                               // 80\n    options: args.opts                                                                                               // 81\n  };                                                                                                                 // 82\n                                                                                                                     // 83\n  this.modem.dial(optsf, function(err, data) {                                                                       // 84\n    args.callback(err, data);                                                                                        // 85\n  });                                                                                                                // 86\n};                                                                                                                   // 87\n                                                                                                                     // 88\n                                                                                                                     // 89\n/**                                                                                                                  // 90\n * Disconnects a container from a network                                                                            // 91\n * @param  {[Object]}   opts     Disconnect options (optional)                                                       // 92\n * @param  {Function} callback Callback                                                                              // 93\n */                                                                                                                  // 94\nNetwork.prototype.disconnect = function(opts, callback) {                                                            // 95\n  var args = util.processArgs(opts, callback);                                                                       // 96\n                                                                                                                     // 97\n  var optsf = {                                                                                                      // 98\n    path: '/networks/' + this.id + '/disconnect',                                                                    // 99\n    method: 'POST',                                                                                                  // 100\n    statusCodes: {                                                                                                   // 101\n      200: true,                                                                                                     // 102\n      201: true,                                                                                                     // 103\n      404: 'network or container is not found',                                                                      // 104\n      500: 'server error'                                                                                            // 105\n    },                                                                                                               // 106\n    options: args.opts                                                                                               // 107\n  };                                                                                                                 // 108\n                                                                                                                     // 109\n  this.modem.dial(optsf, function(err, data) {                                                                       // 110\n    args.callback(err, data);                                                                                        // 111\n  });                                                                                                                // 112\n};                                                                                                                   // 113\n                                                                                                                     // 114\n                                                                                                                     // 115\n                                                                                                                     // 116\n                                                                                                                     // 117\nmodule.exports = Network;                                                                                            // 118\n                                                                                                                     // 119\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}},\"meteor-node-stubs\":{\"deps\":{\"events.js\":[\"events/\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/events.js                                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"events/\");                                                                                                  // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"querystring.js\":[\"querystring-es3/\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/querystring.js                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"querystring-es3/\");                                                                                         // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"https.js\":[\"https-browserify\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/https.js                                                                      //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"https-browserify\");                                                                                         // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"http.js\":[\"http-browserify\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/http.js                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"http-browserify\");                                                                                          // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"stream.js\":[\"stream-browserify\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/stream.js                                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"stream-browserify\");                                                                                        // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"buffer.js\":[\"buffer/\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/buffer.js                                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"buffer/\");                                                                                                  // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"url.js\":[\"url/\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/url.js                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"url/\");                                                                                                     // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"fs.js\":function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/fs.js                                                                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n                                                                                                                     // 1\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"path.js\":[\"path-browserify\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/path.js                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"path-browserify\");                                                                                          // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"util.js\":[\"util/util.js\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/util.js                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"util/util.js\");                                                                                             // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"process.js\":[\"process/browser.js\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/process.js                                                                    //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"process/browser.js\");                                                                                       // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"domain.js\":[\"domain-browser\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/deps/domain.js                                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"domain-browser\");                                                                                           // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"node_modules\":{\"events\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/events/package.json                                                   //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"events\";                                                                                             // 1\nexports.version = \"1.1.0\";                                                                                           // 2\nexports.main = \"./events.js\";                                                                                        // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"events.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/events/events.js                                                      //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\nfunction EventEmitter() {                                                                                            // 22\n  this._events = this._events || {};                                                                                 // 23\n  this._maxListeners = this._maxListeners || undefined;                                                              // 24\n}                                                                                                                    // 25\nmodule.exports = EventEmitter;                                                                                       // 26\n                                                                                                                     // 27\n// Backwards-compat with node 0.10.x                                                                                 // 28\nEventEmitter.EventEmitter = EventEmitter;                                                                            // 29\n                                                                                                                     // 30\nEventEmitter.prototype._events = undefined;                                                                          // 31\nEventEmitter.prototype._maxListeners = undefined;                                                                    // 32\n                                                                                                                     // 33\n// By default EventEmitters will print a warning if more than 10 listeners are                                       // 34\n// added to it. This is a useful default which helps finding memory leaks.                                           // 35\nEventEmitter.defaultMaxListeners = 10;                                                                               // 36\n                                                                                                                     // 37\n// Obviously not all Emitters should be limited to 10. This function allows                                          // 38\n// that to be increased. Set to zero for unlimited.                                                                  // 39\nEventEmitter.prototype.setMaxListeners = function(n) {                                                               // 40\n  if (!isNumber(n) || n < 0 || isNaN(n))                                                                             // 41\n    throw TypeError('n must be a positive number');                                                                  // 42\n  this._maxListeners = n;                                                                                            // 43\n  return this;                                                                                                       // 44\n};                                                                                                                   // 45\n                                                                                                                     // 46\nEventEmitter.prototype.emit = function(type) {                                                                       // 47\n  var er, handler, len, args, i, listeners;                                                                          // 48\n                                                                                                                     // 49\n  if (!this._events)                                                                                                 // 50\n    this._events = {};                                                                                               // 51\n                                                                                                                     // 52\n  // If there is no 'error' event listener then throw.                                                               // 53\n  if (type === 'error') {                                                                                            // 54\n    if (!this._events.error ||                                                                                       // 55\n        (isObject(this._events.error) && !this._events.error.length)) {                                              // 56\n      er = arguments[1];                                                                                             // 57\n      if (er instanceof Error) {                                                                                     // 58\n        throw er; // Unhandled 'error' event                                                                         // 59\n      }                                                                                                              // 60\n      throw TypeError('Uncaught, unspecified \"error\" event.');                                                       // 61\n    }                                                                                                                // 62\n  }                                                                                                                  // 63\n                                                                                                                     // 64\n  handler = this._events[type];                                                                                      // 65\n                                                                                                                     // 66\n  if (isUndefined(handler))                                                                                          // 67\n    return false;                                                                                                    // 68\n                                                                                                                     // 69\n  if (isFunction(handler)) {                                                                                         // 70\n    switch (arguments.length) {                                                                                      // 71\n      // fast cases                                                                                                  // 72\n      case 1:                                                                                                        // 73\n        handler.call(this);                                                                                          // 74\n        break;                                                                                                       // 75\n      case 2:                                                                                                        // 76\n        handler.call(this, arguments[1]);                                                                            // 77\n        break;                                                                                                       // 78\n      case 3:                                                                                                        // 79\n        handler.call(this, arguments[1], arguments[2]);                                                              // 80\n        break;                                                                                                       // 81\n      // slower                                                                                                      // 82\n      default:                                                                                                       // 83\n        args = Array.prototype.slice.call(arguments, 1);                                                             // 84\n        handler.apply(this, args);                                                                                   // 85\n    }                                                                                                                // 86\n  } else if (isObject(handler)) {                                                                                    // 87\n    args = Array.prototype.slice.call(arguments, 1);                                                                 // 88\n    listeners = handler.slice();                                                                                     // 89\n    len = listeners.length;                                                                                          // 90\n    for (i = 0; i < len; i++)                                                                                        // 91\n      listeners[i].apply(this, args);                                                                                // 92\n  }                                                                                                                  // 93\n                                                                                                                     // 94\n  return true;                                                                                                       // 95\n};                                                                                                                   // 96\n                                                                                                                     // 97\nEventEmitter.prototype.addListener = function(type, listener) {                                                      // 98\n  var m;                                                                                                             // 99\n                                                                                                                     // 100\n  if (!isFunction(listener))                                                                                         // 101\n    throw TypeError('listener must be a function');                                                                  // 102\n                                                                                                                     // 103\n  if (!this._events)                                                                                                 // 104\n    this._events = {};                                                                                               // 105\n                                                                                                                     // 106\n  // To avoid recursion in the case that type === \"newListener\"! Before                                              // 107\n  // adding it to the listeners, first emit \"newListener\".                                                           // 108\n  if (this._events.newListener)                                                                                      // 109\n    this.emit('newListener', type,                                                                                   // 110\n              isFunction(listener.listener) ?                                                                        // 111\n              listener.listener : listener);                                                                         // 112\n                                                                                                                     // 113\n  if (!this._events[type])                                                                                           // 114\n    // Optimize the case of one listener. Don't need the extra array object.                                         // 115\n    this._events[type] = listener;                                                                                   // 116\n  else if (isObject(this._events[type]))                                                                             // 117\n    // If we've already got an array, just append.                                                                   // 118\n    this._events[type].push(listener);                                                                               // 119\n  else                                                                                                               // 120\n    // Adding the second element, need to change to array.                                                           // 121\n    this._events[type] = [this._events[type], listener];                                                             // 122\n                                                                                                                     // 123\n  // Check for listener leak                                                                                         // 124\n  if (isObject(this._events[type]) && !this._events[type].warned) {                                                  // 125\n    if (!isUndefined(this._maxListeners)) {                                                                          // 126\n      m = this._maxListeners;                                                                                        // 127\n    } else {                                                                                                         // 128\n      m = EventEmitter.defaultMaxListeners;                                                                          // 129\n    }                                                                                                                // 130\n                                                                                                                     // 131\n    if (m && m > 0 && this._events[type].length > m) {                                                               // 132\n      this._events[type].warned = true;                                                                              // 133\n      console.error('(node) warning: possible EventEmitter memory ' +                                                // 134\n                    'leak detected. %d listeners added. ' +                                                          // 135\n                    'Use emitter.setMaxListeners() to increase limit.',                                              // 136\n                    this._events[type].length);                                                                      // 137\n      if (typeof console.trace === 'function') {                                                                     // 138\n        // not supported in IE 10                                                                                    // 139\n        console.trace();                                                                                             // 140\n      }                                                                                                              // 141\n    }                                                                                                                // 142\n  }                                                                                                                  // 143\n                                                                                                                     // 144\n  return this;                                                                                                       // 145\n};                                                                                                                   // 146\n                                                                                                                     // 147\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;                                                      // 148\n                                                                                                                     // 149\nEventEmitter.prototype.once = function(type, listener) {                                                             // 150\n  if (!isFunction(listener))                                                                                         // 151\n    throw TypeError('listener must be a function');                                                                  // 152\n                                                                                                                     // 153\n  var fired = false;                                                                                                 // 154\n                                                                                                                     // 155\n  function g() {                                                                                                     // 156\n    this.removeListener(type, g);                                                                                    // 157\n                                                                                                                     // 158\n    if (!fired) {                                                                                                    // 159\n      fired = true;                                                                                                  // 160\n      listener.apply(this, arguments);                                                                               // 161\n    }                                                                                                                // 162\n  }                                                                                                                  // 163\n                                                                                                                     // 164\n  g.listener = listener;                                                                                             // 165\n  this.on(type, g);                                                                                                  // 166\n                                                                                                                     // 167\n  return this;                                                                                                       // 168\n};                                                                                                                   // 169\n                                                                                                                     // 170\n// emits a 'removeListener' event iff the listener was removed                                                       // 171\nEventEmitter.prototype.removeListener = function(type, listener) {                                                   // 172\n  var list, position, length, i;                                                                                     // 173\n                                                                                                                     // 174\n  if (!isFunction(listener))                                                                                         // 175\n    throw TypeError('listener must be a function');                                                                  // 176\n                                                                                                                     // 177\n  if (!this._events || !this._events[type])                                                                          // 178\n    return this;                                                                                                     // 179\n                                                                                                                     // 180\n  list = this._events[type];                                                                                         // 181\n  length = list.length;                                                                                              // 182\n  position = -1;                                                                                                     // 183\n                                                                                                                     // 184\n  if (list === listener ||                                                                                           // 185\n      (isFunction(list.listener) && list.listener === listener)) {                                                   // 186\n    delete this._events[type];                                                                                       // 187\n    if (this._events.removeListener)                                                                                 // 188\n      this.emit('removeListener', type, listener);                                                                   // 189\n                                                                                                                     // 190\n  } else if (isObject(list)) {                                                                                       // 191\n    for (i = length; i-- > 0;) {                                                                                     // 192\n      if (list[i] === listener ||                                                                                    // 193\n          (list[i].listener && list[i].listener === listener)) {                                                     // 194\n        position = i;                                                                                                // 195\n        break;                                                                                                       // 196\n      }                                                                                                              // 197\n    }                                                                                                                // 198\n                                                                                                                     // 199\n    if (position < 0)                                                                                                // 200\n      return this;                                                                                                   // 201\n                                                                                                                     // 202\n    if (list.length === 1) {                                                                                         // 203\n      list.length = 0;                                                                                               // 204\n      delete this._events[type];                                                                                     // 205\n    } else {                                                                                                         // 206\n      list.splice(position, 1);                                                                                      // 207\n    }                                                                                                                // 208\n                                                                                                                     // 209\n    if (this._events.removeListener)                                                                                 // 210\n      this.emit('removeListener', type, listener);                                                                   // 211\n  }                                                                                                                  // 212\n                                                                                                                     // 213\n  return this;                                                                                                       // 214\n};                                                                                                                   // 215\n                                                                                                                     // 216\nEventEmitter.prototype.removeAllListeners = function(type) {                                                         // 217\n  var key, listeners;                                                                                                // 218\n                                                                                                                     // 219\n  if (!this._events)                                                                                                 // 220\n    return this;                                                                                                     // 221\n                                                                                                                     // 222\n  // not listening for removeListener, no need to emit                                                               // 223\n  if (!this._events.removeListener) {                                                                                // 224\n    if (arguments.length === 0)                                                                                      // 225\n      this._events = {};                                                                                             // 226\n    else if (this._events[type])                                                                                     // 227\n      delete this._events[type];                                                                                     // 228\n    return this;                                                                                                     // 229\n  }                                                                                                                  // 230\n                                                                                                                     // 231\n  // emit removeListener for all listeners on all events                                                             // 232\n  if (arguments.length === 0) {                                                                                      // 233\n    for (key in this._events) {                                                                                      // 234\n      if (key === 'removeListener') continue;                                                                        // 235\n      this.removeAllListeners(key);                                                                                  // 236\n    }                                                                                                                // 237\n    this.removeAllListeners('removeListener');                                                                       // 238\n    this._events = {};                                                                                               // 239\n    return this;                                                                                                     // 240\n  }                                                                                                                  // 241\n                                                                                                                     // 242\n  listeners = this._events[type];                                                                                    // 243\n                                                                                                                     // 244\n  if (isFunction(listeners)) {                                                                                       // 245\n    this.removeListener(type, listeners);                                                                            // 246\n  } else if (listeners) {                                                                                            // 247\n    // LIFO order                                                                                                    // 248\n    while (listeners.length)                                                                                         // 249\n      this.removeListener(type, listeners[listeners.length - 1]);                                                    // 250\n  }                                                                                                                  // 251\n  delete this._events[type];                                                                                         // 252\n                                                                                                                     // 253\n  return this;                                                                                                       // 254\n};                                                                                                                   // 255\n                                                                                                                     // 256\nEventEmitter.prototype.listeners = function(type) {                                                                  // 257\n  var ret;                                                                                                           // 258\n  if (!this._events || !this._events[type])                                                                          // 259\n    ret = [];                                                                                                        // 260\n  else if (isFunction(this._events[type]))                                                                           // 261\n    ret = [this._events[type]];                                                                                      // 262\n  else                                                                                                               // 263\n    ret = this._events[type].slice();                                                                                // 264\n  return ret;                                                                                                        // 265\n};                                                                                                                   // 266\n                                                                                                                     // 267\nEventEmitter.prototype.listenerCount = function(type) {                                                              // 268\n  if (this._events) {                                                                                                // 269\n    var evlistener = this._events[type];                                                                             // 270\n                                                                                                                     // 271\n    if (isFunction(evlistener))                                                                                      // 272\n      return 1;                                                                                                      // 273\n    else if (evlistener)                                                                                             // 274\n      return evlistener.length;                                                                                      // 275\n  }                                                                                                                  // 276\n  return 0;                                                                                                          // 277\n};                                                                                                                   // 278\n                                                                                                                     // 279\nEventEmitter.listenerCount = function(emitter, type) {                                                               // 280\n  return emitter.listenerCount(type);                                                                                // 281\n};                                                                                                                   // 282\n                                                                                                                     // 283\nfunction isFunction(arg) {                                                                                           // 284\n  return typeof arg === 'function';                                                                                  // 285\n}                                                                                                                    // 286\n                                                                                                                     // 287\nfunction isNumber(arg) {                                                                                             // 288\n  return typeof arg === 'number';                                                                                    // 289\n}                                                                                                                    // 290\n                                                                                                                     // 291\nfunction isObject(arg) {                                                                                             // 292\n  return typeof arg === 'object' && arg !== null;                                                                    // 293\n}                                                                                                                    // 294\n                                                                                                                     // 295\nfunction isUndefined(arg) {                                                                                          // 296\n  return arg === void 0;                                                                                             // 297\n}                                                                                                                    // 298\n                                                                                                                     // 299\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"querystring-es3\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/querystring-es3/package.json                                          //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"querystring-es3\";                                                                                    // 1\nexports.version = \"0.2.1\";                                                                                           // 2\n                                                                                                                     // 3\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"./decode\",\"./encode\",function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/querystring-es3/index.js                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n'use strict';                                                                                                        // 1\n                                                                                                                     // 2\nexports.decode = exports.parse = require('./decode');                                                                // 3\nexports.encode = exports.stringify = require('./encode');                                                            // 4\n                                                                                                                     // 5\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"decode.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/querystring-es3/decode.js                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n'use strict';                                                                                                        // 22\n                                                                                                                     // 23\n// If obj.hasOwnProperty has been overridden, then calling                                                           // 24\n// obj.hasOwnProperty(prop) will break.                                                                              // 25\n// See: https://github.com/joyent/node/issues/1707                                                                   // 26\nfunction hasOwnProperty(obj, prop) {                                                                                 // 27\n  return Object.prototype.hasOwnProperty.call(obj, prop);                                                            // 28\n}                                                                                                                    // 29\n                                                                                                                     // 30\nmodule.exports = function(qs, sep, eq, options) {                                                                    // 31\n  sep = sep || '&';                                                                                                  // 32\n  eq = eq || '=';                                                                                                    // 33\n  var obj = {};                                                                                                      // 34\n                                                                                                                     // 35\n  if (typeof qs !== 'string' || qs.length === 0) {                                                                   // 36\n    return obj;                                                                                                      // 37\n  }                                                                                                                  // 38\n                                                                                                                     // 39\n  var regexp = /\\+/g;                                                                                                // 40\n  qs = qs.split(sep);                                                                                                // 41\n                                                                                                                     // 42\n  var maxKeys = 1000;                                                                                                // 43\n  if (options && typeof options.maxKeys === 'number') {                                                              // 44\n    maxKeys = options.maxKeys;                                                                                       // 45\n  }                                                                                                                  // 46\n                                                                                                                     // 47\n  var len = qs.length;                                                                                               // 48\n  // maxKeys <= 0 means that we should not limit keys count                                                          // 49\n  if (maxKeys > 0 && len > maxKeys) {                                                                                // 50\n    len = maxKeys;                                                                                                   // 51\n  }                                                                                                                  // 52\n                                                                                                                     // 53\n  for (var i = 0; i < len; ++i) {                                                                                    // 54\n    var x = qs[i].replace(regexp, '%20'),                                                                            // 55\n        idx = x.indexOf(eq),                                                                                         // 56\n        kstr, vstr, k, v;                                                                                            // 57\n                                                                                                                     // 58\n    if (idx >= 0) {                                                                                                  // 59\n      kstr = x.substr(0, idx);                                                                                       // 60\n      vstr = x.substr(idx + 1);                                                                                      // 61\n    } else {                                                                                                         // 62\n      kstr = x;                                                                                                      // 63\n      vstr = '';                                                                                                     // 64\n    }                                                                                                                // 65\n                                                                                                                     // 66\n    k = decodeURIComponent(kstr);                                                                                    // 67\n    v = decodeURIComponent(vstr);                                                                                    // 68\n                                                                                                                     // 69\n    if (!hasOwnProperty(obj, k)) {                                                                                   // 70\n      obj[k] = v;                                                                                                    // 71\n    } else if (isArray(obj[k])) {                                                                                    // 72\n      obj[k].push(v);                                                                                                // 73\n    } else {                                                                                                         // 74\n      obj[k] = [obj[k], v];                                                                                          // 75\n    }                                                                                                                // 76\n  }                                                                                                                  // 77\n                                                                                                                     // 78\n  return obj;                                                                                                        // 79\n};                                                                                                                   // 80\n                                                                                                                     // 81\nvar isArray = Array.isArray || function (xs) {                                                                       // 82\n  return Object.prototype.toString.call(xs) === '[object Array]';                                                    // 83\n};                                                                                                                   // 84\n                                                                                                                     // 85\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"encode.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/querystring-es3/encode.js                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n'use strict';                                                                                                        // 22\n                                                                                                                     // 23\nvar stringifyPrimitive = function(v) {                                                                               // 24\n  switch (typeof v) {                                                                                                // 25\n    case 'string':                                                                                                   // 26\n      return v;                                                                                                      // 27\n                                                                                                                     // 28\n    case 'boolean':                                                                                                  // 29\n      return v ? 'true' : 'false';                                                                                   // 30\n                                                                                                                     // 31\n    case 'number':                                                                                                   // 32\n      return isFinite(v) ? v : '';                                                                                   // 33\n                                                                                                                     // 34\n    default:                                                                                                         // 35\n      return '';                                                                                                     // 36\n  }                                                                                                                  // 37\n};                                                                                                                   // 38\n                                                                                                                     // 39\nmodule.exports = function(obj, sep, eq, name) {                                                                      // 40\n  sep = sep || '&';                                                                                                  // 41\n  eq = eq || '=';                                                                                                    // 42\n  if (obj === null) {                                                                                                // 43\n    obj = undefined;                                                                                                 // 44\n  }                                                                                                                  // 45\n                                                                                                                     // 46\n  if (typeof obj === 'object') {                                                                                     // 47\n    return map(objectKeys(obj), function(k) {                                                                        // 48\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;                                                       // 49\n      if (isArray(obj[k])) {                                                                                         // 50\n        return map(obj[k], function(v) {                                                                             // 51\n          return ks + encodeURIComponent(stringifyPrimitive(v));                                                     // 52\n        }).join(sep);                                                                                                // 53\n      } else {                                                                                                       // 54\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));                                                  // 55\n      }                                                                                                              // 56\n    }).join(sep);                                                                                                    // 57\n                                                                                                                     // 58\n  }                                                                                                                  // 59\n                                                                                                                     // 60\n  if (!name) return '';                                                                                              // 61\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +                                                         // 62\n         encodeURIComponent(stringifyPrimitive(obj));                                                                // 63\n};                                                                                                                   // 64\n                                                                                                                     // 65\nvar isArray = Array.isArray || function (xs) {                                                                       // 66\n  return Object.prototype.toString.call(xs) === '[object Array]';                                                    // 67\n};                                                                                                                   // 68\n                                                                                                                     // 69\nfunction map (xs, f) {                                                                                               // 70\n  if (xs.map) return xs.map(f);                                                                                      // 71\n  var res = [];                                                                                                      // 72\n  for (var i = 0; i < xs.length; i++) {                                                                              // 73\n    res.push(f(xs[i], i));                                                                                           // 74\n  }                                                                                                                  // 75\n  return res;                                                                                                        // 76\n}                                                                                                                    // 77\n                                                                                                                     // 78\nvar objectKeys = Object.keys || function (obj) {                                                                     // 79\n  var res = [];                                                                                                      // 80\n  for (var key in obj) {                                                                                             // 81\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);                                               // 82\n  }                                                                                                                  // 83\n  return res;                                                                                                        // 84\n};                                                                                                                   // 85\n                                                                                                                     // 86\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"https-browserify\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/https-browserify/package.json                                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"https-browserify\";                                                                                   // 1\nexports.version = \"0.0.1\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"http\",\"meteor-node-stubs/deps/http\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/https-browserify/index.js                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar http = require('http');                                                                                          // 1\n                                                                                                                     // 2\nvar https = module.exports;                                                                                          // 3\n                                                                                                                     // 4\nfor (var key in http) {                                                                                              // 5\n    if (http.hasOwnProperty(key)) https[key] = http[key];                                                            // 6\n};                                                                                                                   // 7\n                                                                                                                     // 8\nhttps.request = function (params, cb) {                                                                              // 9\n    if (!params) params = {};                                                                                        // 10\n    params.scheme = 'https';                                                                                         // 11\n    params.protocol = 'https:';                                                                                      // 12\n    return http.request.call(this, params, cb);                                                                      // 13\n}                                                                                                                    // 14\n                                                                                                                     // 15\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"http-browserify\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/http-browserify/package.json                                          //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"http-browserify\";                                                                                    // 1\nexports.version = \"1.7.0\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"events\",\"./lib/request\",\"url\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/http-browserify/index.js                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar http = module.exports;                                                                                           // 1\nvar EventEmitter = require('events').EventEmitter;                                                                   // 2\nvar Request = require('./lib/request');                                                                              // 3\nvar url = require('url')                                                                                             // 4\n                                                                                                                     // 5\nhttp.request = function (params, cb) {                                                                               // 6\n    if (typeof params === 'string') {                                                                                // 7\n        params = url.parse(params)                                                                                   // 8\n    }                                                                                                                // 9\n    if (!params) params = {};                                                                                        // 10\n    if (!params.host && !params.port) {                                                                              // 11\n        params.port = parseInt(window.location.port, 10);                                                            // 12\n    }                                                                                                                // 13\n    if (!params.host && params.hostname) {                                                                           // 14\n        params.host = params.hostname;                                                                               // 15\n    }                                                                                                                // 16\n                                                                                                                     // 17\n    if (!params.protocol) {                                                                                          // 18\n        if (params.scheme) {                                                                                         // 19\n            params.protocol = params.scheme + ':';                                                                   // 20\n        } else {                                                                                                     // 21\n            params.protocol = window.location.protocol;                                                              // 22\n        }                                                                                                            // 23\n    }                                                                                                                // 24\n                                                                                                                     // 25\n    if (!params.host) {                                                                                              // 26\n        params.host = window.location.hostname || window.location.host;                                              // 27\n    }                                                                                                                // 28\n    if (/:/.test(params.host)) {                                                                                     // 29\n        if (!params.port) {                                                                                          // 30\n            params.port = params.host.split(':')[1];                                                                 // 31\n        }                                                                                                            // 32\n        params.host = params.host.split(':')[0];                                                                     // 33\n    }                                                                                                                // 34\n    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;                                          // 35\n                                                                                                                     // 36\n    var req = new Request(new xhrHttp, params);                                                                      // 37\n    if (cb) req.on('response', cb);                                                                                  // 38\n    return req;                                                                                                      // 39\n};                                                                                                                   // 40\n                                                                                                                     // 41\nhttp.get = function (params, cb) {                                                                                   // 42\n    params.method = 'GET';                                                                                           // 43\n    var req = http.request(params, cb);                                                                              // 44\n    req.end();                                                                                                       // 45\n    return req;                                                                                                      // 46\n};                                                                                                                   // 47\n                                                                                                                     // 48\nhttp.Agent = function () {};                                                                                         // 49\nhttp.Agent.defaultMaxSockets = 4;                                                                                    // 50\n                                                                                                                     // 51\nvar xhrHttp = (function () {                                                                                         // 52\n    if (typeof window === 'undefined') {                                                                             // 53\n        throw new Error('no window object present');                                                                 // 54\n    }                                                                                                                // 55\n    else if (window.XMLHttpRequest) {                                                                                // 56\n        return window.XMLHttpRequest;                                                                                // 57\n    }                                                                                                                // 58\n    else if (window.ActiveXObject) {                                                                                 // 59\n        var axs = [                                                                                                  // 60\n            'Msxml2.XMLHTTP.6.0',                                                                                    // 61\n            'Msxml2.XMLHTTP.3.0',                                                                                    // 62\n            'Microsoft.XMLHTTP'                                                                                      // 63\n        ];                                                                                                           // 64\n        for (var i = 0; i < axs.length; i++) {                                                                       // 65\n            try {                                                                                                    // 66\n                var ax = new(window.ActiveXObject)(axs[i]);                                                          // 67\n                return function () {                                                                                 // 68\n                    if (ax) {                                                                                        // 69\n                        var ax_ = ax;                                                                                // 70\n                        ax = null;                                                                                   // 71\n                        return ax_;                                                                                  // 72\n                    }                                                                                                // 73\n                    else {                                                                                           // 74\n                        return new(window.ActiveXObject)(axs[i]);                                                    // 75\n                    }                                                                                                // 76\n                };                                                                                                   // 77\n            }                                                                                                        // 78\n            catch (e) {}                                                                                             // 79\n        }                                                                                                            // 80\n        throw new Error('ajax not supported in this browser')                                                        // 81\n    }                                                                                                                // 82\n    else {                                                                                                           // 83\n        throw new Error('ajax not supported in this browser');                                                       // 84\n    }                                                                                                                // 85\n})();                                                                                                                // 86\n                                                                                                                     // 87\nhttp.STATUS_CODES = {                                                                                                // 88\n    100 : 'Continue',                                                                                                // 89\n    101 : 'Switching Protocols',                                                                                     // 90\n    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918                                           // 91\n    200 : 'OK',                                                                                                      // 92\n    201 : 'Created',                                                                                                 // 93\n    202 : 'Accepted',                                                                                                // 94\n    203 : 'Non-Authoritative Information',                                                                           // 95\n    204 : 'No Content',                                                                                              // 96\n    205 : 'Reset Content',                                                                                           // 97\n    206 : 'Partial Content',                                                                                         // 98\n    207 : 'Multi-Status',               // RFC 4918                                                                  // 99\n    300 : 'Multiple Choices',                                                                                        // 100\n    301 : 'Moved Permanently',                                                                                       // 101\n    302 : 'Moved Temporarily',                                                                                       // 102\n    303 : 'See Other',                                                                                               // 103\n    304 : 'Not Modified',                                                                                            // 104\n    305 : 'Use Proxy',                                                                                               // 105\n    307 : 'Temporary Redirect',                                                                                      // 106\n    400 : 'Bad Request',                                                                                             // 107\n    401 : 'Unauthorized',                                                                                            // 108\n    402 : 'Payment Required',                                                                                        // 109\n    403 : 'Forbidden',                                                                                               // 110\n    404 : 'Not Found',                                                                                               // 111\n    405 : 'Method Not Allowed',                                                                                      // 112\n    406 : 'Not Acceptable',                                                                                          // 113\n    407 : 'Proxy Authentication Required',                                                                           // 114\n    408 : 'Request Time-out',                                                                                        // 115\n    409 : 'Conflict',                                                                                                // 116\n    410 : 'Gone',                                                                                                    // 117\n    411 : 'Length Required',                                                                                         // 118\n    412 : 'Precondition Failed',                                                                                     // 119\n    413 : 'Request Entity Too Large',                                                                                // 120\n    414 : 'Request-URI Too Large',                                                                                   // 121\n    415 : 'Unsupported Media Type',                                                                                  // 122\n    416 : 'Requested Range Not Satisfiable',                                                                         // 123\n    417 : 'Expectation Failed',                                                                                      // 124\n    418 : 'I\\'m a teapot',              // RFC 2324                                                                  // 125\n    422 : 'Unprocessable Entity',       // RFC 4918                                                                  // 126\n    423 : 'Locked',                     // RFC 4918                                                                  // 127\n    424 : 'Failed Dependency',          // RFC 4918                                                                  // 128\n    425 : 'Unordered Collection',       // RFC 4918                                                                  // 129\n    426 : 'Upgrade Required',           // RFC 2817                                                                  // 130\n    428 : 'Precondition Required',      // RFC 6585                                                                  // 131\n    429 : 'Too Many Requests',          // RFC 6585                                                                  // 132\n    431 : 'Request Header Fields Too Large',// RFC 6585                                                              // 133\n    500 : 'Internal Server Error',                                                                                   // 134\n    501 : 'Not Implemented',                                                                                         // 135\n    502 : 'Bad Gateway',                                                                                             // 136\n    503 : 'Service Unavailable',                                                                                     // 137\n    504 : 'Gateway Time-out',                                                                                        // 138\n    505 : 'HTTP Version Not Supported',                                                                              // 139\n    506 : 'Variant Also Negotiates',    // RFC 2295                                                                  // 140\n    507 : 'Insufficient Storage',       // RFC 4918                                                                  // 141\n    509 : 'Bandwidth Limit Exceeded',                                                                                // 142\n    510 : 'Not Extended',               // RFC 2774                                                                  // 143\n    511 : 'Network Authentication Required' // RFC 6585                                                              // 144\n};                                                                                                                   // 145\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"lib\":{\"request.js\":[\"stream\",\"./response\",\"Base64\",\"inherits\",\"meteor-node-stubs/deps/stream\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/http-browserify/lib/request.js                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar Stream = require('stream');                                                                                      // 1\nvar Response = require('./response');                                                                                // 2\nvar Base64 = require('Base64');                                                                                      // 3\nvar inherits = require('inherits');                                                                                  // 4\n                                                                                                                     // 5\nvar Request = module.exports = function (xhr, params) {                                                              // 6\n    var self = this;                                                                                                 // 7\n    self.writable = true;                                                                                            // 8\n    self.xhr = xhr;                                                                                                  // 9\n    self.body = [];                                                                                                  // 10\n                                                                                                                     // 11\n    self.uri = (params.protocol || 'http:') + '//'                                                                   // 12\n        + params.host                                                                                                // 13\n        + (params.port ? ':' + params.port : '')                                                                     // 14\n        + (params.path || '/')                                                                                       // 15\n    ;                                                                                                                // 16\n                                                                                                                     // 17\n    if (typeof params.withCredentials === 'undefined') {                                                             // 18\n        params.withCredentials = true;                                                                               // 19\n    }                                                                                                                // 20\n                                                                                                                     // 21\n    try { xhr.withCredentials = params.withCredentials }                                                             // 22\n    catch (e) {}                                                                                                     // 23\n                                                                                                                     // 24\n    if (params.responseType) try { xhr.responseType = params.responseType }                                          // 25\n    catch (e) {}                                                                                                     // 26\n                                                                                                                     // 27\n    xhr.open(                                                                                                        // 28\n        params.method || 'GET',                                                                                      // 29\n        self.uri,                                                                                                    // 30\n        true                                                                                                         // 31\n    );                                                                                                               // 32\n                                                                                                                     // 33\n    xhr.onerror = function(event) {                                                                                  // 34\n        self.emit('error', new Error('Network error'));                                                              // 35\n    };                                                                                                               // 36\n                                                                                                                     // 37\n    self._headers = {};                                                                                              // 38\n                                                                                                                     // 39\n    if (params.headers) {                                                                                            // 40\n        var keys = objectKeys(params.headers);                                                                       // 41\n        for (var i = 0; i < keys.length; i++) {                                                                      // 42\n            var key = keys[i];                                                                                       // 43\n            if (!self.isSafeRequestHeader(key)) continue;                                                            // 44\n            var value = params.headers[key];                                                                         // 45\n            self.setHeader(key, value);                                                                              // 46\n        }                                                                                                            // 47\n    }                                                                                                                // 48\n                                                                                                                     // 49\n    if (params.auth) {                                                                                               // 50\n        //basic auth                                                                                                 // 51\n        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));                                        // 52\n    }                                                                                                                // 53\n                                                                                                                     // 54\n    var res = new Response;                                                                                          // 55\n    res.on('close', function () {                                                                                    // 56\n        self.emit('close');                                                                                          // 57\n    });                                                                                                              // 58\n                                                                                                                     // 59\n    res.on('ready', function () {                                                                                    // 60\n        self.emit('response', res);                                                                                  // 61\n    });                                                                                                              // 62\n                                                                                                                     // 63\n    res.on('error', function (err) {                                                                                 // 64\n        self.emit('error', err);                                                                                     // 65\n    });                                                                                                              // 66\n                                                                                                                     // 67\n    xhr.onreadystatechange = function () {                                                                           // 68\n        // Fix for IE9 bug                                                                                           // 69\n        // SCRIPT575: Could not complete the operation due to error c00c023f                                         // 70\n        // It happens when a request is aborted, calling the success callback anyway with readyState === 4           // 71\n        if (xhr.__aborted) return;                                                                                   // 72\n        res.handle(xhr);                                                                                             // 73\n    };                                                                                                               // 74\n};                                                                                                                   // 75\n                                                                                                                     // 76\ninherits(Request, Stream);                                                                                           // 77\n                                                                                                                     // 78\nRequest.prototype.setHeader = function (key, value) {                                                                // 79\n    this._headers[key.toLowerCase()] = value                                                                         // 80\n};                                                                                                                   // 81\n                                                                                                                     // 82\nRequest.prototype.getHeader = function (key) {                                                                       // 83\n    return this._headers[key.toLowerCase()]                                                                          // 84\n};                                                                                                                   // 85\n                                                                                                                     // 86\nRequest.prototype.removeHeader = function (key) {                                                                    // 87\n    delete this._headers[key.toLowerCase()]                                                                          // 88\n};                                                                                                                   // 89\n                                                                                                                     // 90\nRequest.prototype.write = function (s) {                                                                             // 91\n    this.body.push(s);                                                                                               // 92\n};                                                                                                                   // 93\n                                                                                                                     // 94\nRequest.prototype.destroy = function (s) {                                                                           // 95\n    this.xhr.__aborted = true;                                                                                       // 96\n    this.xhr.abort();                                                                                                // 97\n    this.emit('close');                                                                                              // 98\n};                                                                                                                   // 99\n                                                                                                                     // 100\nRequest.prototype.end = function (s) {                                                                               // 101\n    if (s !== undefined) this.body.push(s);                                                                          // 102\n                                                                                                                     // 103\n    var keys = objectKeys(this._headers);                                                                            // 104\n    for (var i = 0; i < keys.length; i++) {                                                                          // 105\n        var key = keys[i];                                                                                           // 106\n        var value = this._headers[key];                                                                              // 107\n        if (isArray(value)) {                                                                                        // 108\n            for (var j = 0; j < value.length; j++) {                                                                 // 109\n                this.xhr.setRequestHeader(key, value[j]);                                                            // 110\n            }                                                                                                        // 111\n        }                                                                                                            // 112\n        else this.xhr.setRequestHeader(key, value)                                                                   // 113\n    }                                                                                                                // 114\n                                                                                                                     // 115\n    if (this.body.length === 0) {                                                                                    // 116\n        this.xhr.send('');                                                                                           // 117\n    }                                                                                                                // 118\n    else if (typeof this.body[0] === 'string') {                                                                     // 119\n        this.xhr.send(this.body.join(''));                                                                           // 120\n    }                                                                                                                // 121\n    else if (isArray(this.body[0])) {                                                                                // 122\n        var body = [];                                                                                               // 123\n        for (var i = 0; i < this.body.length; i++) {                                                                 // 124\n            body.push.apply(body, this.body[i]);                                                                     // 125\n        }                                                                                                            // 126\n        this.xhr.send(body);                                                                                         // 127\n    }                                                                                                                // 128\n    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {                                           // 129\n        var len = 0;                                                                                                 // 130\n        for (var i = 0; i < this.body.length; i++) {                                                                 // 131\n            len += this.body[i].length;                                                                              // 132\n        }                                                                                                            // 133\n        var body = new(this.body[0].constructor)(len);                                                               // 134\n        var k = 0;                                                                                                   // 135\n                                                                                                                     // 136\n        for (var i = 0; i < this.body.length; i++) {                                                                 // 137\n            var b = this.body[i];                                                                                    // 138\n            for (var j = 0; j < b.length; j++) {                                                                     // 139\n                body[k++] = b[j];                                                                                    // 140\n            }                                                                                                        // 141\n        }                                                                                                            // 142\n        this.xhr.send(body);                                                                                         // 143\n    }                                                                                                                // 144\n    else if (isXHR2Compatible(this.body[0])) {                                                                       // 145\n        this.xhr.send(this.body[0]);                                                                                 // 146\n    }                                                                                                                // 147\n    else {                                                                                                           // 148\n        var body = '';                                                                                               // 149\n        for (var i = 0; i < this.body.length; i++) {                                                                 // 150\n            body += this.body[i].toString();                                                                         // 151\n        }                                                                                                            // 152\n        this.xhr.send(body);                                                                                         // 153\n    }                                                                                                                // 154\n};                                                                                                                   // 155\n                                                                                                                     // 156\n// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html              // 157\nRequest.unsafeHeaders = [                                                                                            // 158\n    \"accept-charset\",                                                                                                // 159\n    \"accept-encoding\",                                                                                               // 160\n    \"access-control-request-headers\",                                                                                // 161\n    \"access-control-request-method\",                                                                                 // 162\n    \"connection\",                                                                                                    // 163\n    \"content-length\",                                                                                                // 164\n    \"cookie\",                                                                                                        // 165\n    \"cookie2\",                                                                                                       // 166\n    \"content-transfer-encoding\",                                                                                     // 167\n    \"date\",                                                                                                          // 168\n    \"expect\",                                                                                                        // 169\n    \"host\",                                                                                                          // 170\n    \"keep-alive\",                                                                                                    // 171\n    \"origin\",                                                                                                        // 172\n    \"referer\",                                                                                                       // 173\n    \"te\",                                                                                                            // 174\n    \"trailer\",                                                                                                       // 175\n    \"transfer-encoding\",                                                                                             // 176\n    \"upgrade\",                                                                                                       // 177\n    \"user-agent\",                                                                                                    // 178\n    \"via\"                                                                                                            // 179\n];                                                                                                                   // 180\n                                                                                                                     // 181\nRequest.prototype.isSafeRequestHeader = function (headerName) {                                                      // 182\n    if (!headerName) return false;                                                                                   // 183\n    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;                                          // 184\n};                                                                                                                   // 185\n                                                                                                                     // 186\nvar objectKeys = Object.keys || function (obj) {                                                                     // 187\n    var keys = [];                                                                                                   // 188\n    for (var key in obj) keys.push(key);                                                                             // 189\n    return keys;                                                                                                     // 190\n};                                                                                                                   // 191\n                                                                                                                     // 192\nvar isArray = Array.isArray || function (xs) {                                                                       // 193\n    return Object.prototype.toString.call(xs) === '[object Array]';                                                  // 194\n};                                                                                                                   // 195\n                                                                                                                     // 196\nvar indexOf = function (xs, x) {                                                                                     // 197\n    if (xs.indexOf) return xs.indexOf(x);                                                                            // 198\n    for (var i = 0; i < xs.length; i++) {                                                                            // 199\n        if (xs[i] === x) return i;                                                                                   // 200\n    }                                                                                                                // 201\n    return -1;                                                                                                       // 202\n};                                                                                                                   // 203\n                                                                                                                     // 204\nvar isXHR2Compatible = function (obj) {                                                                              // 205\n    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;                                             // 206\n    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;                               // 207\n    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;                                     // 208\n};                                                                                                                   // 209\n                                                                                                                     // 210\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"response.js\":[\"stream\",\"util\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/http-browserify/lib/response.js                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar Stream = require('stream');                                                                                      // 1\nvar util = require('util');                                                                                          // 2\n                                                                                                                     // 3\nvar Response = module.exports = function (res) {                                                                     // 4\n    this.offset = 0;                                                                                                 // 5\n    this.readable = true;                                                                                            // 6\n};                                                                                                                   // 7\n                                                                                                                     // 8\nutil.inherits(Response, Stream);                                                                                     // 9\n                                                                                                                     // 10\nvar capable = {                                                                                                      // 11\n    streaming : true,                                                                                                // 12\n    status2 : true                                                                                                   // 13\n};                                                                                                                   // 14\n                                                                                                                     // 15\nfunction parseHeaders (res) {                                                                                        // 16\n    var lines = res.getAllResponseHeaders().split(/\\r?\\n/);                                                          // 17\n    var headers = {};                                                                                                // 18\n    for (var i = 0; i < lines.length; i++) {                                                                         // 19\n        var line = lines[i];                                                                                         // 20\n        if (line === '') continue;                                                                                   // 21\n                                                                                                                     // 22\n        var m = line.match(/^([^:]+):\\s*(.*)/);                                                                      // 23\n        if (m) {                                                                                                     // 24\n            var key = m[1].toLowerCase(), value = m[2];                                                              // 25\n                                                                                                                     // 26\n            if (headers[key] !== undefined) {                                                                        // 27\n                                                                                                                     // 28\n                if (isArray(headers[key])) {                                                                         // 29\n                    headers[key].push(value);                                                                        // 30\n                }                                                                                                    // 31\n                else {                                                                                               // 32\n                    headers[key] = [ headers[key], value ];                                                          // 33\n                }                                                                                                    // 34\n            }                                                                                                        // 35\n            else {                                                                                                   // 36\n                headers[key] = value;                                                                                // 37\n            }                                                                                                        // 38\n        }                                                                                                            // 39\n        else {                                                                                                       // 40\n            headers[line] = true;                                                                                    // 41\n        }                                                                                                            // 42\n    }                                                                                                                // 43\n    return headers;                                                                                                  // 44\n}                                                                                                                    // 45\n                                                                                                                     // 46\nResponse.prototype.getResponse = function (xhr) {                                                                    // 47\n    var respType = String(xhr.responseType).toLowerCase();                                                           // 48\n    if (respType === 'blob') return xhr.responseBlob || xhr.response;                                                // 49\n    if (respType === 'arraybuffer') return xhr.response;                                                             // 50\n    return xhr.responseText;                                                                                         // 51\n}                                                                                                                    // 52\n                                                                                                                     // 53\nResponse.prototype.getHeader = function (key) {                                                                      // 54\n    return this.headers[key.toLowerCase()];                                                                          // 55\n};                                                                                                                   // 56\n                                                                                                                     // 57\nResponse.prototype.handle = function (res) {                                                                         // 58\n    if (res.readyState === 2 && capable.status2) {                                                                   // 59\n        try {                                                                                                        // 60\n            this.statusCode = res.status;                                                                            // 61\n            this.headers = parseHeaders(res);                                                                        // 62\n        }                                                                                                            // 63\n        catch (err) {                                                                                                // 64\n            capable.status2 = false;                                                                                 // 65\n        }                                                                                                            // 66\n                                                                                                                     // 67\n        if (capable.status2) {                                                                                       // 68\n            this.emit('ready');                                                                                      // 69\n        }                                                                                                            // 70\n    }                                                                                                                // 71\n    else if (capable.streaming && res.readyState === 3) {                                                            // 72\n        try {                                                                                                        // 73\n            if (!this.statusCode) {                                                                                  // 74\n                this.statusCode = res.status;                                                                        // 75\n                this.headers = parseHeaders(res);                                                                    // 76\n                this.emit('ready');                                                                                  // 77\n            }                                                                                                        // 78\n        }                                                                                                            // 79\n        catch (err) {}                                                                                               // 80\n                                                                                                                     // 81\n        try {                                                                                                        // 82\n            this._emitData(res);                                                                                     // 83\n        }                                                                                                            // 84\n        catch (err) {                                                                                                // 85\n            capable.streaming = false;                                                                               // 86\n        }                                                                                                            // 87\n    }                                                                                                                // 88\n    else if (res.readyState === 4) {                                                                                 // 89\n        if (!this.statusCode) {                                                                                      // 90\n            this.statusCode = res.status;                                                                            // 91\n            this.emit('ready');                                                                                      // 92\n        }                                                                                                            // 93\n        this._emitData(res);                                                                                         // 94\n                                                                                                                     // 95\n        if (res.error) {                                                                                             // 96\n            this.emit('error', this.getResponse(res));                                                               // 97\n        }                                                                                                            // 98\n        else this.emit('end');                                                                                       // 99\n                                                                                                                     // 100\n        this.emit('close');                                                                                          // 101\n    }                                                                                                                // 102\n};                                                                                                                   // 103\n                                                                                                                     // 104\nResponse.prototype._emitData = function (res) {                                                                      // 105\n    var respBody = this.getResponse(res);                                                                            // 106\n    if (respBody.toString().match(/ArrayBuffer/)) {                                                                  // 107\n        this.emit('data', new Uint8Array(respBody, this.offset));                                                    // 108\n        this.offset = respBody.byteLength;                                                                           // 109\n        return;                                                                                                      // 110\n    }                                                                                                                // 111\n    if (respBody.length > this.offset) {                                                                             // 112\n        this.emit('data', respBody.slice(this.offset));                                                              // 113\n        this.offset = respBody.length;                                                                               // 114\n    }                                                                                                                // 115\n};                                                                                                                   // 116\n                                                                                                                     // 117\nvar isArray = Array.isArray || function (xs) {                                                                       // 118\n    return Object.prototype.toString.call(xs) === '[object Array]';                                                  // 119\n};                                                                                                                   // 120\n                                                                                                                     // 121\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"node_modules\":{\"Base64\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/http-browserify/node_modules/Base64/package.json                      //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"Base64\";                                                                                             // 1\nexports.version = \"0.2.1\";                                                                                           // 2\nexports.main = \"./base64.js\";                                                                                        // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"base64.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/http-browserify/node_modules/Base64/base64.js                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n;(function () {                                                                                                      // 1\n                                                                                                                     // 2\n  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers                                    // 3\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';                                   // 4\n                                                                                                                     // 5\n  function InvalidCharacterError(message) {                                                                          // 6\n    this.message = message;                                                                                          // 7\n  }                                                                                                                  // 8\n  InvalidCharacterError.prototype = new Error;                                                                       // 9\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError';                                                    // 10\n                                                                                                                     // 11\n  // encoder                                                                                                         // 12\n  // [https://gist.github.com/999166] by [https://github.com/nignag]                                                 // 13\n  object.btoa || (                                                                                                   // 14\n  object.btoa = function (input) {                                                                                   // 15\n    for (                                                                                                            // 16\n      // initialize result and counter                                                                               // 17\n      var block, charCode, idx = 0, map = chars, output = '';                                                        // 18\n      // if the next input index does not exist:                                                                     // 19\n      //   change the mapping table to \"=\"                                                                           // 20\n      //   check if d has no fractional digits                                                                       // 21\n      input.charAt(idx | 0) || (map = '=', idx % 1);                                                                 // 22\n      // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8                                                         // 23\n      output += map.charAt(63 & block >> 8 - idx % 1 * 8)                                                            // 24\n    ) {                                                                                                              // 25\n      charCode = input.charCodeAt(idx += 3/4);                                                                       // 26\n      if (charCode > 0xFF) {                                                                                         // 27\n        throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n      }                                                                                                              // 29\n      block = block << 8 | charCode;                                                                                 // 30\n    }                                                                                                                // 31\n    return output;                                                                                                   // 32\n  });                                                                                                                // 33\n                                                                                                                     // 34\n  // decoder                                                                                                         // 35\n  // [https://gist.github.com/1020396] by [https://github.com/atk]                                                   // 36\n  object.atob || (                                                                                                   // 37\n  object.atob = function (input) {                                                                                   // 38\n    input = input.replace(/=+$/, '');                                                                                // 39\n    if (input.length % 4 == 1) {                                                                                     // 40\n      throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");          // 41\n    }                                                                                                                // 42\n    for (                                                                                                            // 43\n      // initialize result and counters                                                                              // 44\n      var bc = 0, bs, buffer, idx = 0, output = '';                                                                  // 45\n      // get next character                                                                                          // 46\n      buffer = input.charAt(idx++);                                                                                  // 47\n      // character found in table? initialize bit storage and add its ascii value;                                   // 48\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,                                                           // 49\n        // and if not first of each 4 characters,                                                                    // 50\n        // convert the first 8 bits to one ascii character                                                           // 51\n        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0                                     // 52\n    ) {                                                                                                              // 53\n      // try to find character in table (0-63, not found => -1)                                                      // 54\n      buffer = chars.indexOf(buffer);                                                                                // 55\n    }                                                                                                                // 56\n    return output;                                                                                                   // 57\n  });                                                                                                                // 58\n                                                                                                                     // 59\n}());                                                                                                                // 60\n                                                                                                                     // 61\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"inherits\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/http-browserify/node_modules/inherits/package.json                    //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"inherits\";                                                                                           // 1\nexports.version = \"2.0.1\";                                                                                           // 2\nexports.main = \"./inherits_browser.js\";                                                                              // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"inherits_browser.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/http-browserify/node_modules/inherits/inherits_browser.js             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nif (typeof Object.create === 'function') {                                                                           // 1\n  // implementation from standard node.js 'util' module                                                              // 2\n  module.exports = function inherits(ctor, superCtor) {                                                              // 3\n    ctor.super_ = superCtor                                                                                          // 4\n    ctor.prototype = Object.create(superCtor.prototype, {                                                            // 5\n      constructor: {                                                                                                 // 6\n        value: ctor,                                                                                                 // 7\n        enumerable: false,                                                                                           // 8\n        writable: true,                                                                                              // 9\n        configurable: true                                                                                           // 10\n      }                                                                                                              // 11\n    });                                                                                                              // 12\n  };                                                                                                                 // 13\n} else {                                                                                                             // 14\n  // old school shim for old browsers                                                                                // 15\n  module.exports = function inherits(ctor, superCtor) {                                                              // 16\n    ctor.super_ = superCtor                                                                                          // 17\n    var TempCtor = function () {}                                                                                    // 18\n    TempCtor.prototype = superCtor.prototype                                                                         // 19\n    ctor.prototype = new TempCtor()                                                                                  // 20\n    ctor.prototype.constructor = ctor                                                                                // 21\n  }                                                                                                                  // 22\n}                                                                                                                    // 23\n                                                                                                                     // 24\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}},\"stream-browserify\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/stream-browserify/package.json                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"stream-browserify\";                                                                                  // 1\nexports.version = \"2.0.1\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"events\",\"inherits\",\"readable-stream/readable.js\",\"readable-stream/writable.js\",\"readable-stream/duplex.js\",\"readable-stream/transform.js\",\"readable-stream/passthrough.js\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/stream-browserify/index.js                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\nmodule.exports = Stream;                                                                                             // 22\n                                                                                                                     // 23\nvar EE = require('events').EventEmitter;                                                                             // 24\nvar inherits = require('inherits');                                                                                  // 25\n                                                                                                                     // 26\ninherits(Stream, EE);                                                                                                // 27\nStream.Readable = require('readable-stream/readable.js');                                                            // 28\nStream.Writable = require('readable-stream/writable.js');                                                            // 29\nStream.Duplex = require('readable-stream/duplex.js');                                                                // 30\nStream.Transform = require('readable-stream/transform.js');                                                          // 31\nStream.PassThrough = require('readable-stream/passthrough.js');                                                      // 32\n                                                                                                                     // 33\n// Backwards-compat with node 0.4.x                                                                                  // 34\nStream.Stream = Stream;                                                                                              // 35\n                                                                                                                     // 36\n                                                                                                                     // 37\n                                                                                                                     // 38\n// old-style streams.  Note that the pipe method (the only relevant                                                  // 39\n// part of this class) is overridden in the Readable class.                                                          // 40\n                                                                                                                     // 41\nfunction Stream() {                                                                                                  // 42\n  EE.call(this);                                                                                                     // 43\n}                                                                                                                    // 44\n                                                                                                                     // 45\nStream.prototype.pipe = function(dest, options) {                                                                    // 46\n  var source = this;                                                                                                 // 47\n                                                                                                                     // 48\n  function ondata(chunk) {                                                                                           // 49\n    if (dest.writable) {                                                                                             // 50\n      if (false === dest.write(chunk) && source.pause) {                                                             // 51\n        source.pause();                                                                                              // 52\n      }                                                                                                              // 53\n    }                                                                                                                // 54\n  }                                                                                                                  // 55\n                                                                                                                     // 56\n  source.on('data', ondata);                                                                                         // 57\n                                                                                                                     // 58\n  function ondrain() {                                                                                               // 59\n    if (source.readable && source.resume) {                                                                          // 60\n      source.resume();                                                                                               // 61\n    }                                                                                                                // 62\n  }                                                                                                                  // 63\n                                                                                                                     // 64\n  dest.on('drain', ondrain);                                                                                         // 65\n                                                                                                                     // 66\n  // If the 'end' option is not supplied, dest.end() will be called when                                             // 67\n  // source gets the 'end' or 'close' events.  Only dest.end() once.                                                 // 68\n  if (!dest._isStdio && (!options || options.end !== false)) {                                                       // 69\n    source.on('end', onend);                                                                                         // 70\n    source.on('close', onclose);                                                                                     // 71\n  }                                                                                                                  // 72\n                                                                                                                     // 73\n  var didOnEnd = false;                                                                                              // 74\n  function onend() {                                                                                                 // 75\n    if (didOnEnd) return;                                                                                            // 76\n    didOnEnd = true;                                                                                                 // 77\n                                                                                                                     // 78\n    dest.end();                                                                                                      // 79\n  }                                                                                                                  // 80\n                                                                                                                     // 81\n                                                                                                                     // 82\n  function onclose() {                                                                                               // 83\n    if (didOnEnd) return;                                                                                            // 84\n    didOnEnd = true;                                                                                                 // 85\n                                                                                                                     // 86\n    if (typeof dest.destroy === 'function') dest.destroy();                                                          // 87\n  }                                                                                                                  // 88\n                                                                                                                     // 89\n  // don't leave dangling pipes when there are errors.                                                               // 90\n  function onerror(er) {                                                                                             // 91\n    cleanup();                                                                                                       // 92\n    if (EE.listenerCount(this, 'error') === 0) {                                                                     // 93\n      throw er; // Unhandled stream error in pipe.                                                                   // 94\n    }                                                                                                                // 95\n  }                                                                                                                  // 96\n                                                                                                                     // 97\n  source.on('error', onerror);                                                                                       // 98\n  dest.on('error', onerror);                                                                                         // 99\n                                                                                                                     // 100\n  // remove all the event listeners that were added.                                                                 // 101\n  function cleanup() {                                                                                               // 102\n    source.removeListener('data', ondata);                                                                           // 103\n    dest.removeListener('drain', ondrain);                                                                           // 104\n                                                                                                                     // 105\n    source.removeListener('end', onend);                                                                             // 106\n    source.removeListener('close', onclose);                                                                         // 107\n                                                                                                                     // 108\n    source.removeListener('error', onerror);                                                                         // 109\n    dest.removeListener('error', onerror);                                                                           // 110\n                                                                                                                     // 111\n    source.removeListener('end', cleanup);                                                                           // 112\n    source.removeListener('close', cleanup);                                                                         // 113\n                                                                                                                     // 114\n    dest.removeListener('close', cleanup);                                                                           // 115\n  }                                                                                                                  // 116\n                                                                                                                     // 117\n  source.on('end', cleanup);                                                                                         // 118\n  source.on('close', cleanup);                                                                                       // 119\n                                                                                                                     // 120\n  dest.on('close', cleanup);                                                                                         // 121\n                                                                                                                     // 122\n  dest.emit('pipe', source);                                                                                         // 123\n                                                                                                                     // 124\n  // Allow for unix-like usage: A.pipe(B).pipe(C)                                                                    // 125\n  return dest;                                                                                                       // 126\n};                                                                                                                   // 127\n                                                                                                                     // 128\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"inherits\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/stream-browserify/node_modules/inherits/package.json                  //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"inherits\";                                                                                           // 1\nexports.version = \"2.0.1\";                                                                                           // 2\nexports.main = \"./inherits_browser.js\";                                                                              // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"inherits_browser.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/stream-browserify/node_modules/inherits/inherits_browser.js           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nif (typeof Object.create === 'function') {                                                                           // 1\n  // implementation from standard node.js 'util' module                                                              // 2\n  module.exports = function inherits(ctor, superCtor) {                                                              // 3\n    ctor.super_ = superCtor                                                                                          // 4\n    ctor.prototype = Object.create(superCtor.prototype, {                                                            // 5\n      constructor: {                                                                                                 // 6\n        value: ctor,                                                                                                 // 7\n        enumerable: false,                                                                                           // 8\n        writable: true,                                                                                              // 9\n        configurable: true                                                                                           // 10\n      }                                                                                                              // 11\n    });                                                                                                              // 12\n  };                                                                                                                 // 13\n} else {                                                                                                             // 14\n  // old school shim for old browsers                                                                                // 15\n  module.exports = function inherits(ctor, superCtor) {                                                              // 16\n    ctor.super_ = superCtor                                                                                          // 17\n    var TempCtor = function () {}                                                                                    // 18\n    TempCtor.prototype = superCtor.prototype                                                                         // 19\n    ctor.prototype = new TempCtor()                                                                                  // 20\n    ctor.prototype.constructor = ctor                                                                                // 21\n  }                                                                                                                  // 22\n}                                                                                                                    // 23\n                                                                                                                     // 24\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}},\"readable-stream\":{\"readable.js\":[\"./lib/_stream_readable.js\",\"./lib/_stream_writable.js\",\"./lib/_stream_duplex.js\",\"./lib/_stream_transform.js\",\"./lib/_stream_passthrough.js\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/readable.js                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar Stream = (function (){                                                                                           // 1\n  try {                                                                                                              // 2\n    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify              // 3\n  } catch(_){}                                                                                                       // 4\n}());                                                                                                                // 5\nexports = module.exports = require('./lib/_stream_readable.js');                                                     // 6\nexports.Stream = Stream || exports;                                                                                  // 7\nexports.Readable = exports;                                                                                          // 8\nexports.Writable = require('./lib/_stream_writable.js');                                                             // 9\nexports.Duplex = require('./lib/_stream_duplex.js');                                                                 // 10\nexports.Transform = require('./lib/_stream_transform.js');                                                           // 11\nexports.PassThrough = require('./lib/_stream_passthrough.js');                                                       // 12\n                                                                                                                     // 13\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"lib\":{\"_stream_readable.js\":[\"process-nextick-args\",\"isarray\",\"buffer\",\"events\",\"core-util-is\",\"inherits\",\"util\",\"./_stream_duplex\",\"string_decoder/\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/lib/_stream_readable.js                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n'use strict';                                                                                                        // 1\n                                                                                                                     // 2\nmodule.exports = Readable;                                                                                           // 3\n                                                                                                                     // 4\n/*<replacement>*/                                                                                                    // 5\nvar processNextTick = require('process-nextick-args');                                                               // 6\n/*</replacement>*/                                                                                                   // 7\n                                                                                                                     // 8\n/*<replacement>*/                                                                                                    // 9\nvar isArray = require('isarray');                                                                                    // 10\n/*</replacement>*/                                                                                                   // 11\n                                                                                                                     // 12\n/*<replacement>*/                                                                                                    // 13\nvar Buffer = require('buffer').Buffer;                                                                               // 14\n/*</replacement>*/                                                                                                   // 15\n                                                                                                                     // 16\nReadable.ReadableState = ReadableState;                                                                              // 17\n                                                                                                                     // 18\nvar EE = require('events');                                                                                          // 19\n                                                                                                                     // 20\n/*<replacement>*/                                                                                                    // 21\nvar EElistenerCount = function (emitter, type) {                                                                     // 22\n  return emitter.listeners(type).length;                                                                             // 23\n};                                                                                                                   // 24\n/*</replacement>*/                                                                                                   // 25\n                                                                                                                     // 26\n/*<replacement>*/                                                                                                    // 27\nvar Stream;                                                                                                          // 28\n(function () {                                                                                                       // 29\n  try {                                                                                                              // 30\n    Stream = require('st' + 'ream');                                                                                 // 31\n  } catch (_) {} finally {                                                                                           // 32\n    if (!Stream) Stream = require('events').EventEmitter;                                                            // 33\n  }                                                                                                                  // 34\n})();                                                                                                                // 35\n/*</replacement>*/                                                                                                   // 36\n                                                                                                                     // 37\nvar Buffer = require('buffer').Buffer;                                                                               // 38\n                                                                                                                     // 39\n/*<replacement>*/                                                                                                    // 40\nvar util = require('core-util-is');                                                                                  // 41\nutil.inherits = require('inherits');                                                                                 // 42\n/*</replacement>*/                                                                                                   // 43\n                                                                                                                     // 44\n/*<replacement>*/                                                                                                    // 45\nvar debugUtil = require('util');                                                                                     // 46\nvar debug = undefined;                                                                                               // 47\nif (debugUtil && debugUtil.debuglog) {                                                                               // 48\n  debug = debugUtil.debuglog('stream');                                                                              // 49\n} else {                                                                                                             // 50\n  debug = function () {};                                                                                            // 51\n}                                                                                                                    // 52\n/*</replacement>*/                                                                                                   // 53\n                                                                                                                     // 54\nvar StringDecoder;                                                                                                   // 55\n                                                                                                                     // 56\nutil.inherits(Readable, Stream);                                                                                     // 57\n                                                                                                                     // 58\nvar Duplex;                                                                                                          // 59\nfunction ReadableState(options, stream) {                                                                            // 60\n  Duplex = Duplex || require('./_stream_duplex');                                                                    // 61\n                                                                                                                     // 62\n  options = options || {};                                                                                           // 63\n                                                                                                                     // 64\n  // object stream flag. Used to make read(n) ignore n and to                                                        // 65\n  // make all the buffer merging and length checks go away                                                           // 66\n  this.objectMode = !!options.objectMode;                                                                            // 67\n                                                                                                                     // 68\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;                   // 69\n                                                                                                                     // 70\n  // the point at which it stops calling _read() to fill the buffer                                                  // 71\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"                                            // 72\n  var hwm = options.highWaterMark;                                                                                   // 73\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;                                                                 // 74\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;                                                          // 75\n                                                                                                                     // 76\n  // cast to ints.                                                                                                   // 77\n  this.highWaterMark = ~ ~this.highWaterMark;                                                                        // 78\n                                                                                                                     // 79\n  this.buffer = [];                                                                                                  // 80\n  this.length = 0;                                                                                                   // 81\n  this.pipes = null;                                                                                                 // 82\n  this.pipesCount = 0;                                                                                               // 83\n  this.flowing = null;                                                                                               // 84\n  this.ended = false;                                                                                                // 85\n  this.endEmitted = false;                                                                                           // 86\n  this.reading = false;                                                                                              // 87\n                                                                                                                     // 88\n  // a flag to be able to tell if the onwrite cb is called immediately,                                              // 89\n  // or on a later tick.  We set this to true at first, because any                                                  // 90\n  // actions that shouldn't happen until \"later\" should generally also                                               // 91\n  // not happen before the first write call.                                                                         // 92\n  this.sync = true;                                                                                                  // 93\n                                                                                                                     // 94\n  // whenever we return null, then we set a flag to say                                                              // 95\n  // that we're awaiting a 'readable' event emission.                                                                // 96\n  this.needReadable = false;                                                                                         // 97\n  this.emittedReadable = false;                                                                                      // 98\n  this.readableListening = false;                                                                                    // 99\n  this.resumeScheduled = false;                                                                                      // 100\n                                                                                                                     // 101\n  // Crypto is kind of old and crusty.  Historically, its default string                                             // 102\n  // encoding is 'binary' so we have to make this configurable.                                                      // 103\n  // Everything else in the universe uses 'utf8', though.                                                            // 104\n  this.defaultEncoding = options.defaultEncoding || 'utf8';                                                          // 105\n                                                                                                                     // 106\n  // when piping, we only care about 'readable' events that happen                                                   // 107\n  // after read()ing all the bytes and not getting any pushback.                                                     // 108\n  this.ranOut = false;                                                                                               // 109\n                                                                                                                     // 110\n  // the number of writers that are awaiting a drain event in .pipe()s                                               // 111\n  this.awaitDrain = 0;                                                                                               // 112\n                                                                                                                     // 113\n  // if true, a maybeReadMore has been scheduled                                                                     // 114\n  this.readingMore = false;                                                                                          // 115\n                                                                                                                     // 116\n  this.decoder = null;                                                                                               // 117\n  this.encoding = null;                                                                                              // 118\n  if (options.encoding) {                                                                                            // 119\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;                                    // 120\n    this.decoder = new StringDecoder(options.encoding);                                                              // 121\n    this.encoding = options.encoding;                                                                                // 122\n  }                                                                                                                  // 123\n}                                                                                                                    // 124\n                                                                                                                     // 125\nvar Duplex;                                                                                                          // 126\nfunction Readable(options) {                                                                                         // 127\n  Duplex = Duplex || require('./_stream_duplex');                                                                    // 128\n                                                                                                                     // 129\n  if (!(this instanceof Readable)) return new Readable(options);                                                     // 130\n                                                                                                                     // 131\n  this._readableState = new ReadableState(options, this);                                                            // 132\n                                                                                                                     // 133\n  // legacy                                                                                                          // 134\n  this.readable = true;                                                                                              // 135\n                                                                                                                     // 136\n  if (options && typeof options.read === 'function') this._read = options.read;                                      // 137\n                                                                                                                     // 138\n  Stream.call(this);                                                                                                 // 139\n}                                                                                                                    // 140\n                                                                                                                     // 141\n// Manually shove something into the read() buffer.                                                                  // 142\n// This returns true if the highWaterMark has not been hit yet,                                                      // 143\n// similar to how Writable.write() returns true if you should                                                        // 144\n// write() some more.                                                                                                // 145\nReadable.prototype.push = function (chunk, encoding) {                                                               // 146\n  var state = this._readableState;                                                                                   // 147\n                                                                                                                     // 148\n  if (!state.objectMode && typeof chunk === 'string') {                                                              // 149\n    encoding = encoding || state.defaultEncoding;                                                                    // 150\n    if (encoding !== state.encoding) {                                                                               // 151\n      chunk = new Buffer(chunk, encoding);                                                                           // 152\n      encoding = '';                                                                                                 // 153\n    }                                                                                                                // 154\n  }                                                                                                                  // 155\n                                                                                                                     // 156\n  return readableAddChunk(this, state, chunk, encoding, false);                                                      // 157\n};                                                                                                                   // 158\n                                                                                                                     // 159\n// Unshift should *always* be something directly out of read()                                                       // 160\nReadable.prototype.unshift = function (chunk) {                                                                      // 161\n  var state = this._readableState;                                                                                   // 162\n  return readableAddChunk(this, state, chunk, '', true);                                                             // 163\n};                                                                                                                   // 164\n                                                                                                                     // 165\nReadable.prototype.isPaused = function () {                                                                          // 166\n  return this._readableState.flowing === false;                                                                      // 167\n};                                                                                                                   // 168\n                                                                                                                     // 169\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {                                              // 170\n  var er = chunkInvalid(state, chunk);                                                                               // 171\n  if (er) {                                                                                                          // 172\n    stream.emit('error', er);                                                                                        // 173\n  } else if (chunk === null) {                                                                                       // 174\n    state.reading = false;                                                                                           // 175\n    onEofChunk(stream, state);                                                                                       // 176\n  } else if (state.objectMode || chunk && chunk.length > 0) {                                                        // 177\n    if (state.ended && !addToFront) {                                                                                // 178\n      var e = new Error('stream.push() after EOF');                                                                  // 179\n      stream.emit('error', e);                                                                                       // 180\n    } else if (state.endEmitted && addToFront) {                                                                     // 181\n      var e = new Error('stream.unshift() after end event');                                                         // 182\n      stream.emit('error', e);                                                                                       // 183\n    } else {                                                                                                         // 184\n      var skipAdd;                                                                                                   // 185\n      if (state.decoder && !addToFront && !encoding) {                                                               // 186\n        chunk = state.decoder.write(chunk);                                                                          // 187\n        skipAdd = !state.objectMode && chunk.length === 0;                                                           // 188\n      }                                                                                                              // 189\n                                                                                                                     // 190\n      if (!addToFront) state.reading = false;                                                                        // 191\n                                                                                                                     // 192\n      // Don't add to the buffer if we've decoded to an empty string chunk and                                       // 193\n      // we're not in object mode                                                                                    // 194\n      if (!skipAdd) {                                                                                                // 195\n        // if we want the data now, just emit it.                                                                    // 196\n        if (state.flowing && state.length === 0 && !state.sync) {                                                    // 197\n          stream.emit('data', chunk);                                                                                // 198\n          stream.read(0);                                                                                            // 199\n        } else {                                                                                                     // 200\n          // update the buffer info.                                                                                 // 201\n          state.length += state.objectMode ? 1 : chunk.length;                                                       // 202\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);                                 // 203\n                                                                                                                     // 204\n          if (state.needReadable) emitReadable(stream);                                                              // 205\n        }                                                                                                            // 206\n      }                                                                                                              // 207\n                                                                                                                     // 208\n      maybeReadMore(stream, state);                                                                                  // 209\n    }                                                                                                                // 210\n  } else if (!addToFront) {                                                                                          // 211\n    state.reading = false;                                                                                           // 212\n  }                                                                                                                  // 213\n                                                                                                                     // 214\n  return needMoreData(state);                                                                                        // 215\n}                                                                                                                    // 216\n                                                                                                                     // 217\n// if it's past the high water mark, we can push in some more.                                                       // 218\n// Also, if we have no data yet, we can stand some                                                                   // 219\n// more bytes.  This is to work around cases where hwm=0,                                                            // 220\n// such as the repl.  Also, if the push() triggered a                                                                // 221\n// readable event, and the user called read(largeNumber) such that                                                   // 222\n// needReadable was set, then we ought to push more, so that another                                                 // 223\n// 'readable' event will be triggered.                                                                               // 224\nfunction needMoreData(state) {                                                                                       // 225\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);           // 226\n}                                                                                                                    // 227\n                                                                                                                     // 228\n// backwards compatibility.                                                                                          // 229\nReadable.prototype.setEncoding = function (enc) {                                                                    // 230\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;                                      // 231\n  this._readableState.decoder = new StringDecoder(enc);                                                              // 232\n  this._readableState.encoding = enc;                                                                                // 233\n  return this;                                                                                                       // 234\n};                                                                                                                   // 235\n                                                                                                                     // 236\n// Don't raise the hwm > 8MB                                                                                         // 237\nvar MAX_HWM = 0x800000;                                                                                              // 238\nfunction computeNewHighWaterMark(n) {                                                                                // 239\n  if (n >= MAX_HWM) {                                                                                                // 240\n    n = MAX_HWM;                                                                                                     // 241\n  } else {                                                                                                           // 242\n    // Get the next highest power of 2                                                                               // 243\n    n--;                                                                                                             // 244\n    n |= n >>> 1;                                                                                                    // 245\n    n |= n >>> 2;                                                                                                    // 246\n    n |= n >>> 4;                                                                                                    // 247\n    n |= n >>> 8;                                                                                                    // 248\n    n |= n >>> 16;                                                                                                   // 249\n    n++;                                                                                                             // 250\n  }                                                                                                                  // 251\n  return n;                                                                                                          // 252\n}                                                                                                                    // 253\n                                                                                                                     // 254\nfunction howMuchToRead(n, state) {                                                                                   // 255\n  if (state.length === 0 && state.ended) return 0;                                                                   // 256\n                                                                                                                     // 257\n  if (state.objectMode) return n === 0 ? 0 : 1;                                                                      // 258\n                                                                                                                     // 259\n  if (n === null || isNaN(n)) {                                                                                      // 260\n    // only flow one buffer at a time                                                                                // 261\n    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;                // 262\n  }                                                                                                                  // 263\n                                                                                                                     // 264\n  if (n <= 0) return 0;                                                                                              // 265\n                                                                                                                     // 266\n  // If we're asking for more than the target buffer level,                                                          // 267\n  // then raise the water mark.  Bump up to the next highest                                                         // 268\n  // power of 2, to prevent increasing it excessively in tiny                                                        // 269\n  // amounts.                                                                                                        // 270\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);                                     // 271\n                                                                                                                     // 272\n  // don't have that much.  return null, unless we've ended.                                                         // 273\n  if (n > state.length) {                                                                                            // 274\n    if (!state.ended) {                                                                                              // 275\n      state.needReadable = true;                                                                                     // 276\n      return 0;                                                                                                      // 277\n    } else {                                                                                                         // 278\n      return state.length;                                                                                           // 279\n    }                                                                                                                // 280\n  }                                                                                                                  // 281\n                                                                                                                     // 282\n  return n;                                                                                                          // 283\n}                                                                                                                    // 284\n                                                                                                                     // 285\n// you can override either this method, or the async _read(n) below.                                                 // 286\nReadable.prototype.read = function (n) {                                                                             // 287\n  debug('read', n);                                                                                                  // 288\n  var state = this._readableState;                                                                                   // 289\n  var nOrig = n;                                                                                                     // 290\n                                                                                                                     // 291\n  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;                                                 // 292\n                                                                                                                     // 293\n  // if we're doing read(0) to trigger a readable event, but we                                                      // 294\n  // already have a bunch of data in the buffer, then just trigger                                                   // 295\n  // the 'readable' event and move on.                                                                               // 296\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {                       // 297\n    debug('read: emitReadable', state.length, state.ended);                                                          // 298\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);                                // 299\n    return null;                                                                                                     // 300\n  }                                                                                                                  // 301\n                                                                                                                     // 302\n  n = howMuchToRead(n, state);                                                                                       // 303\n                                                                                                                     // 304\n  // if we've ended, and we're now clear, then finish it up.                                                         // 305\n  if (n === 0 && state.ended) {                                                                                      // 306\n    if (state.length === 0) endReadable(this);                                                                       // 307\n    return null;                                                                                                     // 308\n  }                                                                                                                  // 309\n                                                                                                                     // 310\n  // All the actual chunk generation logic needs to be                                                               // 311\n  // *below* the call to _read.  The reason is that in certain                                                       // 312\n  // synthetic stream cases, such as passthrough streams, _read                                                      // 313\n  // may be a completely synchronous operation which may change                                                      // 314\n  // the state of the read buffer, providing enough data when                                                        // 315\n  // before there was *not* enough.                                                                                  // 316\n  //                                                                                                                 // 317\n  // So, the steps are:                                                                                              // 318\n  // 1. Figure out what the state of things will be after we do                                                      // 319\n  // a read from the buffer.                                                                                         // 320\n  //                                                                                                                 // 321\n  // 2. If that resulting state will trigger a _read, then call _read.                                               // 322\n  // Note that this may be asynchronous, or synchronous.  Yes, it is                                                 // 323\n  // deeply ugly to write APIs this way, but that still doesn't mean                                                 // 324\n  // that the Readable class should behave improperly, as streams are                                                // 325\n  // designed to be sync/async agnostic.                                                                             // 326\n  // Take note if the _read call is sync or async (ie, if the read call                                              // 327\n  // has returned yet), so that we know whether or not it's safe to emit                                             // 328\n  // 'readable' etc.                                                                                                 // 329\n  //                                                                                                                 // 330\n  // 3. Actually pull the requested chunks out of the buffer and return.                                             // 331\n                                                                                                                     // 332\n  // if we need a readable event, then we need to do some reading.                                                   // 333\n  var doRead = state.needReadable;                                                                                   // 334\n  debug('need readable', doRead);                                                                                    // 335\n                                                                                                                     // 336\n  // if we currently have less than the highWaterMark, then also read some                                           // 337\n  if (state.length === 0 || state.length - n < state.highWaterMark) {                                                // 338\n    doRead = true;                                                                                                   // 339\n    debug('length less than watermark', doRead);                                                                     // 340\n  }                                                                                                                  // 341\n                                                                                                                     // 342\n  // however, if we've ended, then there's no point, and if we're already                                            // 343\n  // reading, then it's unnecessary.                                                                                 // 344\n  if (state.ended || state.reading) {                                                                                // 345\n    doRead = false;                                                                                                  // 346\n    debug('reading or ended', doRead);                                                                               // 347\n  }                                                                                                                  // 348\n                                                                                                                     // 349\n  if (doRead) {                                                                                                      // 350\n    debug('do read');                                                                                                // 351\n    state.reading = true;                                                                                            // 352\n    state.sync = true;                                                                                               // 353\n    // if the length is currently zero, then we *need* a readable event.                                             // 354\n    if (state.length === 0) state.needReadable = true;                                                               // 355\n    // call internal read method                                                                                     // 356\n    this._read(state.highWaterMark);                                                                                 // 357\n    state.sync = false;                                                                                              // 358\n  }                                                                                                                  // 359\n                                                                                                                     // 360\n  // If _read pushed data synchronously, then `reading` will be false,                                               // 361\n  // and we need to re-evaluate how much data we can return to the user.                                             // 362\n  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);                                                     // 363\n                                                                                                                     // 364\n  var ret;                                                                                                           // 365\n  if (n > 0) ret = fromList(n, state);else ret = null;                                                               // 366\n                                                                                                                     // 367\n  if (ret === null) {                                                                                                // 368\n    state.needReadable = true;                                                                                       // 369\n    n = 0;                                                                                                           // 370\n  }                                                                                                                  // 371\n                                                                                                                     // 372\n  state.length -= n;                                                                                                 // 373\n                                                                                                                     // 374\n  // If we have nothing in the buffer, then we want to know                                                          // 375\n  // as soon as we *do* get something into the buffer.                                                               // 376\n  if (state.length === 0 && !state.ended) state.needReadable = true;                                                 // 377\n                                                                                                                     // 378\n  // If we tried to read() past the EOF, then emit end on the next tick.                                             // 379\n  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);                                           // 380\n                                                                                                                     // 381\n  if (ret !== null) this.emit('data', ret);                                                                          // 382\n                                                                                                                     // 383\n  return ret;                                                                                                        // 384\n};                                                                                                                   // 385\n                                                                                                                     // 386\nfunction chunkInvalid(state, chunk) {                                                                                // 387\n  var er = null;                                                                                                     // 388\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');                                                           // 390\n  }                                                                                                                  // 391\n  return er;                                                                                                         // 392\n}                                                                                                                    // 393\n                                                                                                                     // 394\nfunction onEofChunk(stream, state) {                                                                                 // 395\n  if (state.ended) return;                                                                                           // 396\n  if (state.decoder) {                                                                                               // 397\n    var chunk = state.decoder.end();                                                                                 // 398\n    if (chunk && chunk.length) {                                                                                     // 399\n      state.buffer.push(chunk);                                                                                      // 400\n      state.length += state.objectMode ? 1 : chunk.length;                                                           // 401\n    }                                                                                                                // 402\n  }                                                                                                                  // 403\n  state.ended = true;                                                                                                // 404\n                                                                                                                     // 405\n  // emit 'readable' now to make sure it gets picked up.                                                             // 406\n  emitReadable(stream);                                                                                              // 407\n}                                                                                                                    // 408\n                                                                                                                     // 409\n// Don't emit readable right away in sync mode, because this can trigger                                             // 410\n// another read() call => stack overflow.  This way, it might trigger                                                // 411\n// a nextTick recursion warning, but that's not so bad.                                                              // 412\nfunction emitReadable(stream) {                                                                                      // 413\n  var state = stream._readableState;                                                                                 // 414\n  state.needReadable = false;                                                                                        // 415\n  if (!state.emittedReadable) {                                                                                      // 416\n    debug('emitReadable', state.flowing);                                                                            // 417\n    state.emittedReadable = true;                                                                                    // 418\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);                               // 419\n  }                                                                                                                  // 420\n}                                                                                                                    // 421\n                                                                                                                     // 422\nfunction emitReadable_(stream) {                                                                                     // 423\n  debug('emit readable');                                                                                            // 424\n  stream.emit('readable');                                                                                           // 425\n  flow(stream);                                                                                                      // 426\n}                                                                                                                    // 427\n                                                                                                                     // 428\n// at this point, the user has presumably seen the 'readable' event,                                                 // 429\n// and called read() to consume some data.  that may have triggered                                                  // 430\n// in turn another _read(n) call, in which case reading = true if                                                    // 431\n// it's in progress.                                                                                                 // 432\n// However, if we're not ended, or reading, and the length < hwm,                                                    // 433\n// then go ahead and try to read some more preemptively.                                                             // 434\nfunction maybeReadMore(stream, state) {                                                                              // 435\n  if (!state.readingMore) {                                                                                          // 436\n    state.readingMore = true;                                                                                        // 437\n    processNextTick(maybeReadMore_, stream, state);                                                                  // 438\n  }                                                                                                                  // 439\n}                                                                                                                    // 440\n                                                                                                                     // 441\nfunction maybeReadMore_(stream, state) {                                                                             // 442\n  var len = state.length;                                                                                            // 443\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {                   // 444\n    debug('maybeReadMore read 0');                                                                                   // 445\n    stream.read(0);                                                                                                  // 446\n    if (len === state.length)                                                                                        // 447\n      // didn't get any data, stop spinning.                                                                         // 448\n      break;else len = state.length;                                                                                 // 449\n  }                                                                                                                  // 450\n  state.readingMore = false;                                                                                         // 451\n}                                                                                                                    // 452\n                                                                                                                     // 453\n// abstract method.  to be overridden in specific implementation classes.                                            // 454\n// call cb(er, data) where data is <= n in length.                                                                   // 455\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat                                                // 456\n// arbitrary, and perhaps not very meaningful.                                                                       // 457\nReadable.prototype._read = function (n) {                                                                            // 458\n  this.emit('error', new Error('not implemented'));                                                                  // 459\n};                                                                                                                   // 460\n                                                                                                                     // 461\nReadable.prototype.pipe = function (dest, pipeOpts) {                                                                // 462\n  var src = this;                                                                                                    // 463\n  var state = this._readableState;                                                                                   // 464\n                                                                                                                     // 465\n  switch (state.pipesCount) {                                                                                        // 466\n    case 0:                                                                                                          // 467\n      state.pipes = dest;                                                                                            // 468\n      break;                                                                                                         // 469\n    case 1:                                                                                                          // 470\n      state.pipes = [state.pipes, dest];                                                                             // 471\n      break;                                                                                                         // 472\n    default:                                                                                                         // 473\n      state.pipes.push(dest);                                                                                        // 474\n      break;                                                                                                         // 475\n  }                                                                                                                  // 476\n  state.pipesCount += 1;                                                                                             // 477\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);                                                        // 478\n                                                                                                                     // 479\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;           // 480\n                                                                                                                     // 481\n  var endFn = doEnd ? onend : cleanup;                                                                               // 482\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);                                          // 483\n                                                                                                                     // 484\n  dest.on('unpipe', onunpipe);                                                                                       // 485\n  function onunpipe(readable) {                                                                                      // 486\n    debug('onunpipe');                                                                                               // 487\n    if (readable === src) {                                                                                          // 488\n      cleanup();                                                                                                     // 489\n    }                                                                                                                // 490\n  }                                                                                                                  // 491\n                                                                                                                     // 492\n  function onend() {                                                                                                 // 493\n    debug('onend');                                                                                                  // 494\n    dest.end();                                                                                                      // 495\n  }                                                                                                                  // 496\n                                                                                                                     // 497\n  // when the dest drains, it reduces the awaitDrain counter                                                         // 498\n  // on the source.  This would be more elegant with a .once()                                                       // 499\n  // handler in flow(), but adding and removing repeatedly is                                                        // 500\n  // too slow.                                                                                                       // 501\n  var ondrain = pipeOnDrain(src);                                                                                    // 502\n  dest.on('drain', ondrain);                                                                                         // 503\n                                                                                                                     // 504\n  var cleanedUp = false;                                                                                             // 505\n  function cleanup() {                                                                                               // 506\n    debug('cleanup');                                                                                                // 507\n    // cleanup event handlers once the pipe is broken                                                                // 508\n    dest.removeListener('close', onclose);                                                                           // 509\n    dest.removeListener('finish', onfinish);                                                                         // 510\n    dest.removeListener('drain', ondrain);                                                                           // 511\n    dest.removeListener('error', onerror);                                                                           // 512\n    dest.removeListener('unpipe', onunpipe);                                                                         // 513\n    src.removeListener('end', onend);                                                                                // 514\n    src.removeListener('end', cleanup);                                                                              // 515\n    src.removeListener('data', ondata);                                                                              // 516\n                                                                                                                     // 517\n    cleanedUp = true;                                                                                                // 518\n                                                                                                                     // 519\n    // if the reader is waiting for a drain event from this                                                          // 520\n    // specific writer, then it would cause it to never start                                                        // 521\n    // flowing again.                                                                                                // 522\n    // So, if this is awaiting a drain, then we just call it now.                                                    // 523\n    // If we don't know, then assume that we are waiting for one.                                                    // 524\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();                      // 525\n  }                                                                                                                  // 526\n                                                                                                                     // 527\n  src.on('data', ondata);                                                                                            // 528\n  function ondata(chunk) {                                                                                           // 529\n    debug('ondata');                                                                                                 // 530\n    var ret = dest.write(chunk);                                                                                     // 531\n    if (false === ret) {                                                                                             // 532\n      // If the user unpiped during `dest.write()`, it is possible                                                   // 533\n      // to get stuck in a permanently paused state if that write                                                    // 534\n      // also returned false.                                                                                        // 535\n      if (state.pipesCount === 1 && state.pipes[0] === dest && src.listenerCount('data') === 1 && !cleanedUp) {      // 536\n        debug('false write response, pause', src._readableState.awaitDrain);                                         // 537\n        src._readableState.awaitDrain++;                                                                             // 538\n      }                                                                                                              // 539\n      src.pause();                                                                                                   // 540\n    }                                                                                                                // 541\n  }                                                                                                                  // 542\n                                                                                                                     // 543\n  // if the dest has an error, then stop piping into it.                                                             // 544\n  // however, don't suppress the throwing behavior for this.                                                         // 545\n  function onerror(er) {                                                                                             // 546\n    debug('onerror', er);                                                                                            // 547\n    unpipe();                                                                                                        // 548\n    dest.removeListener('error', onerror);                                                                           // 549\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);                                                // 550\n  }                                                                                                                  // 551\n  // This is a brutally ugly hack to make sure that our error handler                                                // 552\n  // is attached before any userland ones.  NEVER DO THIS.                                                           // 553\n  if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error];\n                                                                                                                     // 555\n  // Both close and finish should trigger unpipe, but only once.                                                     // 556\n  function onclose() {                                                                                               // 557\n    dest.removeListener('finish', onfinish);                                                                         // 558\n    unpipe();                                                                                                        // 559\n  }                                                                                                                  // 560\n  dest.once('close', onclose);                                                                                       // 561\n  function onfinish() {                                                                                              // 562\n    debug('onfinish');                                                                                               // 563\n    dest.removeListener('close', onclose);                                                                           // 564\n    unpipe();                                                                                                        // 565\n  }                                                                                                                  // 566\n  dest.once('finish', onfinish);                                                                                     // 567\n                                                                                                                     // 568\n  function unpipe() {                                                                                                // 569\n    debug('unpipe');                                                                                                 // 570\n    src.unpipe(dest);                                                                                                // 571\n  }                                                                                                                  // 572\n                                                                                                                     // 573\n  // tell the dest that it's being piped to                                                                          // 574\n  dest.emit('pipe', src);                                                                                            // 575\n                                                                                                                     // 576\n  // start the flow if it hasn't been started already.                                                               // 577\n  if (!state.flowing) {                                                                                              // 578\n    debug('pipe resume');                                                                                            // 579\n    src.resume();                                                                                                    // 580\n  }                                                                                                                  // 581\n                                                                                                                     // 582\n  return dest;                                                                                                       // 583\n};                                                                                                                   // 584\n                                                                                                                     // 585\nfunction pipeOnDrain(src) {                                                                                          // 586\n  return function () {                                                                                               // 587\n    var state = src._readableState;                                                                                  // 588\n    debug('pipeOnDrain', state.awaitDrain);                                                                          // 589\n    if (state.awaitDrain) state.awaitDrain--;                                                                        // 590\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {                                                    // 591\n      state.flowing = true;                                                                                          // 592\n      flow(src);                                                                                                     // 593\n    }                                                                                                                // 594\n  };                                                                                                                 // 595\n}                                                                                                                    // 596\n                                                                                                                     // 597\nReadable.prototype.unpipe = function (dest) {                                                                        // 598\n  var state = this._readableState;                                                                                   // 599\n                                                                                                                     // 600\n  // if we're not piping anywhere, then do nothing.                                                                  // 601\n  if (state.pipesCount === 0) return this;                                                                           // 602\n                                                                                                                     // 603\n  // just one destination.  most common case.                                                                        // 604\n  if (state.pipesCount === 1) {                                                                                      // 605\n    // passed in one, but it's not the right one.                                                                    // 606\n    if (dest && dest !== state.pipes) return this;                                                                   // 607\n                                                                                                                     // 608\n    if (!dest) dest = state.pipes;                                                                                   // 609\n                                                                                                                     // 610\n    // got a match.                                                                                                  // 611\n    state.pipes = null;                                                                                              // 612\n    state.pipesCount = 0;                                                                                            // 613\n    state.flowing = false;                                                                                           // 614\n    if (dest) dest.emit('unpipe', this);                                                                             // 615\n    return this;                                                                                                     // 616\n  }                                                                                                                  // 617\n                                                                                                                     // 618\n  // slow case. multiple pipe destinations.                                                                          // 619\n                                                                                                                     // 620\n  if (!dest) {                                                                                                       // 621\n    // remove all.                                                                                                   // 622\n    var dests = state.pipes;                                                                                         // 623\n    var len = state.pipesCount;                                                                                      // 624\n    state.pipes = null;                                                                                              // 625\n    state.pipesCount = 0;                                                                                            // 626\n    state.flowing = false;                                                                                           // 627\n                                                                                                                     // 628\n    for (var _i = 0; _i < len; _i++) {                                                                               // 629\n      dests[_i].emit('unpipe', this);                                                                                // 630\n    }return this;                                                                                                    // 631\n  }                                                                                                                  // 632\n                                                                                                                     // 633\n  // try to find the right one.                                                                                      // 634\n  var i = indexOf(state.pipes, dest);                                                                                // 635\n  if (i === -1) return this;                                                                                         // 636\n                                                                                                                     // 637\n  state.pipes.splice(i, 1);                                                                                          // 638\n  state.pipesCount -= 1;                                                                                             // 639\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];                                                          // 640\n                                                                                                                     // 641\n  dest.emit('unpipe', this);                                                                                         // 642\n                                                                                                                     // 643\n  return this;                                                                                                       // 644\n};                                                                                                                   // 645\n                                                                                                                     // 646\n// set up data events if they are asked for                                                                          // 647\n// Ensure readable listeners eventually get something                                                                // 648\nReadable.prototype.on = function (ev, fn) {                                                                          // 649\n  var res = Stream.prototype.on.call(this, ev, fn);                                                                  // 650\n                                                                                                                     // 651\n  // If listening to data, and it has not explicitly been paused,                                                    // 652\n  // then call resume to start the flow of data on the next tick.                                                    // 653\n  if (ev === 'data' && false !== this._readableState.flowing) {                                                      // 654\n    this.resume();                                                                                                   // 655\n  }                                                                                                                  // 656\n                                                                                                                     // 657\n  if (ev === 'readable' && !this._readableState.endEmitted) {                                                        // 658\n    var state = this._readableState;                                                                                 // 659\n    if (!state.readableListening) {                                                                                  // 660\n      state.readableListening = true;                                                                                // 661\n      state.emittedReadable = false;                                                                                 // 662\n      state.needReadable = true;                                                                                     // 663\n      if (!state.reading) {                                                                                          // 664\n        processNextTick(nReadingNextTick, this);                                                                     // 665\n      } else if (state.length) {                                                                                     // 666\n        emitReadable(this, state);                                                                                   // 667\n      }                                                                                                              // 668\n    }                                                                                                                // 669\n  }                                                                                                                  // 670\n                                                                                                                     // 671\n  return res;                                                                                                        // 672\n};                                                                                                                   // 673\nReadable.prototype.addListener = Readable.prototype.on;                                                              // 674\n                                                                                                                     // 675\nfunction nReadingNextTick(self) {                                                                                    // 676\n  debug('readable nexttick read 0');                                                                                 // 677\n  self.read(0);                                                                                                      // 678\n}                                                                                                                    // 679\n                                                                                                                     // 680\n// pause() and resume() are remnants of the legacy readable stream API                                               // 681\n// If the user uses them, then switch into old mode.                                                                 // 682\nReadable.prototype.resume = function () {                                                                            // 683\n  var state = this._readableState;                                                                                   // 684\n  if (!state.flowing) {                                                                                              // 685\n    debug('resume');                                                                                                 // 686\n    state.flowing = true;                                                                                            // 687\n    resume(this, state);                                                                                             // 688\n  }                                                                                                                  // 689\n  return this;                                                                                                       // 690\n};                                                                                                                   // 691\n                                                                                                                     // 692\nfunction resume(stream, state) {                                                                                     // 693\n  if (!state.resumeScheduled) {                                                                                      // 694\n    state.resumeScheduled = true;                                                                                    // 695\n    processNextTick(resume_, stream, state);                                                                         // 696\n  }                                                                                                                  // 697\n}                                                                                                                    // 698\n                                                                                                                     // 699\nfunction resume_(stream, state) {                                                                                    // 700\n  if (!state.reading) {                                                                                              // 701\n    debug('resume read 0');                                                                                          // 702\n    stream.read(0);                                                                                                  // 703\n  }                                                                                                                  // 704\n                                                                                                                     // 705\n  state.resumeScheduled = false;                                                                                     // 706\n  stream.emit('resume');                                                                                             // 707\n  flow(stream);                                                                                                      // 708\n  if (state.flowing && !state.reading) stream.read(0);                                                               // 709\n}                                                                                                                    // 710\n                                                                                                                     // 711\nReadable.prototype.pause = function () {                                                                             // 712\n  debug('call pause flowing=%j', this._readableState.flowing);                                                       // 713\n  if (false !== this._readableState.flowing) {                                                                       // 714\n    debug('pause');                                                                                                  // 715\n    this._readableState.flowing = false;                                                                             // 716\n    this.emit('pause');                                                                                              // 717\n  }                                                                                                                  // 718\n  return this;                                                                                                       // 719\n};                                                                                                                   // 720\n                                                                                                                     // 721\nfunction flow(stream) {                                                                                              // 722\n  var state = stream._readableState;                                                                                 // 723\n  debug('flow', state.flowing);                                                                                      // 724\n  if (state.flowing) {                                                                                               // 725\n    do {                                                                                                             // 726\n      var chunk = stream.read();                                                                                     // 727\n    } while (null !== chunk && state.flowing);                                                                       // 728\n  }                                                                                                                  // 729\n}                                                                                                                    // 730\n                                                                                                                     // 731\n// wrap an old-style stream as the async data source.                                                                // 732\n// This is *not* part of the readable stream interface.                                                              // 733\n// It is an ugly unfortunate mess of history.                                                                        // 734\nReadable.prototype.wrap = function (stream) {                                                                        // 735\n  var state = this._readableState;                                                                                   // 736\n  var paused = false;                                                                                                // 737\n                                                                                                                     // 738\n  var self = this;                                                                                                   // 739\n  stream.on('end', function () {                                                                                     // 740\n    debug('wrapped end');                                                                                            // 741\n    if (state.decoder && !state.ended) {                                                                             // 742\n      var chunk = state.decoder.end();                                                                               // 743\n      if (chunk && chunk.length) self.push(chunk);                                                                   // 744\n    }                                                                                                                // 745\n                                                                                                                     // 746\n    self.push(null);                                                                                                 // 747\n  });                                                                                                                // 748\n                                                                                                                     // 749\n  stream.on('data', function (chunk) {                                                                               // 750\n    debug('wrapped data');                                                                                           // 751\n    if (state.decoder) chunk = state.decoder.write(chunk);                                                           // 752\n                                                                                                                     // 753\n    // don't skip over falsy values in objectMode                                                                    // 754\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n                                                                                                                     // 756\n    var ret = self.push(chunk);                                                                                      // 757\n    if (!ret) {                                                                                                      // 758\n      paused = true;                                                                                                 // 759\n      stream.pause();                                                                                                // 760\n    }                                                                                                                // 761\n  });                                                                                                                // 762\n                                                                                                                     // 763\n  // proxy all the other methods.                                                                                    // 764\n  // important when wrapping filters and duplexes.                                                                   // 765\n  for (var i in stream) {                                                                                            // 766\n    if (this[i] === undefined && typeof stream[i] === 'function') {                                                  // 767\n      this[i] = function (method) {                                                                                  // 768\n        return function () {                                                                                         // 769\n          return stream[method].apply(stream, arguments);                                                            // 770\n        };                                                                                                           // 771\n      }(i);                                                                                                          // 772\n    }                                                                                                                // 773\n  }                                                                                                                  // 774\n                                                                                                                     // 775\n  // proxy certain important events.                                                                                 // 776\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];                                                     // 777\n  forEach(events, function (ev) {                                                                                    // 778\n    stream.on(ev, self.emit.bind(self, ev));                                                                         // 779\n  });                                                                                                                // 780\n                                                                                                                     // 781\n  // when we try to consume some more bytes, simply unpause the                                                      // 782\n  // underlying stream.                                                                                              // 783\n  self._read = function (n) {                                                                                        // 784\n    debug('wrapped _read', n);                                                                                       // 785\n    if (paused) {                                                                                                    // 786\n      paused = false;                                                                                                // 787\n      stream.resume();                                                                                               // 788\n    }                                                                                                                // 789\n  };                                                                                                                 // 790\n                                                                                                                     // 791\n  return self;                                                                                                       // 792\n};                                                                                                                   // 793\n                                                                                                                     // 794\n// exposed for testing purposes only.                                                                                // 795\nReadable._fromList = fromList;                                                                                       // 796\n                                                                                                                     // 797\n// Pluck off n bytes from an array of buffers.                                                                       // 798\n// Length is the combined lengths of all the buffers in the list.                                                    // 799\nfunction fromList(n, state) {                                                                                        // 800\n  var list = state.buffer;                                                                                           // 801\n  var length = state.length;                                                                                         // 802\n  var stringMode = !!state.decoder;                                                                                  // 803\n  var objectMode = !!state.objectMode;                                                                               // 804\n  var ret;                                                                                                           // 805\n                                                                                                                     // 806\n  // nothing in the list, definitely empty.                                                                          // 807\n  if (list.length === 0) return null;                                                                                // 808\n                                                                                                                     // 809\n  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {                 // 810\n    // read it all, truncate the array.                                                                              // 811\n    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);\n    list.length = 0;                                                                                                 // 813\n  } else {                                                                                                           // 814\n    // read just some of it.                                                                                         // 815\n    if (n < list[0].length) {                                                                                        // 816\n      // just take a part of the first list item.                                                                    // 817\n      // slice is the same for buffers and strings.                                                                  // 818\n      var buf = list[0];                                                                                             // 819\n      ret = buf.slice(0, n);                                                                                         // 820\n      list[0] = buf.slice(n);                                                                                        // 821\n    } else if (n === list[0].length) {                                                                               // 822\n      // first list is a perfect match                                                                               // 823\n      ret = list.shift();                                                                                            // 824\n    } else {                                                                                                         // 825\n      // complex case.                                                                                               // 826\n      // we have enough to cover it, but it spans past the first buffer.                                             // 827\n      if (stringMode) ret = '';else ret = new Buffer(n);                                                             // 828\n                                                                                                                     // 829\n      var c = 0;                                                                                                     // 830\n      for (var i = 0, l = list.length; i < l && c < n; i++) {                                                        // 831\n        var buf = list[0];                                                                                           // 832\n        var cpy = Math.min(n - c, buf.length);                                                                       // 833\n                                                                                                                     // 834\n        if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);                                      // 835\n                                                                                                                     // 836\n        if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();                                            // 837\n                                                                                                                     // 838\n        c += cpy;                                                                                                    // 839\n      }                                                                                                              // 840\n    }                                                                                                                // 841\n  }                                                                                                                  // 842\n                                                                                                                     // 843\n  return ret;                                                                                                        // 844\n}                                                                                                                    // 845\n                                                                                                                     // 846\nfunction endReadable(stream) {                                                                                       // 847\n  var state = stream._readableState;                                                                                 // 848\n                                                                                                                     // 849\n  // If we get here before consuming all the bytes, then that is a                                                   // 850\n  // bug in node.  Should never happen.                                                                              // 851\n  if (state.length > 0) throw new Error('endReadable called on non-empty stream');                                   // 852\n                                                                                                                     // 853\n  if (!state.endEmitted) {                                                                                           // 854\n    state.ended = true;                                                                                              // 855\n    processNextTick(endReadableNT, state, stream);                                                                   // 856\n  }                                                                                                                  // 857\n}                                                                                                                    // 858\n                                                                                                                     // 859\nfunction endReadableNT(state, stream) {                                                                              // 860\n  // Check that we didn't get one last unshift.                                                                      // 861\n  if (!state.endEmitted && state.length === 0) {                                                                     // 862\n    state.endEmitted = true;                                                                                         // 863\n    stream.readable = false;                                                                                         // 864\n    stream.emit('end');                                                                                              // 865\n  }                                                                                                                  // 866\n}                                                                                                                    // 867\n                                                                                                                     // 868\nfunction forEach(xs, f) {                                                                                            // 869\n  for (var i = 0, l = xs.length; i < l; i++) {                                                                       // 870\n    f(xs[i], i);                                                                                                     // 871\n  }                                                                                                                  // 872\n}                                                                                                                    // 873\n                                                                                                                     // 874\nfunction indexOf(xs, x) {                                                                                            // 875\n  for (var i = 0, l = xs.length; i < l; i++) {                                                                       // 876\n    if (xs[i] === x) return i;                                                                                       // 877\n  }                                                                                                                  // 878\n  return -1;                                                                                                         // 879\n}                                                                                                                    // 880\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_duplex.js\":[\"process-nextick-args\",\"core-util-is\",\"inherits\",\"./_stream_readable\",\"./_stream_writable\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/lib/_stream_duplex.js                                 //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// a duplex stream is just a stream that is both readable and writable.                                              // 1\n// Since JS doesn't have multiple prototypal inheritance, this class                                                 // 2\n// prototypally inherits from Readable, and then parasitically from                                                  // 3\n// Writable.                                                                                                         // 4\n                                                                                                                     // 5\n'use strict';                                                                                                        // 6\n                                                                                                                     // 7\n/*<replacement>*/                                                                                                    // 8\n                                                                                                                     // 9\nvar objectKeys = Object.keys || function (obj) {                                                                     // 10\n  var keys = [];                                                                                                     // 11\n  for (var key in obj) {                                                                                             // 12\n    keys.push(key);                                                                                                  // 13\n  }return keys;                                                                                                      // 14\n};                                                                                                                   // 15\n/*</replacement>*/                                                                                                   // 16\n                                                                                                                     // 17\nmodule.exports = Duplex;                                                                                             // 18\n                                                                                                                     // 19\n/*<replacement>*/                                                                                                    // 20\nvar processNextTick = require('process-nextick-args');                                                               // 21\n/*</replacement>*/                                                                                                   // 22\n                                                                                                                     // 23\n/*<replacement>*/                                                                                                    // 24\nvar util = require('core-util-is');                                                                                  // 25\nutil.inherits = require('inherits');                                                                                 // 26\n/*</replacement>*/                                                                                                   // 27\n                                                                                                                     // 28\nvar Readable = require('./_stream_readable');                                                                        // 29\nvar Writable = require('./_stream_writable');                                                                        // 30\n                                                                                                                     // 31\nutil.inherits(Duplex, Readable);                                                                                     // 32\n                                                                                                                     // 33\nvar keys = objectKeys(Writable.prototype);                                                                           // 34\nfor (var v = 0; v < keys.length; v++) {                                                                              // 35\n  var method = keys[v];                                                                                              // 36\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];                              // 37\n}                                                                                                                    // 38\n                                                                                                                     // 39\nfunction Duplex(options) {                                                                                           // 40\n  if (!(this instanceof Duplex)) return new Duplex(options);                                                         // 41\n                                                                                                                     // 42\n  Readable.call(this, options);                                                                                      // 43\n  Writable.call(this, options);                                                                                      // 44\n                                                                                                                     // 45\n  if (options && options.readable === false) this.readable = false;                                                  // 46\n                                                                                                                     // 47\n  if (options && options.writable === false) this.writable = false;                                                  // 48\n                                                                                                                     // 49\n  this.allowHalfOpen = true;                                                                                         // 50\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;                                        // 51\n                                                                                                                     // 52\n  this.once('end', onend);                                                                                           // 53\n}                                                                                                                    // 54\n                                                                                                                     // 55\n// the no-half-open enforcer                                                                                         // 56\nfunction onend() {                                                                                                   // 57\n  // if we allow half-open state, or if the writable side ended,                                                     // 58\n  // then we're ok.                                                                                                  // 59\n  if (this.allowHalfOpen || this._writableState.ended) return;                                                       // 60\n                                                                                                                     // 61\n  // no more data can be written.                                                                                    // 62\n  // But allow more writes to happen in this tick.                                                                   // 63\n  processNextTick(onEndNT, this);                                                                                    // 64\n}                                                                                                                    // 65\n                                                                                                                     // 66\nfunction onEndNT(self) {                                                                                             // 67\n  self.end();                                                                                                        // 68\n}                                                                                                                    // 69\n                                                                                                                     // 70\nfunction forEach(xs, f) {                                                                                            // 71\n  for (var i = 0, l = xs.length; i < l; i++) {                                                                       // 72\n    f(xs[i], i);                                                                                                     // 73\n  }                                                                                                                  // 74\n}                                                                                                                    // 75\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_writable.js\":[\"process-nextick-args\",\"buffer\",\"core-util-is\",\"inherits\",\"util-deprecate\",\"events\",\"./_stream_duplex\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/lib/_stream_writable.js                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// A bit simpler than readable streams.                                                                              // 1\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all                                             // 2\n// the drain event emission and buffering.                                                                           // 3\n                                                                                                                     // 4\n'use strict';                                                                                                        // 5\n                                                                                                                     // 6\nmodule.exports = Writable;                                                                                           // 7\n                                                                                                                     // 8\n/*<replacement>*/                                                                                                    // 9\nvar processNextTick = require('process-nextick-args');                                                               // 10\n/*</replacement>*/                                                                                                   // 11\n                                                                                                                     // 12\n/*<replacement>*/                                                                                                    // 13\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/                                                                                                   // 15\n                                                                                                                     // 16\n/*<replacement>*/                                                                                                    // 17\nvar Buffer = require('buffer').Buffer;                                                                               // 18\n/*</replacement>*/                                                                                                   // 19\n                                                                                                                     // 20\nWritable.WritableState = WritableState;                                                                              // 21\n                                                                                                                     // 22\n/*<replacement>*/                                                                                                    // 23\nvar util = require('core-util-is');                                                                                  // 24\nutil.inherits = require('inherits');                                                                                 // 25\n/*</replacement>*/                                                                                                   // 26\n                                                                                                                     // 27\n/*<replacement>*/                                                                                                    // 28\nvar internalUtil = {                                                                                                 // 29\n  deprecate: require('util-deprecate')                                                                               // 30\n};                                                                                                                   // 31\n/*</replacement>*/                                                                                                   // 32\n                                                                                                                     // 33\n/*<replacement>*/                                                                                                    // 34\nvar Stream;                                                                                                          // 35\n(function () {                                                                                                       // 36\n  try {                                                                                                              // 37\n    Stream = require('st' + 'ream');                                                                                 // 38\n  } catch (_) {} finally {                                                                                           // 39\n    if (!Stream) Stream = require('events').EventEmitter;                                                            // 40\n  }                                                                                                                  // 41\n})();                                                                                                                // 42\n/*</replacement>*/                                                                                                   // 43\n                                                                                                                     // 44\nvar Buffer = require('buffer').Buffer;                                                                               // 45\n                                                                                                                     // 46\nutil.inherits(Writable, Stream);                                                                                     // 47\n                                                                                                                     // 48\nfunction nop() {}                                                                                                    // 49\n                                                                                                                     // 50\nfunction WriteReq(chunk, encoding, cb) {                                                                             // 51\n  this.chunk = chunk;                                                                                                // 52\n  this.encoding = encoding;                                                                                          // 53\n  this.callback = cb;                                                                                                // 54\n  this.next = null;                                                                                                  // 55\n}                                                                                                                    // 56\n                                                                                                                     // 57\nvar Duplex;                                                                                                          // 58\nfunction WritableState(options, stream) {                                                                            // 59\n  Duplex = Duplex || require('./_stream_duplex');                                                                    // 60\n                                                                                                                     // 61\n  options = options || {};                                                                                           // 62\n                                                                                                                     // 63\n  // object stream flag to indicate whether or not this stream                                                       // 64\n  // contains buffers or objects.                                                                                    // 65\n  this.objectMode = !!options.objectMode;                                                                            // 66\n                                                                                                                     // 67\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;                   // 68\n                                                                                                                     // 69\n  // the point at which write() starts returning false                                                               // 70\n  // Note: 0 is a valid value, means that we always return false if                                                  // 71\n  // the entire buffer is not flushed immediately on write()                                                         // 72\n  var hwm = options.highWaterMark;                                                                                   // 73\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;                                                                 // 74\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;                                                          // 75\n                                                                                                                     // 76\n  // cast to ints.                                                                                                   // 77\n  this.highWaterMark = ~ ~this.highWaterMark;                                                                        // 78\n                                                                                                                     // 79\n  this.needDrain = false;                                                                                            // 80\n  // at the start of calling end()                                                                                   // 81\n  this.ending = false;                                                                                               // 82\n  // when end() has been called, and returned                                                                        // 83\n  this.ended = false;                                                                                                // 84\n  // when 'finish' is emitted                                                                                        // 85\n  this.finished = false;                                                                                             // 86\n                                                                                                                     // 87\n  // should we decode strings into buffers before passing to _write?                                                 // 88\n  // this is here so that some node-core streams can optimize string                                                 // 89\n  // handling at a lower level.                                                                                      // 90\n  var noDecode = options.decodeStrings === false;                                                                    // 91\n  this.decodeStrings = !noDecode;                                                                                    // 92\n                                                                                                                     // 93\n  // Crypto is kind of old and crusty.  Historically, its default string                                             // 94\n  // encoding is 'binary' so we have to make this configurable.                                                      // 95\n  // Everything else in the universe uses 'utf8', though.                                                            // 96\n  this.defaultEncoding = options.defaultEncoding || 'utf8';                                                          // 97\n                                                                                                                     // 98\n  // not an actual buffer we keep track of, but a measurement                                                        // 99\n  // of how much we're waiting to get pushed to some underlying                                                      // 100\n  // socket or file.                                                                                                 // 101\n  this.length = 0;                                                                                                   // 102\n                                                                                                                     // 103\n  // a flag to see when we're in the middle of a write.                                                              // 104\n  this.writing = false;                                                                                              // 105\n                                                                                                                     // 106\n  // when true all writes will be buffered until .uncork() call                                                      // 107\n  this.corked = 0;                                                                                                   // 108\n                                                                                                                     // 109\n  // a flag to be able to tell if the onwrite cb is called immediately,                                              // 110\n  // or on a later tick.  We set this to true at first, because any                                                  // 111\n  // actions that shouldn't happen until \"later\" should generally also                                               // 112\n  // not happen before the first write call.                                                                         // 113\n  this.sync = true;                                                                                                  // 114\n                                                                                                                     // 115\n  // a flag to know if we're processing previously buffered items, which                                             // 116\n  // may call the _write() callback in the same tick, so that we don't                                               // 117\n  // end up in an overlapped onwrite situation.                                                                      // 118\n  this.bufferProcessing = false;                                                                                     // 119\n                                                                                                                     // 120\n  // the callback that's passed to _write(chunk,cb)                                                                  // 121\n  this.onwrite = function (er) {                                                                                     // 122\n    onwrite(stream, er);                                                                                             // 123\n  };                                                                                                                 // 124\n                                                                                                                     // 125\n  // the callback that the user supplies to write(chunk,encoding,cb)                                                 // 126\n  this.writecb = null;                                                                                               // 127\n                                                                                                                     // 128\n  // the amount that is being written when _write is called.                                                         // 129\n  this.writelen = 0;                                                                                                 // 130\n                                                                                                                     // 131\n  this.bufferedRequest = null;                                                                                       // 132\n  this.lastBufferedRequest = null;                                                                                   // 133\n                                                                                                                     // 134\n  // number of pending user-supplied write callbacks                                                                 // 135\n  // this must be 0 before 'finish' can be emitted                                                                   // 136\n  this.pendingcb = 0;                                                                                                // 137\n                                                                                                                     // 138\n  // emit prefinish if the only thing we're waiting for is _write cbs                                                // 139\n  // This is relevant for synchronous Transform streams                                                              // 140\n  this.prefinished = false;                                                                                          // 141\n                                                                                                                     // 142\n  // True if the error was already emitted and should not be thrown again                                            // 143\n  this.errorEmitted = false;                                                                                         // 144\n                                                                                                                     // 145\n  // count buffered requests                                                                                         // 146\n  this.bufferedRequestCount = 0;                                                                                     // 147\n                                                                                                                     // 148\n  // create the two objects needed to store the corked requests                                                      // 149\n  // they are not a linked list, as no new elements are inserted in there                                            // 150\n  this.corkedRequestsFree = new CorkedRequest(this);                                                                 // 151\n  this.corkedRequestsFree.next = new CorkedRequest(this);                                                            // 152\n}                                                                                                                    // 153\n                                                                                                                     // 154\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {                                              // 155\n  var current = this.bufferedRequest;                                                                                // 156\n  var out = [];                                                                                                      // 157\n  while (current) {                                                                                                  // 158\n    out.push(current);                                                                                               // 159\n    current = current.next;                                                                                          // 160\n  }                                                                                                                  // 161\n  return out;                                                                                                        // 162\n};                                                                                                                   // 163\n                                                                                                                     // 164\n(function () {                                                                                                       // 165\n  try {                                                                                                              // 166\n    Object.defineProperty(WritableState.prototype, 'buffer', {                                                       // 167\n      get: internalUtil.deprecate(function () {                                                                      // 168\n        return this.getBuffer();                                                                                     // 169\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')                          // 170\n    });                                                                                                              // 171\n  } catch (_) {}                                                                                                     // 172\n})();                                                                                                                // 173\n                                                                                                                     // 174\nvar Duplex;                                                                                                          // 175\nfunction Writable(options) {                                                                                         // 176\n  Duplex = Duplex || require('./_stream_duplex');                                                                    // 177\n                                                                                                                     // 178\n  // Writable ctor is applied to Duplexes, though they're not                                                        // 179\n  // instanceof Writable, they're instanceof Readable.                                                               // 180\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);                        // 181\n                                                                                                                     // 182\n  this._writableState = new WritableState(options, this);                                                            // 183\n                                                                                                                     // 184\n  // legacy.                                                                                                         // 185\n  this.writable = true;                                                                                              // 186\n                                                                                                                     // 187\n  if (options) {                                                                                                     // 188\n    if (typeof options.write === 'function') this._write = options.write;                                            // 189\n                                                                                                                     // 190\n    if (typeof options.writev === 'function') this._writev = options.writev;                                         // 191\n  }                                                                                                                  // 192\n                                                                                                                     // 193\n  Stream.call(this);                                                                                                 // 194\n}                                                                                                                    // 195\n                                                                                                                     // 196\n// Otherwise people can pipe Writable streams, which is just wrong.                                                  // 197\nWritable.prototype.pipe = function () {                                                                              // 198\n  this.emit('error', new Error('Cannot pipe. Not readable.'));                                                       // 199\n};                                                                                                                   // 200\n                                                                                                                     // 201\nfunction writeAfterEnd(stream, cb) {                                                                                 // 202\n  var er = new Error('write after end');                                                                             // 203\n  // TODO: defer error events consistently everywhere, not just the cb                                               // 204\n  stream.emit('error', er);                                                                                          // 205\n  processNextTick(cb, er);                                                                                           // 206\n}                                                                                                                    // 207\n                                                                                                                     // 208\n// If we get something that is not a buffer, string, null, or undefined,                                             // 209\n// and we're not in objectMode, then that's an error.                                                                // 210\n// Otherwise stream chunks are all considered to be of length=1, and the                                             // 211\n// watermarks determine how many objects to keep in the buffer, rather than                                          // 212\n// how many bytes or characters.                                                                                     // 213\nfunction validChunk(stream, state, chunk, cb) {                                                                      // 214\n  var valid = true;                                                                                                  // 215\n                                                                                                                     // 216\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');                                                       // 218\n    stream.emit('error', er);                                                                                        // 219\n    processNextTick(cb, er);                                                                                         // 220\n    valid = false;                                                                                                   // 221\n  }                                                                                                                  // 222\n  return valid;                                                                                                      // 223\n}                                                                                                                    // 224\n                                                                                                                     // 225\nWritable.prototype.write = function (chunk, encoding, cb) {                                                          // 226\n  var state = this._writableState;                                                                                   // 227\n  var ret = false;                                                                                                   // 228\n                                                                                                                     // 229\n  if (typeof encoding === 'function') {                                                                              // 230\n    cb = encoding;                                                                                                   // 231\n    encoding = null;                                                                                                 // 232\n  }                                                                                                                  // 233\n                                                                                                                     // 234\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;              // 235\n                                                                                                                     // 236\n  if (typeof cb !== 'function') cb = nop;                                                                            // 237\n                                                                                                                     // 238\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {                            // 239\n    state.pendingcb++;                                                                                               // 240\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);                                                           // 241\n  }                                                                                                                  // 242\n                                                                                                                     // 243\n  return ret;                                                                                                        // 244\n};                                                                                                                   // 245\n                                                                                                                     // 246\nWritable.prototype.cork = function () {                                                                              // 247\n  var state = this._writableState;                                                                                   // 248\n                                                                                                                     // 249\n  state.corked++;                                                                                                    // 250\n};                                                                                                                   // 251\n                                                                                                                     // 252\nWritable.prototype.uncork = function () {                                                                            // 253\n  var state = this._writableState;                                                                                   // 254\n                                                                                                                     // 255\n  if (state.corked) {                                                                                                // 256\n    state.corked--;                                                                                                  // 257\n                                                                                                                     // 258\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }                                                                                                                  // 260\n};                                                                                                                   // 261\n                                                                                                                     // 262\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {                                      // 263\n  // node::ParseEncoding() requires lower case.                                                                      // 264\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();                                               // 265\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;                                                                    // 267\n};                                                                                                                   // 268\n                                                                                                                     // 269\nfunction decodeChunk(state, chunk, encoding) {                                                                       // 270\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {                             // 271\n    chunk = new Buffer(chunk, encoding);                                                                             // 272\n  }                                                                                                                  // 273\n  return chunk;                                                                                                      // 274\n}                                                                                                                    // 275\n                                                                                                                     // 276\n// if we're already writing something, then just put this                                                            // 277\n// in the queue, and wait our turn.  Otherwise, call _write                                                          // 278\n// If we return false, then we need a drain event, so set that flag.                                                 // 279\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {                                                         // 280\n  chunk = decodeChunk(state, chunk, encoding);                                                                       // 281\n                                                                                                                     // 282\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';                                                                   // 283\n  var len = state.objectMode ? 1 : chunk.length;                                                                     // 284\n                                                                                                                     // 285\n  state.length += len;                                                                                               // 286\n                                                                                                                     // 287\n  var ret = state.length < state.highWaterMark;                                                                      // 288\n  // we must ensure that previous needDrain will not be reset to false.                                              // 289\n  if (!ret) state.needDrain = true;                                                                                  // 290\n                                                                                                                     // 291\n  if (state.writing || state.corked) {                                                                               // 292\n    var last = state.lastBufferedRequest;                                                                            // 293\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);                                                   // 294\n    if (last) {                                                                                                      // 295\n      last.next = state.lastBufferedRequest;                                                                         // 296\n    } else {                                                                                                         // 297\n      state.bufferedRequest = state.lastBufferedRequest;                                                             // 298\n    }                                                                                                                // 299\n    state.bufferedRequestCount += 1;                                                                                 // 300\n  } else {                                                                                                           // 301\n    doWrite(stream, state, false, len, chunk, encoding, cb);                                                         // 302\n  }                                                                                                                  // 303\n                                                                                                                     // 304\n  return ret;                                                                                                        // 305\n}                                                                                                                    // 306\n                                                                                                                     // 307\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {                                                  // 308\n  state.writelen = len;                                                                                              // 309\n  state.writecb = cb;                                                                                                // 310\n  state.writing = true;                                                                                              // 311\n  state.sync = true;                                                                                                 // 312\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);               // 313\n  state.sync = false;                                                                                                // 314\n}                                                                                                                    // 315\n                                                                                                                     // 316\nfunction onwriteError(stream, state, sync, er, cb) {                                                                 // 317\n  --state.pendingcb;                                                                                                 // 318\n  if (sync) processNextTick(cb, er);else cb(er);                                                                     // 319\n                                                                                                                     // 320\n  stream._writableState.errorEmitted = true;                                                                         // 321\n  stream.emit('error', er);                                                                                          // 322\n}                                                                                                                    // 323\n                                                                                                                     // 324\nfunction onwriteStateUpdate(state) {                                                                                 // 325\n  state.writing = false;                                                                                             // 326\n  state.writecb = null;                                                                                              // 327\n  state.length -= state.writelen;                                                                                    // 328\n  state.writelen = 0;                                                                                                // 329\n}                                                                                                                    // 330\n                                                                                                                     // 331\nfunction onwrite(stream, er) {                                                                                       // 332\n  var state = stream._writableState;                                                                                 // 333\n  var sync = state.sync;                                                                                             // 334\n  var cb = state.writecb;                                                                                            // 335\n                                                                                                                     // 336\n  onwriteStateUpdate(state);                                                                                         // 337\n                                                                                                                     // 338\n  if (er) onwriteError(stream, state, sync, er, cb);else {                                                           // 339\n    // Check if we're actually ready to finish, but don't emit yet                                                   // 340\n    var finished = needFinish(state);                                                                                // 341\n                                                                                                                     // 342\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {                            // 343\n      clearBuffer(stream, state);                                                                                    // 344\n    }                                                                                                                // 345\n                                                                                                                     // 346\n    if (sync) {                                                                                                      // 347\n      /*<replacement>*/                                                                                              // 348\n      asyncWrite(afterWrite, stream, state, finished, cb);                                                           // 349\n      /*</replacement>*/                                                                                             // 350\n    } else {                                                                                                         // 351\n        afterWrite(stream, state, finished, cb);                                                                     // 352\n      }                                                                                                              // 353\n  }                                                                                                                  // 354\n}                                                                                                                    // 355\n                                                                                                                     // 356\nfunction afterWrite(stream, state, finished, cb) {                                                                   // 357\n  if (!finished) onwriteDrain(stream, state);                                                                        // 358\n  state.pendingcb--;                                                                                                 // 359\n  cb();                                                                                                              // 360\n  finishMaybe(stream, state);                                                                                        // 361\n}                                                                                                                    // 362\n                                                                                                                     // 363\n// Must force callback to be called on nextTick, so that we don't                                                    // 364\n// emit 'drain' before the write() consumer gets the 'false' return                                                  // 365\n// value, and has a chance to attach a 'drain' listener.                                                             // 366\nfunction onwriteDrain(stream, state) {                                                                               // 367\n  if (state.length === 0 && state.needDrain) {                                                                       // 368\n    state.needDrain = false;                                                                                         // 369\n    stream.emit('drain');                                                                                            // 370\n  }                                                                                                                  // 371\n}                                                                                                                    // 372\n                                                                                                                     // 373\n// if there's something in the buffer waiting, then process it                                                       // 374\nfunction clearBuffer(stream, state) {                                                                                // 375\n  state.bufferProcessing = true;                                                                                     // 376\n  var entry = state.bufferedRequest;                                                                                 // 377\n                                                                                                                     // 378\n  if (stream._writev && entry && entry.next) {                                                                       // 379\n    // Fast case, write everything using _writev()                                                                   // 380\n    var l = state.bufferedRequestCount;                                                                              // 381\n    var buffer = new Array(l);                                                                                       // 382\n    var holder = state.corkedRequestsFree;                                                                           // 383\n    holder.entry = entry;                                                                                            // 384\n                                                                                                                     // 385\n    var count = 0;                                                                                                   // 386\n    while (entry) {                                                                                                  // 387\n      buffer[count] = entry;                                                                                         // 388\n      entry = entry.next;                                                                                            // 389\n      count += 1;                                                                                                    // 390\n    }                                                                                                                // 391\n                                                                                                                     // 392\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);                                           // 393\n                                                                                                                     // 394\n    // doWrite is always async, defer these to save a bit of time                                                    // 395\n    // as the hot path ends with doWrite                                                                             // 396\n    state.pendingcb++;                                                                                               // 397\n    state.lastBufferedRequest = null;                                                                                // 398\n    state.corkedRequestsFree = holder.next;                                                                          // 399\n    holder.next = null;                                                                                              // 400\n  } else {                                                                                                           // 401\n    // Slow case, write chunks one-by-one                                                                            // 402\n    while (entry) {                                                                                                  // 403\n      var chunk = entry.chunk;                                                                                       // 404\n      var encoding = entry.encoding;                                                                                 // 405\n      var cb = entry.callback;                                                                                       // 406\n      var len = state.objectMode ? 1 : chunk.length;                                                                 // 407\n                                                                                                                     // 408\n      doWrite(stream, state, false, len, chunk, encoding, cb);                                                       // 409\n      entry = entry.next;                                                                                            // 410\n      // if we didn't call the onwrite immediately, then                                                             // 411\n      // it means that we need to wait until it does.                                                                // 412\n      // also, that means that the chunk and cb are currently                                                        // 413\n      // being processed, so move the buffer counter past them.                                                      // 414\n      if (state.writing) {                                                                                           // 415\n        break;                                                                                                       // 416\n      }                                                                                                              // 417\n    }                                                                                                                // 418\n                                                                                                                     // 419\n    if (entry === null) state.lastBufferedRequest = null;                                                            // 420\n  }                                                                                                                  // 421\n                                                                                                                     // 422\n  state.bufferedRequestCount = 0;                                                                                    // 423\n  state.bufferedRequest = entry;                                                                                     // 424\n  state.bufferProcessing = false;                                                                                    // 425\n}                                                                                                                    // 426\n                                                                                                                     // 427\nWritable.prototype._write = function (chunk, encoding, cb) {                                                         // 428\n  cb(new Error('not implemented'));                                                                                  // 429\n};                                                                                                                   // 430\n                                                                                                                     // 431\nWritable.prototype._writev = null;                                                                                   // 432\n                                                                                                                     // 433\nWritable.prototype.end = function (chunk, encoding, cb) {                                                            // 434\n  var state = this._writableState;                                                                                   // 435\n                                                                                                                     // 436\n  if (typeof chunk === 'function') {                                                                                 // 437\n    cb = chunk;                                                                                                      // 438\n    chunk = null;                                                                                                    // 439\n    encoding = null;                                                                                                 // 440\n  } else if (typeof encoding === 'function') {                                                                       // 441\n    cb = encoding;                                                                                                   // 442\n    encoding = null;                                                                                                 // 443\n  }                                                                                                                  // 444\n                                                                                                                     // 445\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);                                            // 446\n                                                                                                                     // 447\n  // .end() fully uncorks                                                                                            // 448\n  if (state.corked) {                                                                                                // 449\n    state.corked = 1;                                                                                                // 450\n    this.uncork();                                                                                                   // 451\n  }                                                                                                                  // 452\n                                                                                                                     // 453\n  // ignore unnecessary end() calls.                                                                                 // 454\n  if (!state.ending && !state.finished) endWritable(this, state, cb);                                                // 455\n};                                                                                                                   // 456\n                                                                                                                     // 457\nfunction needFinish(state) {                                                                                         // 458\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;  // 459\n}                                                                                                                    // 460\n                                                                                                                     // 461\nfunction prefinish(stream, state) {                                                                                  // 462\n  if (!state.prefinished) {                                                                                          // 463\n    state.prefinished = true;                                                                                        // 464\n    stream.emit('prefinish');                                                                                        // 465\n  }                                                                                                                  // 466\n}                                                                                                                    // 467\n                                                                                                                     // 468\nfunction finishMaybe(stream, state) {                                                                                // 469\n  var need = needFinish(state);                                                                                      // 470\n  if (need) {                                                                                                        // 471\n    if (state.pendingcb === 0) {                                                                                     // 472\n      prefinish(stream, state);                                                                                      // 473\n      state.finished = true;                                                                                         // 474\n      stream.emit('finish');                                                                                         // 475\n    } else {                                                                                                         // 476\n      prefinish(stream, state);                                                                                      // 477\n    }                                                                                                                // 478\n  }                                                                                                                  // 479\n  return need;                                                                                                       // 480\n}                                                                                                                    // 481\n                                                                                                                     // 482\nfunction endWritable(stream, state, cb) {                                                                            // 483\n  state.ending = true;                                                                                               // 484\n  finishMaybe(stream, state);                                                                                        // 485\n  if (cb) {                                                                                                          // 486\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);                                          // 487\n  }                                                                                                                  // 488\n  state.ended = true;                                                                                                // 489\n  stream.writable = false;                                                                                           // 490\n}                                                                                                                    // 491\n                                                                                                                     // 492\n// It seems a linked list but it is not                                                                              // 493\n// there will be only 2 of these for each stream                                                                     // 494\nfunction CorkedRequest(state) {                                                                                      // 495\n  var _this = this;                                                                                                  // 496\n                                                                                                                     // 497\n  this.next = null;                                                                                                  // 498\n  this.entry = null;                                                                                                 // 499\n                                                                                                                     // 500\n  this.finish = function (err) {                                                                                     // 501\n    var entry = _this.entry;                                                                                         // 502\n    _this.entry = null;                                                                                              // 503\n    while (entry) {                                                                                                  // 504\n      var cb = entry.callback;                                                                                       // 505\n      state.pendingcb--;                                                                                             // 506\n      cb(err);                                                                                                       // 507\n      entry = entry.next;                                                                                            // 508\n    }                                                                                                                // 509\n    if (state.corkedRequestsFree) {                                                                                  // 510\n      state.corkedRequestsFree.next = _this;                                                                         // 511\n    } else {                                                                                                         // 512\n      state.corkedRequestsFree = _this;                                                                              // 513\n    }                                                                                                                // 514\n  };                                                                                                                 // 515\n}                                                                                                                    // 516\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_transform.js\":[\"./_stream_duplex\",\"core-util-is\",\"inherits\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/lib/_stream_transform.js                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// a transform stream is a readable/writable stream where you do                                                     // 1\n// something with the data.  Sometimes it's called a \"filter\",                                                       // 2\n// but that's not a great name for it, since that implies a thing where                                              // 3\n// some bits pass through, and others are simply ignored.  (That would                                               // 4\n// be a valid example of a transform, of course.)                                                                    // 5\n//                                                                                                                   // 6\n// While the output is causally related to the input, it's not a                                                     // 7\n// necessarily symmetric or synchronous transformation.  For example,                                                // 8\n// a zlib stream might take multiple plain-text writes(), and then                                                   // 9\n// emit a single compressed chunk some time in the future.                                                           // 10\n//                                                                                                                   // 11\n// Here's how this works:                                                                                            // 12\n//                                                                                                                   // 13\n// The Transform stream has all the aspects of the readable and writable                                             // 14\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)                                               // 15\n// internally, and returns false if there's a lot of pending writes                                                  // 16\n// buffered up.  When you call read(), that calls _read(n) until                                                     // 17\n// there's enough pending readable data buffered up.                                                                 // 18\n//                                                                                                                   // 19\n// In a transform stream, the written data is placed in a buffer.  When                                              // 20\n// _read(n) is called, it transforms the queued up data, calling the                                                 // 21\n// buffered _write cb's as it consumes chunks.  If consuming a single                                                // 22\n// written chunk would result in multiple output chunks, then the first                                              // 23\n// outputted bit calls the readcb, and subsequent chunks just go into                                                // 24\n// the read buffer, and will cause it to emit 'readable' if necessary.                                               // 25\n//                                                                                                                   // 26\n// This way, back-pressure is actually determined by the reading side,                                               // 27\n// since _read has to be called to start processing a new chunk.  However,                                           // 28\n// a pathological inflate type of transform can cause excessive buffering                                            // 29\n// here.  For example, imagine a stream where every byte of input is                                                 // 30\n// interpreted as an integer from 0-255, and then results in that many                                               // 31\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in                                               // 32\n// 1kb of data being output.  In this case, you could write a very small                                             // 33\n// amount of input, and end up with a very large amount of output.  In                                               // 34\n// such a pathological inflating mechanism, there'd be no way to tell                                                // 35\n// the system to stop doing the transform.  A single 4MB write could                                                 // 36\n// cause the system to run out of memory.                                                                            // 37\n//                                                                                                                   // 38\n// However, even in such a pathological case, only a single written chunk                                            // 39\n// would be consumed, and then the rest would wait (un-transformed) until                                            // 40\n// the results of the previous transformed chunk were consumed.                                                      // 41\n                                                                                                                     // 42\n'use strict';                                                                                                        // 43\n                                                                                                                     // 44\nmodule.exports = Transform;                                                                                          // 45\n                                                                                                                     // 46\nvar Duplex = require('./_stream_duplex');                                                                            // 47\n                                                                                                                     // 48\n/*<replacement>*/                                                                                                    // 49\nvar util = require('core-util-is');                                                                                  // 50\nutil.inherits = require('inherits');                                                                                 // 51\n/*</replacement>*/                                                                                                   // 52\n                                                                                                                     // 53\nutil.inherits(Transform, Duplex);                                                                                    // 54\n                                                                                                                     // 55\nfunction TransformState(stream) {                                                                                    // 56\n  this.afterTransform = function (er, data) {                                                                        // 57\n    return afterTransform(stream, er, data);                                                                         // 58\n  };                                                                                                                 // 59\n                                                                                                                     // 60\n  this.needTransform = false;                                                                                        // 61\n  this.transforming = false;                                                                                         // 62\n  this.writecb = null;                                                                                               // 63\n  this.writechunk = null;                                                                                            // 64\n  this.writeencoding = null;                                                                                         // 65\n}                                                                                                                    // 66\n                                                                                                                     // 67\nfunction afterTransform(stream, er, data) {                                                                          // 68\n  var ts = stream._transformState;                                                                                   // 69\n  ts.transforming = false;                                                                                           // 70\n                                                                                                                     // 71\n  var cb = ts.writecb;                                                                                               // 72\n                                                                                                                     // 73\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));                                  // 74\n                                                                                                                     // 75\n  ts.writechunk = null;                                                                                              // 76\n  ts.writecb = null;                                                                                                 // 77\n                                                                                                                     // 78\n  if (data !== null && data !== undefined) stream.push(data);                                                        // 79\n                                                                                                                     // 80\n  cb(er);                                                                                                            // 81\n                                                                                                                     // 82\n  var rs = stream._readableState;                                                                                    // 83\n  rs.reading = false;                                                                                                // 84\n  if (rs.needReadable || rs.length < rs.highWaterMark) {                                                             // 85\n    stream._read(rs.highWaterMark);                                                                                  // 86\n  }                                                                                                                  // 87\n}                                                                                                                    // 88\n                                                                                                                     // 89\nfunction Transform(options) {                                                                                        // 90\n  if (!(this instanceof Transform)) return new Transform(options);                                                   // 91\n                                                                                                                     // 92\n  Duplex.call(this, options);                                                                                        // 93\n                                                                                                                     // 94\n  this._transformState = new TransformState(this);                                                                   // 95\n                                                                                                                     // 96\n  // when the writable side finishes, then flush out anything remaining.                                             // 97\n  var stream = this;                                                                                                 // 98\n                                                                                                                     // 99\n  // start out asking for a readable event once data is transformed.                                                 // 100\n  this._readableState.needReadable = true;                                                                           // 101\n                                                                                                                     // 102\n  // we have implemented the _read method, and done the other things                                                 // 103\n  // that Readable wants before the first _read call, so unset the                                                   // 104\n  // sync guard flag.                                                                                                // 105\n  this._readableState.sync = false;                                                                                  // 106\n                                                                                                                     // 107\n  if (options) {                                                                                                     // 108\n    if (typeof options.transform === 'function') this._transform = options.transform;                                // 109\n                                                                                                                     // 110\n    if (typeof options.flush === 'function') this._flush = options.flush;                                            // 111\n  }                                                                                                                  // 112\n                                                                                                                     // 113\n  this.once('prefinish', function () {                                                                               // 114\n    if (typeof this._flush === 'function') this._flush(function (er) {                                               // 115\n      done(stream, er);                                                                                              // 116\n    });else done(stream);                                                                                            // 117\n  });                                                                                                                // 118\n}                                                                                                                    // 119\n                                                                                                                     // 120\nTransform.prototype.push = function (chunk, encoding) {                                                              // 121\n  this._transformState.needTransform = false;                                                                        // 122\n  return Duplex.prototype.push.call(this, chunk, encoding);                                                          // 123\n};                                                                                                                   // 124\n                                                                                                                     // 125\n// This is the part where you do stuff!                                                                              // 126\n// override this function in implementation classes.                                                                 // 127\n// 'chunk' is an input chunk.                                                                                        // 128\n//                                                                                                                   // 129\n// Call `push(newChunk)` to pass along transformed output                                                            // 130\n// to the readable side.  You may call 'push' zero or more times.                                                    // 131\n//                                                                                                                   // 132\n// Call `cb(err)` when you are done with this chunk.  If you pass                                                    // 133\n// an error, then that'll put the hurt on the whole operation.  If you                                               // 134\n// never call cb(), then you'll never get another chunk.                                                             // 135\nTransform.prototype._transform = function (chunk, encoding, cb) {                                                    // 136\n  throw new Error('not implemented');                                                                                // 137\n};                                                                                                                   // 138\n                                                                                                                     // 139\nTransform.prototype._write = function (chunk, encoding, cb) {                                                        // 140\n  var ts = this._transformState;                                                                                     // 141\n  ts.writecb = cb;                                                                                                   // 142\n  ts.writechunk = chunk;                                                                                             // 143\n  ts.writeencoding = encoding;                                                                                       // 144\n  if (!ts.transforming) {                                                                                            // 145\n    var rs = this._readableState;                                                                                    // 146\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);           // 147\n  }                                                                                                                  // 148\n};                                                                                                                   // 149\n                                                                                                                     // 150\n// Doesn't matter what the args are here.                                                                            // 151\n// _transform does all the work.                                                                                     // 152\n// That we got here means that the readable side wants more data.                                                    // 153\nTransform.prototype._read = function (n) {                                                                           // 154\n  var ts = this._transformState;                                                                                     // 155\n                                                                                                                     // 156\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {                                                    // 157\n    ts.transforming = true;                                                                                          // 158\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);                                             // 159\n  } else {                                                                                                           // 160\n    // mark that we need a transform, so that any data that comes in                                                 // 161\n    // will get processed, now that we've asked for it.                                                              // 162\n    ts.needTransform = true;                                                                                         // 163\n  }                                                                                                                  // 164\n};                                                                                                                   // 165\n                                                                                                                     // 166\nfunction done(stream, er) {                                                                                          // 167\n  if (er) return stream.emit('error', er);                                                                           // 168\n                                                                                                                     // 169\n  // if there's nothing in the write buffer, then that means                                                         // 170\n  // that nothing more will ever be provided                                                                         // 171\n  var ws = stream._writableState;                                                                                    // 172\n  var ts = stream._transformState;                                                                                   // 173\n                                                                                                                     // 174\n  if (ws.length) throw new Error('calling transform done when ws.length != 0');                                      // 175\n                                                                                                                     // 176\n  if (ts.transforming) throw new Error('calling transform done when still transforming');                            // 177\n                                                                                                                     // 178\n  return stream.push(null);                                                                                          // 179\n}                                                                                                                    // 180\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_passthrough.js\":[\"./_stream_transform\",\"core-util-is\",\"inherits\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/lib/_stream_passthrough.js                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// a passthrough stream.                                                                                             // 1\n// basically just the most minimal sort of Transform stream.                                                         // 2\n// Every written chunk gets output as-is.                                                                            // 3\n                                                                                                                     // 4\n'use strict';                                                                                                        // 5\n                                                                                                                     // 6\nmodule.exports = PassThrough;                                                                                        // 7\n                                                                                                                     // 8\nvar Transform = require('./_stream_transform');                                                                      // 9\n                                                                                                                     // 10\n/*<replacement>*/                                                                                                    // 11\nvar util = require('core-util-is');                                                                                  // 12\nutil.inherits = require('inherits');                                                                                 // 13\n/*</replacement>*/                                                                                                   // 14\n                                                                                                                     // 15\nutil.inherits(PassThrough, Transform);                                                                               // 16\n                                                                                                                     // 17\nfunction PassThrough(options) {                                                                                      // 18\n  if (!(this instanceof PassThrough)) return new PassThrough(options);                                               // 19\n                                                                                                                     // 20\n  Transform.call(this, options);                                                                                     // 21\n}                                                                                                                    // 22\n                                                                                                                     // 23\nPassThrough.prototype._transform = function (chunk, encoding, cb) {                                                  // 24\n  cb(null, chunk);                                                                                                   // 25\n};                                                                                                                   // 26\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"node_modules\":{\"process-nextick-args\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/process-nextick-args/package.json        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"process-nextick-args\";                                                                               // 1\nexports.version = \"1.0.6\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/process-nextick-args/index.js            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n'use strict';                                                                                                        // 1\n                                                                                                                     // 2\nif (!process.version ||                                                                                              // 3\n    process.version.indexOf('v0.') === 0 ||                                                                          // 4\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {                                // 5\n  module.exports = nextTick;                                                                                         // 6\n} else {                                                                                                             // 7\n  module.exports = process.nextTick;                                                                                 // 8\n}                                                                                                                    // 9\n                                                                                                                     // 10\nfunction nextTick(fn) {                                                                                              // 11\n  var args = new Array(arguments.length - 1);                                                                        // 12\n  var i = 0;                                                                                                         // 13\n  while (i < args.length) {                                                                                          // 14\n    args[i++] = arguments[i];                                                                                        // 15\n  }                                                                                                                  // 16\n  process.nextTick(function afterTick() {                                                                            // 17\n    fn.apply(null, args);                                                                                            // 18\n  });                                                                                                                // 19\n}                                                                                                                    // 20\n                                                                                                                     // 21\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"isarray\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/isarray/package.json                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"isarray\";                                                                                            // 1\nexports.version = \"1.0.0\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/isarray/index.js                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar toString = {}.toString;                                                                                          // 1\n                                                                                                                     // 2\nmodule.exports = Array.isArray || function (arr) {                                                                   // 3\n  return toString.call(arr) == '[object Array]';                                                                     // 4\n};                                                                                                                   // 5\n                                                                                                                     // 6\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"core-util-is\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/core-util-is/package.json                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"core-util-is\";                                                                                       // 1\nexports.version = \"1.0.2\";                                                                                           // 2\nexports.main = \"lib/util.js\";                                                                                        // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lib\":{\"util.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/core-util-is/lib/util.js                 //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n// NOTE: These type checking functions intentionally don't use `instanceof`                                          // 22\n// because it is fragile and can be easily faked with `Object.create()`.                                             // 23\n                                                                                                                     // 24\nfunction isArray(arg) {                                                                                              // 25\n  if (Array.isArray) {                                                                                               // 26\n    return Array.isArray(arg);                                                                                       // 27\n  }                                                                                                                  // 28\n  return objectToString(arg) === '[object Array]';                                                                   // 29\n}                                                                                                                    // 30\nexports.isArray = isArray;                                                                                           // 31\n                                                                                                                     // 32\nfunction isBoolean(arg) {                                                                                            // 33\n  return typeof arg === 'boolean';                                                                                   // 34\n}                                                                                                                    // 35\nexports.isBoolean = isBoolean;                                                                                       // 36\n                                                                                                                     // 37\nfunction isNull(arg) {                                                                                               // 38\n  return arg === null;                                                                                               // 39\n}                                                                                                                    // 40\nexports.isNull = isNull;                                                                                             // 41\n                                                                                                                     // 42\nfunction isNullOrUndefined(arg) {                                                                                    // 43\n  return arg == null;                                                                                                // 44\n}                                                                                                                    // 45\nexports.isNullOrUndefined = isNullOrUndefined;                                                                       // 46\n                                                                                                                     // 47\nfunction isNumber(arg) {                                                                                             // 48\n  return typeof arg === 'number';                                                                                    // 49\n}                                                                                                                    // 50\nexports.isNumber = isNumber;                                                                                         // 51\n                                                                                                                     // 52\nfunction isString(arg) {                                                                                             // 53\n  return typeof arg === 'string';                                                                                    // 54\n}                                                                                                                    // 55\nexports.isString = isString;                                                                                         // 56\n                                                                                                                     // 57\nfunction isSymbol(arg) {                                                                                             // 58\n  return typeof arg === 'symbol';                                                                                    // 59\n}                                                                                                                    // 60\nexports.isSymbol = isSymbol;                                                                                         // 61\n                                                                                                                     // 62\nfunction isUndefined(arg) {                                                                                          // 63\n  return arg === void 0;                                                                                             // 64\n}                                                                                                                    // 65\nexports.isUndefined = isUndefined;                                                                                   // 66\n                                                                                                                     // 67\nfunction isRegExp(re) {                                                                                              // 68\n  return objectToString(re) === '[object RegExp]';                                                                   // 69\n}                                                                                                                    // 70\nexports.isRegExp = isRegExp;                                                                                         // 71\n                                                                                                                     // 72\nfunction isObject(arg) {                                                                                             // 73\n  return typeof arg === 'object' && arg !== null;                                                                    // 74\n}                                                                                                                    // 75\nexports.isObject = isObject;                                                                                         // 76\n                                                                                                                     // 77\nfunction isDate(d) {                                                                                                 // 78\n  return objectToString(d) === '[object Date]';                                                                      // 79\n}                                                                                                                    // 80\nexports.isDate = isDate;                                                                                             // 81\n                                                                                                                     // 82\nfunction isError(e) {                                                                                                // 83\n  return (objectToString(e) === '[object Error]' || e instanceof Error);                                             // 84\n}                                                                                                                    // 85\nexports.isError = isError;                                                                                           // 86\n                                                                                                                     // 87\nfunction isFunction(arg) {                                                                                           // 88\n  return typeof arg === 'function';                                                                                  // 89\n}                                                                                                                    // 90\nexports.isFunction = isFunction;                                                                                     // 91\n                                                                                                                     // 92\nfunction isPrimitive(arg) {                                                                                          // 93\n  return arg === null ||                                                                                             // 94\n         typeof arg === 'boolean' ||                                                                                 // 95\n         typeof arg === 'number' ||                                                                                  // 96\n         typeof arg === 'string' ||                                                                                  // 97\n         typeof arg === 'symbol' ||  // ES6 symbol                                                                   // 98\n         typeof arg === 'undefined';                                                                                 // 99\n}                                                                                                                    // 100\nexports.isPrimitive = isPrimitive;                                                                                   // 101\n                                                                                                                     // 102\nexports.isBuffer = Buffer.isBuffer;                                                                                  // 103\n                                                                                                                     // 104\nfunction objectToString(o) {                                                                                         // 105\n  return Object.prototype.toString.call(o);                                                                          // 106\n}                                                                                                                    // 107\n                                                                                                                     // 108\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"inherits\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/inherits/package.json                    //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"inherits\";                                                                                           // 1\nexports.version = \"2.0.1\";                                                                                           // 2\nexports.main = \"./inherits_browser.js\";                                                                              // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"inherits_browser.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/inherits/inherits_browser.js             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nif (typeof Object.create === 'function') {                                                                           // 1\n  // implementation from standard node.js 'util' module                                                              // 2\n  module.exports = function inherits(ctor, superCtor) {                                                              // 3\n    ctor.super_ = superCtor                                                                                          // 4\n    ctor.prototype = Object.create(superCtor.prototype, {                                                            // 5\n      constructor: {                                                                                                 // 6\n        value: ctor,                                                                                                 // 7\n        enumerable: false,                                                                                           // 8\n        writable: true,                                                                                              // 9\n        configurable: true                                                                                           // 10\n      }                                                                                                              // 11\n    });                                                                                                              // 12\n  };                                                                                                                 // 13\n} else {                                                                                                             // 14\n  // old school shim for old browsers                                                                                // 15\n  module.exports = function inherits(ctor, superCtor) {                                                              // 16\n    ctor.super_ = superCtor                                                                                          // 17\n    var TempCtor = function () {}                                                                                    // 18\n    TempCtor.prototype = superCtor.prototype                                                                         // 19\n    ctor.prototype = new TempCtor()                                                                                  // 20\n    ctor.prototype.constructor = ctor                                                                                // 21\n  }                                                                                                                  // 22\n}                                                                                                                    // 23\n                                                                                                                     // 24\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"util-deprecate\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/util-deprecate/package.json              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"util-deprecate\";                                                                                     // 1\nexports.version = \"1.0.2\";                                                                                           // 2\nexports.main = \"browser.js\";                                                                                         // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"browser.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/util-deprecate/browser.js                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n                                                                                                                     // 1\n/**                                                                                                                  // 2\n * Module exports.                                                                                                   // 3\n */                                                                                                                  // 4\n                                                                                                                     // 5\nmodule.exports = deprecate;                                                                                          // 6\n                                                                                                                     // 7\n/**                                                                                                                  // 8\n * Mark that a method should not be used.                                                                            // 9\n * Returns a modified function which warns once by default.                                                          // 10\n *                                                                                                                   // 11\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.                                                // 12\n *                                                                                                                   // 13\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions                                       // 14\n * will throw an Error when invoked.                                                                                 // 15\n *                                                                                                                   // 16\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions                                       // 17\n * will invoke `console.trace()` instead of `console.error()`.                                                       // 18\n *                                                                                                                   // 19\n * @param {Function} fn - the function to deprecate                                                                  // 20\n * @param {String} msg - the string to print to the console when `fn` is invoked                                     // 21\n * @returns {Function} a new \"deprecated\" version of `fn`                                                            // 22\n * @api public                                                                                                       // 23\n */                                                                                                                  // 24\n                                                                                                                     // 25\nfunction deprecate (fn, msg) {                                                                                       // 26\n  if (config('noDeprecation')) {                                                                                     // 27\n    return fn;                                                                                                       // 28\n  }                                                                                                                  // 29\n                                                                                                                     // 30\n  var warned = false;                                                                                                // 31\n  function deprecated() {                                                                                            // 32\n    if (!warned) {                                                                                                   // 33\n      if (config('throwDeprecation')) {                                                                              // 34\n        throw new Error(msg);                                                                                        // 35\n      } else if (config('traceDeprecation')) {                                                                       // 36\n        console.trace(msg);                                                                                          // 37\n      } else {                                                                                                       // 38\n        console.warn(msg);                                                                                           // 39\n      }                                                                                                              // 40\n      warned = true;                                                                                                 // 41\n    }                                                                                                                // 42\n    return fn.apply(this, arguments);                                                                                // 43\n  }                                                                                                                  // 44\n                                                                                                                     // 45\n  return deprecated;                                                                                                 // 46\n}                                                                                                                    // 47\n                                                                                                                     // 48\n/**                                                                                                                  // 49\n * Checks `localStorage` for boolean values for the given `name`.                                                    // 50\n *                                                                                                                   // 51\n * @param {String} name                                                                                              // 52\n * @returns {Boolean}                                                                                                // 53\n * @api private                                                                                                      // 54\n */                                                                                                                  // 55\n                                                                                                                     // 56\nfunction config (name) {                                                                                             // 57\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes                                   // 58\n  try {                                                                                                              // 59\n    if (!global.localStorage) return false;                                                                          // 60\n  } catch (_) {                                                                                                      // 61\n    return false;                                                                                                    // 62\n  }                                                                                                                  // 63\n  var val = global.localStorage[name];                                                                               // 64\n  if (null == val) return false;                                                                                     // 65\n  return String(val).toLowerCase() === 'true';                                                                       // 66\n}                                                                                                                    // 67\n                                                                                                                     // 68\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"writable.js\":[\"./lib/_stream_writable.js\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/writable.js                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.exports = require(\"./lib/_stream_writable.js\")                                                                // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"duplex.js\":[\"./lib/_stream_duplex.js\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/duplex.js                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.exports = require(\"./lib/_stream_duplex.js\")                                                                  // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"transform.js\":[\"./lib/_stream_transform.js\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/transform.js                                          //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.exports = require(\"./lib/_stream_transform.js\")                                                               // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"passthrough.js\":[\"./lib/_stream_passthrough.js\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/readable-stream/passthrough.js                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.exports = require(\"./lib/_stream_passthrough.js\")                                                             // 1\n                                                                                                                     // 2\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"buffer\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/buffer/package.json                                                   //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"buffer\";                                                                                             // 1\nexports.version = \"4.5.1\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"base64-js\",\"ieee754\",\"isarray\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/buffer/index.js                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/*!                                                                                                                  // 1\n * The buffer module from node.js, for the browser.                                                                  // 2\n *                                                                                                                   // 3\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>                                             // 4\n * @license  MIT                                                                                                     // 5\n */                                                                                                                  // 6\n/* eslint-disable no-proto */                                                                                        // 7\n                                                                                                                     // 8\n'use strict'                                                                                                         // 9\n                                                                                                                     // 10\nvar base64 = require('base64-js')                                                                                    // 11\nvar ieee754 = require('ieee754')                                                                                     // 12\nvar isArray = require('isarray')                                                                                     // 13\n                                                                                                                     // 14\nexports.Buffer = Buffer                                                                                              // 15\nexports.SlowBuffer = SlowBuffer                                                                                      // 16\nexports.INSPECT_MAX_BYTES = 50                                                                                       // 17\nBuffer.poolSize = 8192 // not used by this implementation                                                            // 18\n                                                                                                                     // 19\nvar rootParent = {}                                                                                                  // 20\n                                                                                                                     // 21\n/**                                                                                                                  // 22\n * If `Buffer.TYPED_ARRAY_SUPPORT`:                                                                                  // 23\n *   === true    Use Uint8Array implementation (fastest)                                                             // 24\n *   === false   Use Object implementation (most compatible, even IE6)                                               // 25\n *                                                                                                                   // 26\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,                                // 27\n * Opera 11.6+, iOS 4.2+.                                                                                            // 28\n *                                                                                                                   // 29\n * Due to various browser bugs, sometimes the Object implementation will be used even                                // 30\n * when the browser supports typed arrays.                                                                           // 31\n *                                                                                                                   // 32\n * Note:                                                                                                             // 33\n *                                                                                                                   // 34\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,                               // 35\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.                                                     // 36\n *                                                                                                                   // 37\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.                                          // 38\n *                                                                                                                   // 39\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of                            // 40\n *     incorrect length in some situations.                                                                          // 41\n                                                                                                                     // 42\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they                            // 43\n * get the Object implementation, which is slower but behaves correctly.                                             // 44\n */                                                                                                                  // 45\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined                                                // 46\n  ? global.TYPED_ARRAY_SUPPORT                                                                                       // 47\n  : typedArraySupport()                                                                                              // 48\n                                                                                                                     // 49\nfunction typedArraySupport () {                                                                                      // 50\n  try {                                                                                                              // 51\n    var arr = new Uint8Array(1)                                                                                      // 52\n    arr.foo = function () { return 42 }                                                                              // 53\n    return arr.foo() === 42 && // typed array instances can be augmented                                             // 54\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`                                         // 55\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`                                            // 56\n  } catch (e) {                                                                                                      // 57\n    return false                                                                                                     // 58\n  }                                                                                                                  // 59\n}                                                                                                                    // 60\n                                                                                                                     // 61\nfunction kMaxLength () {                                                                                             // 62\n  return Buffer.TYPED_ARRAY_SUPPORT                                                                                  // 63\n    ? 0x7fffffff                                                                                                     // 64\n    : 0x3fffffff                                                                                                     // 65\n}                                                                                                                    // 66\n                                                                                                                     // 67\n/**                                                                                                                  // 68\n * The Buffer constructor returns instances of `Uint8Array` that have their                                          // 69\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of                                   // 70\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods                                   // 71\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it                                     // 72\n * returns a single octet.                                                                                           // 73\n *                                                                                                                   // 74\n * The `Uint8Array` prototype remains unmodified.                                                                    // 75\n */                                                                                                                  // 76\nfunction Buffer (arg) {                                                                                              // 77\n  if (!(this instanceof Buffer)) {                                                                                   // 78\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.                                         // 79\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])                                                   // 80\n    return new Buffer(arg)                                                                                           // 81\n  }                                                                                                                  // 82\n                                                                                                                     // 83\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {                                                                                 // 84\n    this.length = 0                                                                                                  // 85\n    this.parent = undefined                                                                                          // 86\n  }                                                                                                                  // 87\n                                                                                                                     // 88\n  // Common case.                                                                                                    // 89\n  if (typeof arg === 'number') {                                                                                     // 90\n    return fromNumber(this, arg)                                                                                     // 91\n  }                                                                                                                  // 92\n                                                                                                                     // 93\n  // Slightly less common case.                                                                                      // 94\n  if (typeof arg === 'string') {                                                                                     // 95\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')                                       // 96\n  }                                                                                                                  // 97\n                                                                                                                     // 98\n  // Unusual.                                                                                                        // 99\n  return fromObject(this, arg)                                                                                       // 100\n}                                                                                                                    // 101\n                                                                                                                     // 102\n// TODO: Legacy, not needed anymore. Remove in next major version.                                                   // 103\nBuffer._augment = function (arr) {                                                                                   // 104\n  arr.__proto__ = Buffer.prototype                                                                                   // 105\n  return arr                                                                                                         // 106\n}                                                                                                                    // 107\n                                                                                                                     // 108\nfunction fromNumber (that, length) {                                                                                 // 109\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)                                                        // 110\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {                                                                                 // 111\n    for (var i = 0; i < length; i++) {                                                                               // 112\n      that[i] = 0                                                                                                    // 113\n    }                                                                                                                // 114\n  }                                                                                                                  // 115\n  return that                                                                                                        // 116\n}                                                                                                                    // 117\n                                                                                                                     // 118\nfunction fromString (that, string, encoding) {                                                                       // 119\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'                                             // 120\n                                                                                                                     // 121\n  // Assumption: byteLength() return value is always < kMaxLength.                                                   // 122\n  var length = byteLength(string, encoding) | 0                                                                      // 123\n  that = allocate(that, length)                                                                                      // 124\n                                                                                                                     // 125\n  that.write(string, encoding)                                                                                       // 126\n  return that                                                                                                        // 127\n}                                                                                                                    // 128\n                                                                                                                     // 129\nfunction fromObject (that, object) {                                                                                 // 130\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)                                                       // 131\n                                                                                                                     // 132\n  if (isArray(object)) return fromArray(that, object)                                                                // 133\n                                                                                                                     // 134\n  if (object == null) {                                                                                              // 135\n    throw new TypeError('must start with number, buffer, array or string')                                           // 136\n  }                                                                                                                  // 137\n                                                                                                                     // 138\n  if (typeof ArrayBuffer !== 'undefined') {                                                                          // 139\n    if (object.buffer instanceof ArrayBuffer) {                                                                      // 140\n      return fromTypedArray(that, object)                                                                            // 141\n    }                                                                                                                // 142\n    if (object instanceof ArrayBuffer) {                                                                             // 143\n      return fromArrayBuffer(that, object)                                                                           // 144\n    }                                                                                                                // 145\n  }                                                                                                                  // 146\n                                                                                                                     // 147\n  if (object.length) return fromArrayLike(that, object)                                                              // 148\n                                                                                                                     // 149\n  return fromJsonObject(that, object)                                                                                // 150\n}                                                                                                                    // 151\n                                                                                                                     // 152\nfunction fromBuffer (that, buffer) {                                                                                 // 153\n  var length = checked(buffer.length) | 0                                                                            // 154\n  that = allocate(that, length)                                                                                      // 155\n  buffer.copy(that, 0, 0, length)                                                                                    // 156\n  return that                                                                                                        // 157\n}                                                                                                                    // 158\n                                                                                                                     // 159\nfunction fromArray (that, array) {                                                                                   // 160\n  var length = checked(array.length) | 0                                                                             // 161\n  that = allocate(that, length)                                                                                      // 162\n  for (var i = 0; i < length; i += 1) {                                                                              // 163\n    that[i] = array[i] & 255                                                                                         // 164\n  }                                                                                                                  // 165\n  return that                                                                                                        // 166\n}                                                                                                                    // 167\n                                                                                                                     // 168\n// Duplicate of fromArray() to keep fromArray() monomorphic.                                                         // 169\nfunction fromTypedArray (that, array) {                                                                              // 170\n  var length = checked(array.length) | 0                                                                             // 171\n  that = allocate(that, length)                                                                                      // 172\n  // Truncating the elements is probably not what people expect from typed                                           // 173\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior                                         // 174\n  // of the old Buffer constructor.                                                                                  // 175\n  for (var i = 0; i < length; i += 1) {                                                                              // 176\n    that[i] = array[i] & 255                                                                                         // 177\n  }                                                                                                                  // 178\n  return that                                                                                                        // 179\n}                                                                                                                    // 180\n                                                                                                                     // 181\nfunction fromArrayBuffer (that, array) {                                                                             // 182\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer                                              // 183\n                                                                                                                     // 184\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                  // 185\n    // Return an augmented `Uint8Array` instance, for best performance                                               // 186\n    that = new Uint8Array(array)                                                                                     // 187\n    that.__proto__ = Buffer.prototype                                                                                // 188\n  } else {                                                                                                           // 189\n    // Fallback: Return an object instance of the Buffer class                                                       // 190\n    that = fromTypedArray(that, new Uint8Array(array))                                                               // 191\n  }                                                                                                                  // 192\n  return that                                                                                                        // 193\n}                                                                                                                    // 194\n                                                                                                                     // 195\nfunction fromArrayLike (that, array) {                                                                               // 196\n  var length = checked(array.length) | 0                                                                             // 197\n  that = allocate(that, length)                                                                                      // 198\n  for (var i = 0; i < length; i += 1) {                                                                              // 199\n    that[i] = array[i] & 255                                                                                         // 200\n  }                                                                                                                  // 201\n  return that                                                                                                        // 202\n}                                                                                                                    // 203\n                                                                                                                     // 204\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.                                           // 205\n// Returns a zero-length buffer for inputs that don't conform to the spec.                                           // 206\nfunction fromJsonObject (that, object) {                                                                             // 207\n  var array                                                                                                          // 208\n  var length = 0                                                                                                     // 209\n                                                                                                                     // 210\n  if (object.type === 'Buffer' && isArray(object.data)) {                                                            // 211\n    array = object.data                                                                                              // 212\n    length = checked(array.length) | 0                                                                               // 213\n  }                                                                                                                  // 214\n  that = allocate(that, length)                                                                                      // 215\n                                                                                                                     // 216\n  for (var i = 0; i < length; i += 1) {                                                                              // 217\n    that[i] = array[i] & 255                                                                                         // 218\n  }                                                                                                                  // 219\n  return that                                                                                                        // 220\n}                                                                                                                    // 221\n                                                                                                                     // 222\nif (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                    // 223\n  Buffer.prototype.__proto__ = Uint8Array.prototype                                                                  // 224\n  Buffer.__proto__ = Uint8Array                                                                                      // 225\n  if (typeof Symbol !== 'undefined' && Symbol.species &&                                                             // 226\n      Buffer[Symbol.species] === Buffer) {                                                                           // 227\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97                                       // 228\n    Object.defineProperty(Buffer, Symbol.species, {                                                                  // 229\n      value: null,                                                                                                   // 230\n      configurable: true                                                                                             // 231\n    })                                                                                                               // 232\n  }                                                                                                                  // 233\n} else {                                                                                                             // 234\n  // pre-set for values that may exist in the future                                                                 // 235\n  Buffer.prototype.length = undefined                                                                                // 236\n  Buffer.prototype.parent = undefined                                                                                // 237\n}                                                                                                                    // 238\n                                                                                                                     // 239\nfunction allocate (that, length) {                                                                                   // 240\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                  // 241\n    // Return an augmented `Uint8Array` instance, for best performance                                               // 242\n    that = new Uint8Array(length)                                                                                    // 243\n    that.__proto__ = Buffer.prototype                                                                                // 244\n  } else {                                                                                                           // 245\n    // Fallback: Return an object instance of the Buffer class                                                       // 246\n    that.length = length                                                                                             // 247\n  }                                                                                                                  // 248\n                                                                                                                     // 249\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1                                                     // 250\n  if (fromPool) that.parent = rootParent                                                                             // 251\n                                                                                                                     // 252\n  return that                                                                                                        // 253\n}                                                                                                                    // 254\n                                                                                                                     // 255\nfunction checked (length) {                                                                                          // 256\n  // Note: cannot use `length < kMaxLength` here because that fails when                                             // 257\n  // length is NaN (which is otherwise coerced to zero.)                                                             // 258\n  if (length >= kMaxLength()) {                                                                                      // 259\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +                                         // 260\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')                                          // 261\n  }                                                                                                                  // 262\n  return length | 0                                                                                                  // 263\n}                                                                                                                    // 264\n                                                                                                                     // 265\nfunction SlowBuffer (subject, encoding) {                                                                            // 266\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)                                        // 267\n                                                                                                                     // 268\n  var buf = new Buffer(subject, encoding)                                                                            // 269\n  delete buf.parent                                                                                                  // 270\n  return buf                                                                                                         // 271\n}                                                                                                                    // 272\n                                                                                                                     // 273\nBuffer.isBuffer = function isBuffer (b) {                                                                            // 274\n  return !!(b != null && b._isBuffer)                                                                                // 275\n}                                                                                                                    // 276\n                                                                                                                     // 277\nBuffer.compare = function compare (a, b) {                                                                           // 278\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {                                                                  // 279\n    throw new TypeError('Arguments must be Buffers')                                                                 // 280\n  }                                                                                                                  // 281\n                                                                                                                     // 282\n  if (a === b) return 0                                                                                              // 283\n                                                                                                                     // 284\n  var x = a.length                                                                                                   // 285\n  var y = b.length                                                                                                   // 286\n                                                                                                                     // 287\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {                                                              // 288\n    if (a[i] !== b[i]) {                                                                                             // 289\n      x = a[i]                                                                                                       // 290\n      y = b[i]                                                                                                       // 291\n      break                                                                                                          // 292\n    }                                                                                                                // 293\n  }                                                                                                                  // 294\n                                                                                                                     // 295\n  if (x < y) return -1                                                                                               // 296\n  if (y < x) return 1                                                                                                // 297\n  return 0                                                                                                           // 298\n}                                                                                                                    // 299\n                                                                                                                     // 300\nBuffer.isEncoding = function isEncoding (encoding) {                                                                 // 301\n  switch (String(encoding).toLowerCase()) {                                                                          // 302\n    case 'hex':                                                                                                      // 303\n    case 'utf8':                                                                                                     // 304\n    case 'utf-8':                                                                                                    // 305\n    case 'ascii':                                                                                                    // 306\n    case 'binary':                                                                                                   // 307\n    case 'base64':                                                                                                   // 308\n    case 'raw':                                                                                                      // 309\n    case 'ucs2':                                                                                                     // 310\n    case 'ucs-2':                                                                                                    // 311\n    case 'utf16le':                                                                                                  // 312\n    case 'utf-16le':                                                                                                 // 313\n      return true                                                                                                    // 314\n    default:                                                                                                         // 315\n      return false                                                                                                   // 316\n  }                                                                                                                  // 317\n}                                                                                                                    // 318\n                                                                                                                     // 319\nBuffer.concat = function concat (list, length) {                                                                     // 320\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')                              // 321\n                                                                                                                     // 322\n  if (list.length === 0) {                                                                                           // 323\n    return new Buffer(0)                                                                                             // 324\n  }                                                                                                                  // 325\n                                                                                                                     // 326\n  var i                                                                                                              // 327\n  if (length === undefined) {                                                                                        // 328\n    length = 0                                                                                                       // 329\n    for (i = 0; i < list.length; i++) {                                                                              // 330\n      length += list[i].length                                                                                       // 331\n    }                                                                                                                // 332\n  }                                                                                                                  // 333\n                                                                                                                     // 334\n  var buf = new Buffer(length)                                                                                       // 335\n  var pos = 0                                                                                                        // 336\n  for (i = 0; i < list.length; i++) {                                                                                // 337\n    var item = list[i]                                                                                               // 338\n    item.copy(buf, pos)                                                                                              // 339\n    pos += item.length                                                                                               // 340\n  }                                                                                                                  // 341\n  return buf                                                                                                         // 342\n}                                                                                                                    // 343\n                                                                                                                     // 344\nfunction byteLength (string, encoding) {                                                                             // 345\n  if (typeof string !== 'string') string = '' + string                                                               // 346\n                                                                                                                     // 347\n  var len = string.length                                                                                            // 348\n  if (len === 0) return 0                                                                                            // 349\n                                                                                                                     // 350\n  // Use a for loop to avoid recursion                                                                               // 351\n  var loweredCase = false                                                                                            // 352\n  for (;;) {                                                                                                         // 353\n    switch (encoding) {                                                                                              // 354\n      case 'ascii':                                                                                                  // 355\n      case 'binary':                                                                                                 // 356\n      // Deprecated                                                                                                  // 357\n      case 'raw':                                                                                                    // 358\n      case 'raws':                                                                                                   // 359\n        return len                                                                                                   // 360\n      case 'utf8':                                                                                                   // 361\n      case 'utf-8':                                                                                                  // 362\n        return utf8ToBytes(string).length                                                                            // 363\n      case 'ucs2':                                                                                                   // 364\n      case 'ucs-2':                                                                                                  // 365\n      case 'utf16le':                                                                                                // 366\n      case 'utf-16le':                                                                                               // 367\n        return len * 2                                                                                               // 368\n      case 'hex':                                                                                                    // 369\n        return len >>> 1                                                                                             // 370\n      case 'base64':                                                                                                 // 371\n        return base64ToBytes(string).length                                                                          // 372\n      default:                                                                                                       // 373\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8                                            // 374\n        encoding = ('' + encoding).toLowerCase()                                                                     // 375\n        loweredCase = true                                                                                           // 376\n    }                                                                                                                // 377\n  }                                                                                                                  // 378\n}                                                                                                                    // 379\nBuffer.byteLength = byteLength                                                                                       // 380\n                                                                                                                     // 381\nfunction slowToString (encoding, start, end) {                                                                       // 382\n  var loweredCase = false                                                                                            // 383\n                                                                                                                     // 384\n  start = start | 0                                                                                                  // 385\n  end = end === undefined || end === Infinity ? this.length : end | 0                                                // 386\n                                                                                                                     // 387\n  if (!encoding) encoding = 'utf8'                                                                                   // 388\n  if (start < 0) start = 0                                                                                           // 389\n  if (end > this.length) end = this.length                                                                           // 390\n  if (end <= start) return ''                                                                                        // 391\n                                                                                                                     // 392\n  while (true) {                                                                                                     // 393\n    switch (encoding) {                                                                                              // 394\n      case 'hex':                                                                                                    // 395\n        return hexSlice(this, start, end)                                                                            // 396\n                                                                                                                     // 397\n      case 'utf8':                                                                                                   // 398\n      case 'utf-8':                                                                                                  // 399\n        return utf8Slice(this, start, end)                                                                           // 400\n                                                                                                                     // 401\n      case 'ascii':                                                                                                  // 402\n        return asciiSlice(this, start, end)                                                                          // 403\n                                                                                                                     // 404\n      case 'binary':                                                                                                 // 405\n        return binarySlice(this, start, end)                                                                         // 406\n                                                                                                                     // 407\n      case 'base64':                                                                                                 // 408\n        return base64Slice(this, start, end)                                                                         // 409\n                                                                                                                     // 410\n      case 'ucs2':                                                                                                   // 411\n      case 'ucs-2':                                                                                                  // 412\n      case 'utf16le':                                                                                                // 413\n      case 'utf-16le':                                                                                               // 414\n        return utf16leSlice(this, start, end)                                                                        // 415\n                                                                                                                     // 416\n      default:                                                                                                       // 417\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)                                        // 418\n        encoding = (encoding + '').toLowerCase()                                                                     // 419\n        loweredCase = true                                                                                           // 420\n    }                                                                                                                // 421\n  }                                                                                                                  // 422\n}                                                                                                                    // 423\n                                                                                                                     // 424\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect                               // 425\n// Buffer instances.                                                                                                 // 426\nBuffer.prototype._isBuffer = true                                                                                    // 427\n                                                                                                                     // 428\nBuffer.prototype.toString = function toString () {                                                                   // 429\n  var length = this.length | 0                                                                                       // 430\n  if (length === 0) return ''                                                                                        // 431\n  if (arguments.length === 0) return utf8Slice(this, 0, length)                                                      // 432\n  return slowToString.apply(this, arguments)                                                                         // 433\n}                                                                                                                    // 434\n                                                                                                                     // 435\nBuffer.prototype.equals = function equals (b) {                                                                      // 436\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')                                          // 437\n  if (this === b) return true                                                                                        // 438\n  return Buffer.compare(this, b) === 0                                                                               // 439\n}                                                                                                                    // 440\n                                                                                                                     // 441\nBuffer.prototype.inspect = function inspect () {                                                                     // 442\n  var str = ''                                                                                                       // 443\n  var max = exports.INSPECT_MAX_BYTES                                                                                // 444\n  if (this.length > 0) {                                                                                             // 445\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')                                                      // 446\n    if (this.length > max) str += ' ... '                                                                            // 447\n  }                                                                                                                  // 448\n  return '<Buffer ' + str + '>'                                                                                      // 449\n}                                                                                                                    // 450\n                                                                                                                     // 451\nBuffer.prototype.compare = function compare (b) {                                                                    // 452\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')                                          // 453\n  return Buffer.compare(this, b)                                                                                     // 454\n}                                                                                                                    // 455\n                                                                                                                     // 456\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {                                                      // 457\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff                                                               // 458\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000                                                        // 459\n  byteOffset >>= 0                                                                                                   // 460\n                                                                                                                     // 461\n  if (this.length === 0) return -1                                                                                   // 462\n  if (byteOffset >= this.length) return -1                                                                           // 463\n                                                                                                                     // 464\n  // Negative offsets start from the end of the buffer                                                               // 465\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)                                             // 466\n                                                                                                                     // 467\n  if (typeof val === 'string') {                                                                                     // 468\n    if (val.length === 0) return -1 // special case: looking for empty string always fails                           // 469\n    return String.prototype.indexOf.call(this, val, byteOffset)                                                      // 470\n  }                                                                                                                  // 471\n  if (Buffer.isBuffer(val)) {                                                                                        // 472\n    return arrayIndexOf(this, val, byteOffset)                                                                       // 473\n  }                                                                                                                  // 474\n  if (typeof val === 'number') {                                                                                     // 475\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {                                 // 476\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)                                                // 477\n    }                                                                                                                // 478\n    return arrayIndexOf(this, [ val ], byteOffset)                                                                   // 479\n  }                                                                                                                  // 480\n                                                                                                                     // 481\n  function arrayIndexOf (arr, val, byteOffset) {                                                                     // 482\n    var foundIndex = -1                                                                                              // 483\n    for (var i = 0; byteOffset + i < arr.length; i++) {                                                              // 484\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {                                     // 485\n        if (foundIndex === -1) foundIndex = i                                                                        // 486\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex                                        // 487\n      } else {                                                                                                       // 488\n        foundIndex = -1                                                                                              // 489\n      }                                                                                                              // 490\n    }                                                                                                                // 491\n    return -1                                                                                                        // 492\n  }                                                                                                                  // 493\n                                                                                                                     // 494\n  throw new TypeError('val must be string, number or Buffer')                                                        // 495\n}                                                                                                                    // 496\n                                                                                                                     // 497\nfunction hexWrite (buf, string, offset, length) {                                                                    // 498\n  offset = Number(offset) || 0                                                                                       // 499\n  var remaining = buf.length - offset                                                                                // 500\n  if (!length) {                                                                                                     // 501\n    length = remaining                                                                                               // 502\n  } else {                                                                                                           // 503\n    length = Number(length)                                                                                          // 504\n    if (length > remaining) {                                                                                        // 505\n      length = remaining                                                                                             // 506\n    }                                                                                                                // 507\n  }                                                                                                                  // 508\n                                                                                                                     // 509\n  // must be an even number of digits                                                                                // 510\n  var strLen = string.length                                                                                         // 511\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')                                                        // 512\n                                                                                                                     // 513\n  if (length > strLen / 2) {                                                                                         // 514\n    length = strLen / 2                                                                                              // 515\n  }                                                                                                                  // 516\n  for (var i = 0; i < length; i++) {                                                                                 // 517\n    var parsed = parseInt(string.substr(i * 2, 2), 16)                                                               // 518\n    if (isNaN(parsed)) throw new Error('Invalid hex string')                                                         // 519\n    buf[offset + i] = parsed                                                                                         // 520\n  }                                                                                                                  // 521\n  return i                                                                                                           // 522\n}                                                                                                                    // 523\n                                                                                                                     // 524\nfunction utf8Write (buf, string, offset, length) {                                                                   // 525\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)                                   // 526\n}                                                                                                                    // 527\n                                                                                                                     // 528\nfunction asciiWrite (buf, string, offset, length) {                                                                  // 529\n  return blitBuffer(asciiToBytes(string), buf, offset, length)                                                       // 530\n}                                                                                                                    // 531\n                                                                                                                     // 532\nfunction binaryWrite (buf, string, offset, length) {                                                                 // 533\n  return asciiWrite(buf, string, offset, length)                                                                     // 534\n}                                                                                                                    // 535\n                                                                                                                     // 536\nfunction base64Write (buf, string, offset, length) {                                                                 // 537\n  return blitBuffer(base64ToBytes(string), buf, offset, length)                                                      // 538\n}                                                                                                                    // 539\n                                                                                                                     // 540\nfunction ucs2Write (buf, string, offset, length) {                                                                   // 541\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)                                // 542\n}                                                                                                                    // 543\n                                                                                                                     // 544\nBuffer.prototype.write = function write (string, offset, length, encoding) {                                         // 545\n  // Buffer#write(string)                                                                                            // 546\n  if (offset === undefined) {                                                                                        // 547\n    encoding = 'utf8'                                                                                                // 548\n    length = this.length                                                                                             // 549\n    offset = 0                                                                                                       // 550\n  // Buffer#write(string, encoding)                                                                                  // 551\n  } else if (length === undefined && typeof offset === 'string') {                                                   // 552\n    encoding = offset                                                                                                // 553\n    length = this.length                                                                                             // 554\n    offset = 0                                                                                                       // 555\n  // Buffer#write(string, offset[, length][, encoding])                                                              // 556\n  } else if (isFinite(offset)) {                                                                                     // 557\n    offset = offset | 0                                                                                              // 558\n    if (isFinite(length)) {                                                                                          // 559\n      length = length | 0                                                                                            // 560\n      if (encoding === undefined) encoding = 'utf8'                                                                  // 561\n    } else {                                                                                                         // 562\n      encoding = length                                                                                              // 563\n      length = undefined                                                                                             // 564\n    }                                                                                                                // 565\n  // legacy write(string, encoding, offset, length) - remove in v0.13                                                // 566\n  } else {                                                                                                           // 567\n    var swap = encoding                                                                                              // 568\n    encoding = offset                                                                                                // 569\n    offset = length | 0                                                                                              // 570\n    length = swap                                                                                                    // 571\n  }                                                                                                                  // 572\n                                                                                                                     // 573\n  var remaining = this.length - offset                                                                               // 574\n  if (length === undefined || length > remaining) length = remaining                                                 // 575\n                                                                                                                     // 576\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {                                   // 577\n    throw new RangeError('attempt to write outside buffer bounds')                                                   // 578\n  }                                                                                                                  // 579\n                                                                                                                     // 580\n  if (!encoding) encoding = 'utf8'                                                                                   // 581\n                                                                                                                     // 582\n  var loweredCase = false                                                                                            // 583\n  for (;;) {                                                                                                         // 584\n    switch (encoding) {                                                                                              // 585\n      case 'hex':                                                                                                    // 586\n        return hexWrite(this, string, offset, length)                                                                // 587\n                                                                                                                     // 588\n      case 'utf8':                                                                                                   // 589\n      case 'utf-8':                                                                                                  // 590\n        return utf8Write(this, string, offset, length)                                                               // 591\n                                                                                                                     // 592\n      case 'ascii':                                                                                                  // 593\n        return asciiWrite(this, string, offset, length)                                                              // 594\n                                                                                                                     // 595\n      case 'binary':                                                                                                 // 596\n        return binaryWrite(this, string, offset, length)                                                             // 597\n                                                                                                                     // 598\n      case 'base64':                                                                                                 // 599\n        // Warning: maxLength not taken into account in base64Write                                                  // 600\n        return base64Write(this, string, offset, length)                                                             // 601\n                                                                                                                     // 602\n      case 'ucs2':                                                                                                   // 603\n      case 'ucs-2':                                                                                                  // 604\n      case 'utf16le':                                                                                                // 605\n      case 'utf-16le':                                                                                               // 606\n        return ucs2Write(this, string, offset, length)                                                               // 607\n                                                                                                                     // 608\n      default:                                                                                                       // 609\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)                                        // 610\n        encoding = ('' + encoding).toLowerCase()                                                                     // 611\n        loweredCase = true                                                                                           // 612\n    }                                                                                                                // 613\n  }                                                                                                                  // 614\n}                                                                                                                    // 615\n                                                                                                                     // 616\nBuffer.prototype.toJSON = function toJSON () {                                                                       // 617\n  return {                                                                                                           // 618\n    type: 'Buffer',                                                                                                  // 619\n    data: Array.prototype.slice.call(this._arr || this, 0)                                                           // 620\n  }                                                                                                                  // 621\n}                                                                                                                    // 622\n                                                                                                                     // 623\nfunction base64Slice (buf, start, end) {                                                                             // 624\n  if (start === 0 && end === buf.length) {                                                                           // 625\n    return base64.fromByteArray(buf)                                                                                 // 626\n  } else {                                                                                                           // 627\n    return base64.fromByteArray(buf.slice(start, end))                                                               // 628\n  }                                                                                                                  // 629\n}                                                                                                                    // 630\n                                                                                                                     // 631\nfunction utf8Slice (buf, start, end) {                                                                               // 632\n  end = Math.min(buf.length, end)                                                                                    // 633\n  var res = []                                                                                                       // 634\n                                                                                                                     // 635\n  var i = start                                                                                                      // 636\n  while (i < end) {                                                                                                  // 637\n    var firstByte = buf[i]                                                                                           // 638\n    var codePoint = null                                                                                             // 639\n    var bytesPerSequence = (firstByte > 0xEF) ? 4                                                                    // 640\n      : (firstByte > 0xDF) ? 3                                                                                       // 641\n      : (firstByte > 0xBF) ? 2                                                                                       // 642\n      : 1                                                                                                            // 643\n                                                                                                                     // 644\n    if (i + bytesPerSequence <= end) {                                                                               // 645\n      var secondByte, thirdByte, fourthByte, tempCodePoint                                                           // 646\n                                                                                                                     // 647\n      switch (bytesPerSequence) {                                                                                    // 648\n        case 1:                                                                                                      // 649\n          if (firstByte < 0x80) {                                                                                    // 650\n            codePoint = firstByte                                                                                    // 651\n          }                                                                                                          // 652\n          break                                                                                                      // 653\n        case 2:                                                                                                      // 654\n          secondByte = buf[i + 1]                                                                                    // 655\n          if ((secondByte & 0xC0) === 0x80) {                                                                        // 656\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)                                          // 657\n            if (tempCodePoint > 0x7F) {                                                                              // 658\n              codePoint = tempCodePoint                                                                              // 659\n            }                                                                                                        // 660\n          }                                                                                                          // 661\n          break                                                                                                      // 662\n        case 3:                                                                                                      // 663\n          secondByte = buf[i + 1]                                                                                    // 664\n          thirdByte = buf[i + 2]                                                                                     // 665\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {                                         // 666\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)               // 667\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {                       // 668\n              codePoint = tempCodePoint                                                                              // 669\n            }                                                                                                        // 670\n          }                                                                                                          // 671\n          break                                                                                                      // 672\n        case 4:                                                                                                      // 673\n          secondByte = buf[i + 1]                                                                                    // 674\n          thirdByte = buf[i + 2]                                                                                     // 675\n          fourthByte = buf[i + 3]                                                                                    // 676\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {         // 677\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {                                                // 679\n              codePoint = tempCodePoint                                                                              // 680\n            }                                                                                                        // 681\n          }                                                                                                          // 682\n      }                                                                                                              // 683\n    }                                                                                                                // 684\n                                                                                                                     // 685\n    if (codePoint === null) {                                                                                        // 686\n      // we did not generate a valid codePoint so insert a                                                           // 687\n      // replacement char (U+FFFD) and advance only 1 byte                                                           // 688\n      codePoint = 0xFFFD                                                                                             // 689\n      bytesPerSequence = 1                                                                                           // 690\n    } else if (codePoint > 0xFFFF) {                                                                                 // 691\n      // encode to utf16 (surrogate pair dance)                                                                      // 692\n      codePoint -= 0x10000                                                                                           // 693\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)                                                                    // 694\n      codePoint = 0xDC00 | codePoint & 0x3FF                                                                         // 695\n    }                                                                                                                // 696\n                                                                                                                     // 697\n    res.push(codePoint)                                                                                              // 698\n    i += bytesPerSequence                                                                                            // 699\n  }                                                                                                                  // 700\n                                                                                                                     // 701\n  return decodeCodePointsArray(res)                                                                                  // 702\n}                                                                                                                    // 703\n                                                                                                                     // 704\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with                                             // 705\n// the lowest limit is Chrome, with 0x10000 args.                                                                    // 706\n// We go 1 magnitude less, for safety                                                                                // 707\nvar MAX_ARGUMENTS_LENGTH = 0x1000                                                                                    // 708\n                                                                                                                     // 709\nfunction decodeCodePointsArray (codePoints) {                                                                        // 710\n  var len = codePoints.length                                                                                        // 711\n  if (len <= MAX_ARGUMENTS_LENGTH) {                                                                                 // 712\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()                                      // 713\n  }                                                                                                                  // 714\n                                                                                                                     // 715\n  // Decode in chunks to avoid \"call stack size exceeded\".                                                           // 716\n  var res = ''                                                                                                       // 717\n  var i = 0                                                                                                          // 718\n  while (i < len) {                                                                                                  // 719\n    res += String.fromCharCode.apply(                                                                                // 720\n      String,                                                                                                        // 721\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)                                                                 // 722\n    )                                                                                                                // 723\n  }                                                                                                                  // 724\n  return res                                                                                                         // 725\n}                                                                                                                    // 726\n                                                                                                                     // 727\nfunction asciiSlice (buf, start, end) {                                                                              // 728\n  var ret = ''                                                                                                       // 729\n  end = Math.min(buf.length, end)                                                                                    // 730\n                                                                                                                     // 731\n  for (var i = start; i < end; i++) {                                                                                // 732\n    ret += String.fromCharCode(buf[i] & 0x7F)                                                                        // 733\n  }                                                                                                                  // 734\n  return ret                                                                                                         // 735\n}                                                                                                                    // 736\n                                                                                                                     // 737\nfunction binarySlice (buf, start, end) {                                                                             // 738\n  var ret = ''                                                                                                       // 739\n  end = Math.min(buf.length, end)                                                                                    // 740\n                                                                                                                     // 741\n  for (var i = start; i < end; i++) {                                                                                // 742\n    ret += String.fromCharCode(buf[i])                                                                               // 743\n  }                                                                                                                  // 744\n  return ret                                                                                                         // 745\n}                                                                                                                    // 746\n                                                                                                                     // 747\nfunction hexSlice (buf, start, end) {                                                                                // 748\n  var len = buf.length                                                                                               // 749\n                                                                                                                     // 750\n  if (!start || start < 0) start = 0                                                                                 // 751\n  if (!end || end < 0 || end > len) end = len                                                                        // 752\n                                                                                                                     // 753\n  var out = ''                                                                                                       // 754\n  for (var i = start; i < end; i++) {                                                                                // 755\n    out += toHex(buf[i])                                                                                             // 756\n  }                                                                                                                  // 757\n  return out                                                                                                         // 758\n}                                                                                                                    // 759\n                                                                                                                     // 760\nfunction utf16leSlice (buf, start, end) {                                                                            // 761\n  var bytes = buf.slice(start, end)                                                                                  // 762\n  var res = ''                                                                                                       // 763\n  for (var i = 0; i < bytes.length; i += 2) {                                                                        // 764\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)                                                        // 765\n  }                                                                                                                  // 766\n  return res                                                                                                         // 767\n}                                                                                                                    // 768\n                                                                                                                     // 769\nBuffer.prototype.slice = function slice (start, end) {                                                               // 770\n  var len = this.length                                                                                              // 771\n  start = ~~start                                                                                                    // 772\n  end = end === undefined ? len : ~~end                                                                              // 773\n                                                                                                                     // 774\n  if (start < 0) {                                                                                                   // 775\n    start += len                                                                                                     // 776\n    if (start < 0) start = 0                                                                                         // 777\n  } else if (start > len) {                                                                                          // 778\n    start = len                                                                                                      // 779\n  }                                                                                                                  // 780\n                                                                                                                     // 781\n  if (end < 0) {                                                                                                     // 782\n    end += len                                                                                                       // 783\n    if (end < 0) end = 0                                                                                             // 784\n  } else if (end > len) {                                                                                            // 785\n    end = len                                                                                                        // 786\n  }                                                                                                                  // 787\n                                                                                                                     // 788\n  if (end < start) end = start                                                                                       // 789\n                                                                                                                     // 790\n  var newBuf                                                                                                         // 791\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                  // 792\n    newBuf = this.subarray(start, end)                                                                               // 793\n    newBuf.__proto__ = Buffer.prototype                                                                              // 794\n  } else {                                                                                                           // 795\n    var sliceLen = end - start                                                                                       // 796\n    newBuf = new Buffer(sliceLen, undefined)                                                                         // 797\n    for (var i = 0; i < sliceLen; i++) {                                                                             // 798\n      newBuf[i] = this[i + start]                                                                                    // 799\n    }                                                                                                                // 800\n  }                                                                                                                  // 801\n                                                                                                                     // 802\n  if (newBuf.length) newBuf.parent = this.parent || this                                                             // 803\n                                                                                                                     // 804\n  return newBuf                                                                                                      // 805\n}                                                                                                                    // 806\n                                                                                                                     // 807\n/*                                                                                                                   // 808\n * Need to make sure that buffer isn't trying to write out of bounds.                                                // 809\n */                                                                                                                  // 810\nfunction checkOffset (offset, ext, length) {                                                                         // 811\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')                                   // 812\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')                           // 813\n}                                                                                                                    // 814\n                                                                                                                     // 815\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {                                   // 816\n  offset = offset | 0                                                                                                // 817\n  byteLength = byteLength | 0                                                                                        // 818\n  if (!noAssert) checkOffset(offset, byteLength, this.length)                                                        // 819\n                                                                                                                     // 820\n  var val = this[offset]                                                                                             // 821\n  var mul = 1                                                                                                        // 822\n  var i = 0                                                                                                          // 823\n  while (++i < byteLength && (mul *= 0x100)) {                                                                       // 824\n    val += this[offset + i] * mul                                                                                    // 825\n  }                                                                                                                  // 826\n                                                                                                                     // 827\n  return val                                                                                                         // 828\n}                                                                                                                    // 829\n                                                                                                                     // 830\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {                                   // 831\n  offset = offset | 0                                                                                                // 832\n  byteLength = byteLength | 0                                                                                        // 833\n  if (!noAssert) {                                                                                                   // 834\n    checkOffset(offset, byteLength, this.length)                                                                     // 835\n  }                                                                                                                  // 836\n                                                                                                                     // 837\n  var val = this[offset + --byteLength]                                                                              // 838\n  var mul = 1                                                                                                        // 839\n  while (byteLength > 0 && (mul *= 0x100)) {                                                                         // 840\n    val += this[offset + --byteLength] * mul                                                                         // 841\n  }                                                                                                                  // 842\n                                                                                                                     // 843\n  return val                                                                                                         // 844\n}                                                                                                                    // 845\n                                                                                                                     // 846\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {                                                 // 847\n  if (!noAssert) checkOffset(offset, 1, this.length)                                                                 // 848\n  return this[offset]                                                                                                // 849\n}                                                                                                                    // 850\n                                                                                                                     // 851\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {                                           // 852\n  if (!noAssert) checkOffset(offset, 2, this.length)                                                                 // 853\n  return this[offset] | (this[offset + 1] << 8)                                                                      // 854\n}                                                                                                                    // 855\n                                                                                                                     // 856\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {                                           // 857\n  if (!noAssert) checkOffset(offset, 2, this.length)                                                                 // 858\n  return (this[offset] << 8) | this[offset + 1]                                                                      // 859\n}                                                                                                                    // 860\n                                                                                                                     // 861\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {                                           // 862\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                 // 863\n                                                                                                                     // 864\n  return ((this[offset]) |                                                                                           // 865\n      (this[offset + 1] << 8) |                                                                                      // 866\n      (this[offset + 2] << 16)) +                                                                                    // 867\n      (this[offset + 3] * 0x1000000)                                                                                 // 868\n}                                                                                                                    // 869\n                                                                                                                     // 870\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {                                           // 871\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                 // 872\n                                                                                                                     // 873\n  return (this[offset] * 0x1000000) +                                                                                // 874\n    ((this[offset + 1] << 16) |                                                                                      // 875\n    (this[offset + 2] << 8) |                                                                                        // 876\n    this[offset + 3])                                                                                                // 877\n}                                                                                                                    // 878\n                                                                                                                     // 879\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {                                     // 880\n  offset = offset | 0                                                                                                // 881\n  byteLength = byteLength | 0                                                                                        // 882\n  if (!noAssert) checkOffset(offset, byteLength, this.length)                                                        // 883\n                                                                                                                     // 884\n  var val = this[offset]                                                                                             // 885\n  var mul = 1                                                                                                        // 886\n  var i = 0                                                                                                          // 887\n  while (++i < byteLength && (mul *= 0x100)) {                                                                       // 888\n    val += this[offset + i] * mul                                                                                    // 889\n  }                                                                                                                  // 890\n  mul *= 0x80                                                                                                        // 891\n                                                                                                                     // 892\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)                                                                 // 893\n                                                                                                                     // 894\n  return val                                                                                                         // 895\n}                                                                                                                    // 896\n                                                                                                                     // 897\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {                                     // 898\n  offset = offset | 0                                                                                                // 899\n  byteLength = byteLength | 0                                                                                        // 900\n  if (!noAssert) checkOffset(offset, byteLength, this.length)                                                        // 901\n                                                                                                                     // 902\n  var i = byteLength                                                                                                 // 903\n  var mul = 1                                                                                                        // 904\n  var val = this[offset + --i]                                                                                       // 905\n  while (i > 0 && (mul *= 0x100)) {                                                                                  // 906\n    val += this[offset + --i] * mul                                                                                  // 907\n  }                                                                                                                  // 908\n  mul *= 0x80                                                                                                        // 909\n                                                                                                                     // 910\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)                                                                 // 911\n                                                                                                                     // 912\n  return val                                                                                                         // 913\n}                                                                                                                    // 914\n                                                                                                                     // 915\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {                                                   // 916\n  if (!noAssert) checkOffset(offset, 1, this.length)                                                                 // 917\n  if (!(this[offset] & 0x80)) return (this[offset])                                                                  // 918\n  return ((0xff - this[offset] + 1) * -1)                                                                            // 919\n}                                                                                                                    // 920\n                                                                                                                     // 921\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {                                             // 922\n  if (!noAssert) checkOffset(offset, 2, this.length)                                                                 // 923\n  var val = this[offset] | (this[offset + 1] << 8)                                                                   // 924\n  return (val & 0x8000) ? val | 0xFFFF0000 : val                                                                     // 925\n}                                                                                                                    // 926\n                                                                                                                     // 927\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {                                             // 928\n  if (!noAssert) checkOffset(offset, 2, this.length)                                                                 // 929\n  var val = this[offset + 1] | (this[offset] << 8)                                                                   // 930\n  return (val & 0x8000) ? val | 0xFFFF0000 : val                                                                     // 931\n}                                                                                                                    // 932\n                                                                                                                     // 933\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {                                             // 934\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                 // 935\n                                                                                                                     // 936\n  return (this[offset]) |                                                                                            // 937\n    (this[offset + 1] << 8) |                                                                                        // 938\n    (this[offset + 2] << 16) |                                                                                       // 939\n    (this[offset + 3] << 24)                                                                                         // 940\n}                                                                                                                    // 941\n                                                                                                                     // 942\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {                                             // 943\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                 // 944\n                                                                                                                     // 945\n  return (this[offset] << 24) |                                                                                      // 946\n    (this[offset + 1] << 16) |                                                                                       // 947\n    (this[offset + 2] << 8) |                                                                                        // 948\n    (this[offset + 3])                                                                                               // 949\n}                                                                                                                    // 950\n                                                                                                                     // 951\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {                                             // 952\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                 // 953\n  return ieee754.read(this, offset, true, 23, 4)                                                                     // 954\n}                                                                                                                    // 955\n                                                                                                                     // 956\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {                                             // 957\n  if (!noAssert) checkOffset(offset, 4, this.length)                                                                 // 958\n  return ieee754.read(this, offset, false, 23, 4)                                                                    // 959\n}                                                                                                                    // 960\n                                                                                                                     // 961\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {                                           // 962\n  if (!noAssert) checkOffset(offset, 8, this.length)                                                                 // 963\n  return ieee754.read(this, offset, true, 52, 8)                                                                     // 964\n}                                                                                                                    // 965\n                                                                                                                     // 966\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {                                           // 967\n  if (!noAssert) checkOffset(offset, 8, this.length)                                                                 // 968\n  return ieee754.read(this, offset, false, 52, 8)                                                                    // 969\n}                                                                                                                    // 970\n                                                                                                                     // 971\nfunction checkInt (buf, value, offset, ext, max, min) {                                                              // 972\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')                                 // 973\n  if (value > max || value < min) throw new RangeError('value is out of bounds')                                     // 974\n  if (offset + ext > buf.length) throw new RangeError('index out of range')                                          // 975\n}                                                                                                                    // 976\n                                                                                                                     // 977\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {                          // 978\n  value = +value                                                                                                     // 979\n  offset = offset | 0                                                                                                // 980\n  byteLength = byteLength | 0                                                                                        // 981\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)                           // 982\n                                                                                                                     // 983\n  var mul = 1                                                                                                        // 984\n  var i = 0                                                                                                          // 985\n  this[offset] = value & 0xFF                                                                                        // 986\n  while (++i < byteLength && (mul *= 0x100)) {                                                                       // 987\n    this[offset + i] = (value / mul) & 0xFF                                                                          // 988\n  }                                                                                                                  // 989\n                                                                                                                     // 990\n  return offset + byteLength                                                                                         // 991\n}                                                                                                                    // 992\n                                                                                                                     // 993\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {                          // 994\n  value = +value                                                                                                     // 995\n  offset = offset | 0                                                                                                // 996\n  byteLength = byteLength | 0                                                                                        // 997\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)                           // 998\n                                                                                                                     // 999\n  var i = byteLength - 1                                                                                             // 1000\n  var mul = 1                                                                                                        // 1001\n  this[offset + i] = value & 0xFF                                                                                    // 1002\n  while (--i >= 0 && (mul *= 0x100)) {                                                                               // 1003\n    this[offset + i] = (value / mul) & 0xFF                                                                          // 1004\n  }                                                                                                                  // 1005\n                                                                                                                     // 1006\n  return offset + byteLength                                                                                         // 1007\n}                                                                                                                    // 1008\n                                                                                                                     // 1009\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {                                        // 1010\n  value = +value                                                                                                     // 1011\n  offset = offset | 0                                                                                                // 1012\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)                                                           // 1013\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)                                                         // 1014\n  this[offset] = (value & 0xff)                                                                                      // 1015\n  return offset + 1                                                                                                  // 1016\n}                                                                                                                    // 1017\n                                                                                                                     // 1018\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {                                                      // 1019\n  if (value < 0) value = 0xffff + value + 1                                                                          // 1020\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {                                                // 1021\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>                                       // 1022\n      (littleEndian ? i : 1 - i) * 8                                                                                 // 1023\n  }                                                                                                                  // 1024\n}                                                                                                                    // 1025\n                                                                                                                     // 1026\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {                                  // 1027\n  value = +value                                                                                                     // 1028\n  offset = offset | 0                                                                                                // 1029\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)                                                         // 1030\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                  // 1031\n    this[offset] = (value & 0xff)                                                                                    // 1032\n    this[offset + 1] = (value >>> 8)                                                                                 // 1033\n  } else {                                                                                                           // 1034\n    objectWriteUInt16(this, value, offset, true)                                                                     // 1035\n  }                                                                                                                  // 1036\n  return offset + 2                                                                                                  // 1037\n}                                                                                                                    // 1038\n                                                                                                                     // 1039\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {                                  // 1040\n  value = +value                                                                                                     // 1041\n  offset = offset | 0                                                                                                // 1042\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)                                                         // 1043\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                  // 1044\n    this[offset] = (value >>> 8)                                                                                     // 1045\n    this[offset + 1] = (value & 0xff)                                                                                // 1046\n  } else {                                                                                                           // 1047\n    objectWriteUInt16(this, value, offset, false)                                                                    // 1048\n  }                                                                                                                  // 1049\n  return offset + 2                                                                                                  // 1050\n}                                                                                                                    // 1051\n                                                                                                                     // 1052\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {                                                      // 1053\n  if (value < 0) value = 0xffffffff + value + 1                                                                      // 1054\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {                                                // 1055\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff                                              // 1056\n  }                                                                                                                  // 1057\n}                                                                                                                    // 1058\n                                                                                                                     // 1059\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {                                  // 1060\n  value = +value                                                                                                     // 1061\n  offset = offset | 0                                                                                                // 1062\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)                                                     // 1063\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                  // 1064\n    this[offset + 3] = (value >>> 24)                                                                                // 1065\n    this[offset + 2] = (value >>> 16)                                                                                // 1066\n    this[offset + 1] = (value >>> 8)                                                                                 // 1067\n    this[offset] = (value & 0xff)                                                                                    // 1068\n  } else {                                                                                                           // 1069\n    objectWriteUInt32(this, value, offset, true)                                                                     // 1070\n  }                                                                                                                  // 1071\n  return offset + 4                                                                                                  // 1072\n}                                                                                                                    // 1073\n                                                                                                                     // 1074\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {                                  // 1075\n  value = +value                                                                                                     // 1076\n  offset = offset | 0                                                                                                // 1077\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)                                                     // 1078\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                  // 1079\n    this[offset] = (value >>> 24)                                                                                    // 1080\n    this[offset + 1] = (value >>> 16)                                                                                // 1081\n    this[offset + 2] = (value >>> 8)                                                                                 // 1082\n    this[offset + 3] = (value & 0xff)                                                                                // 1083\n  } else {                                                                                                           // 1084\n    objectWriteUInt32(this, value, offset, false)                                                                    // 1085\n  }                                                                                                                  // 1086\n  return offset + 4                                                                                                  // 1087\n}                                                                                                                    // 1088\n                                                                                                                     // 1089\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {                            // 1090\n  value = +value                                                                                                     // 1091\n  offset = offset | 0                                                                                                // 1092\n  if (!noAssert) {                                                                                                   // 1093\n    var limit = Math.pow(2, 8 * byteLength - 1)                                                                      // 1094\n                                                                                                                     // 1095\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)                                                     // 1096\n  }                                                                                                                  // 1097\n                                                                                                                     // 1098\n  var i = 0                                                                                                          // 1099\n  var mul = 1                                                                                                        // 1100\n  var sub = value < 0 ? 1 : 0                                                                                        // 1101\n  this[offset] = value & 0xFF                                                                                        // 1102\n  while (++i < byteLength && (mul *= 0x100)) {                                                                       // 1103\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF                                                             // 1104\n  }                                                                                                                  // 1105\n                                                                                                                     // 1106\n  return offset + byteLength                                                                                         // 1107\n}                                                                                                                    // 1108\n                                                                                                                     // 1109\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {                            // 1110\n  value = +value                                                                                                     // 1111\n  offset = offset | 0                                                                                                // 1112\n  if (!noAssert) {                                                                                                   // 1113\n    var limit = Math.pow(2, 8 * byteLength - 1)                                                                      // 1114\n                                                                                                                     // 1115\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)                                                     // 1116\n  }                                                                                                                  // 1117\n                                                                                                                     // 1118\n  var i = byteLength - 1                                                                                             // 1119\n  var mul = 1                                                                                                        // 1120\n  var sub = value < 0 ? 1 : 0                                                                                        // 1121\n  this[offset + i] = value & 0xFF                                                                                    // 1122\n  while (--i >= 0 && (mul *= 0x100)) {                                                                               // 1123\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF                                                             // 1124\n  }                                                                                                                  // 1125\n                                                                                                                     // 1126\n  return offset + byteLength                                                                                         // 1127\n}                                                                                                                    // 1128\n                                                                                                                     // 1129\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {                                          // 1130\n  value = +value                                                                                                     // 1131\n  offset = offset | 0                                                                                                // 1132\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)                                                       // 1133\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)                                                         // 1134\n  if (value < 0) value = 0xff + value + 1                                                                            // 1135\n  this[offset] = (value & 0xff)                                                                                      // 1136\n  return offset + 1                                                                                                  // 1137\n}                                                                                                                    // 1138\n                                                                                                                     // 1139\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {                                    // 1140\n  value = +value                                                                                                     // 1141\n  offset = offset | 0                                                                                                // 1142\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)                                                   // 1143\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                  // 1144\n    this[offset] = (value & 0xff)                                                                                    // 1145\n    this[offset + 1] = (value >>> 8)                                                                                 // 1146\n  } else {                                                                                                           // 1147\n    objectWriteUInt16(this, value, offset, true)                                                                     // 1148\n  }                                                                                                                  // 1149\n  return offset + 2                                                                                                  // 1150\n}                                                                                                                    // 1151\n                                                                                                                     // 1152\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {                                    // 1153\n  value = +value                                                                                                     // 1154\n  offset = offset | 0                                                                                                // 1155\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)                                                   // 1156\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                  // 1157\n    this[offset] = (value >>> 8)                                                                                     // 1158\n    this[offset + 1] = (value & 0xff)                                                                                // 1159\n  } else {                                                                                                           // 1160\n    objectWriteUInt16(this, value, offset, false)                                                                    // 1161\n  }                                                                                                                  // 1162\n  return offset + 2                                                                                                  // 1163\n}                                                                                                                    // 1164\n                                                                                                                     // 1165\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {                                    // 1166\n  value = +value                                                                                                     // 1167\n  offset = offset | 0                                                                                                // 1168\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)                                           // 1169\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                  // 1170\n    this[offset] = (value & 0xff)                                                                                    // 1171\n    this[offset + 1] = (value >>> 8)                                                                                 // 1172\n    this[offset + 2] = (value >>> 16)                                                                                // 1173\n    this[offset + 3] = (value >>> 24)                                                                                // 1174\n  } else {                                                                                                           // 1175\n    objectWriteUInt32(this, value, offset, true)                                                                     // 1176\n  }                                                                                                                  // 1177\n  return offset + 4                                                                                                  // 1178\n}                                                                                                                    // 1179\n                                                                                                                     // 1180\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {                                    // 1181\n  value = +value                                                                                                     // 1182\n  offset = offset | 0                                                                                                // 1183\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)                                           // 1184\n  if (value < 0) value = 0xffffffff + value + 1                                                                      // 1185\n  if (Buffer.TYPED_ARRAY_SUPPORT) {                                                                                  // 1186\n    this[offset] = (value >>> 24)                                                                                    // 1187\n    this[offset + 1] = (value >>> 16)                                                                                // 1188\n    this[offset + 2] = (value >>> 8)                                                                                 // 1189\n    this[offset + 3] = (value & 0xff)                                                                                // 1190\n  } else {                                                                                                           // 1191\n    objectWriteUInt32(this, value, offset, false)                                                                    // 1192\n  }                                                                                                                  // 1193\n  return offset + 4                                                                                                  // 1194\n}                                                                                                                    // 1195\n                                                                                                                     // 1196\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {                                                          // 1197\n  if (offset + ext > buf.length) throw new RangeError('index out of range')                                          // 1198\n  if (offset < 0) throw new RangeError('index out of range')                                                         // 1199\n}                                                                                                                    // 1200\n                                                                                                                     // 1201\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {                                                   // 1202\n  if (!noAssert) {                                                                                                   // 1203\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)                             // 1204\n  }                                                                                                                  // 1205\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)                                                             // 1206\n  return offset + 4                                                                                                  // 1207\n}                                                                                                                    // 1208\n                                                                                                                     // 1209\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {                                    // 1210\n  return writeFloat(this, value, offset, true, noAssert)                                                             // 1211\n}                                                                                                                    // 1212\n                                                                                                                     // 1213\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {                                    // 1214\n  return writeFloat(this, value, offset, false, noAssert)                                                            // 1215\n}                                                                                                                    // 1216\n                                                                                                                     // 1217\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {                                                  // 1218\n  if (!noAssert) {                                                                                                   // 1219\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)                           // 1220\n  }                                                                                                                  // 1221\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)                                                             // 1222\n  return offset + 8                                                                                                  // 1223\n}                                                                                                                    // 1224\n                                                                                                                     // 1225\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {                                  // 1226\n  return writeDouble(this, value, offset, true, noAssert)                                                            // 1227\n}                                                                                                                    // 1228\n                                                                                                                     // 1229\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {                                  // 1230\n  return writeDouble(this, value, offset, false, noAssert)                                                           // 1231\n}                                                                                                                    // 1232\n                                                                                                                     // 1233\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)                                         // 1234\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {                                            // 1235\n  if (!start) start = 0                                                                                              // 1236\n  if (!end && end !== 0) end = this.length                                                                           // 1237\n  if (targetStart >= target.length) targetStart = target.length                                                      // 1238\n  if (!targetStart) targetStart = 0                                                                                  // 1239\n  if (end > 0 && end < start) end = start                                                                            // 1240\n                                                                                                                     // 1241\n  // Copy 0 bytes; we're done                                                                                        // 1242\n  if (end === start) return 0                                                                                        // 1243\n  if (target.length === 0 || this.length === 0) return 0                                                             // 1244\n                                                                                                                     // 1245\n  // Fatal error conditions                                                                                          // 1246\n  if (targetStart < 0) {                                                                                             // 1247\n    throw new RangeError('targetStart out of bounds')                                                                // 1248\n  }                                                                                                                  // 1249\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')                           // 1250\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')                                                       // 1251\n                                                                                                                     // 1252\n  // Are we oob?                                                                                                     // 1253\n  if (end > this.length) end = this.length                                                                           // 1254\n  if (target.length - targetStart < end - start) {                                                                   // 1255\n    end = target.length - targetStart + start                                                                        // 1256\n  }                                                                                                                  // 1257\n                                                                                                                     // 1258\n  var len = end - start                                                                                              // 1259\n  var i                                                                                                              // 1260\n                                                                                                                     // 1261\n  if (this === target && start < targetStart && targetStart < end) {                                                 // 1262\n    // descending copy from end                                                                                      // 1263\n    for (i = len - 1; i >= 0; i--) {                                                                                 // 1264\n      target[i + targetStart] = this[i + start]                                                                      // 1265\n    }                                                                                                                // 1266\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {                                                            // 1267\n    // ascending copy from start                                                                                     // 1268\n    for (i = 0; i < len; i++) {                                                                                      // 1269\n      target[i + targetStart] = this[i + start]                                                                      // 1270\n    }                                                                                                                // 1271\n  } else {                                                                                                           // 1272\n    Uint8Array.prototype.set.call(                                                                                   // 1273\n      target,                                                                                                        // 1274\n      this.subarray(start, start + len),                                                                             // 1275\n      targetStart                                                                                                    // 1276\n    )                                                                                                                // 1277\n  }                                                                                                                  // 1278\n                                                                                                                     // 1279\n  return len                                                                                                         // 1280\n}                                                                                                                    // 1281\n                                                                                                                     // 1282\n// fill(value, start=0, end=buffer.length)                                                                           // 1283\nBuffer.prototype.fill = function fill (value, start, end) {                                                          // 1284\n  if (!value) value = 0                                                                                              // 1285\n  if (!start) start = 0                                                                                              // 1286\n  if (!end) end = this.length                                                                                        // 1287\n                                                                                                                     // 1288\n  if (end < start) throw new RangeError('end < start')                                                               // 1289\n                                                                                                                     // 1290\n  // Fill 0 bytes; we're done                                                                                        // 1291\n  if (end === start) return                                                                                          // 1292\n  if (this.length === 0) return                                                                                      // 1293\n                                                                                                                     // 1294\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')                                 // 1295\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')                                        // 1296\n                                                                                                                     // 1297\n  var i                                                                                                              // 1298\n  if (typeof value === 'number') {                                                                                   // 1299\n    for (i = start; i < end; i++) {                                                                                  // 1300\n      this[i] = value                                                                                                // 1301\n    }                                                                                                                // 1302\n  } else {                                                                                                           // 1303\n    var bytes = utf8ToBytes(value.toString())                                                                        // 1304\n    var len = bytes.length                                                                                           // 1305\n    for (i = start; i < end; i++) {                                                                                  // 1306\n      this[i] = bytes[i % len]                                                                                       // 1307\n    }                                                                                                                // 1308\n  }                                                                                                                  // 1309\n                                                                                                                     // 1310\n  return this                                                                                                        // 1311\n}                                                                                                                    // 1312\n                                                                                                                     // 1313\n// HELPER FUNCTIONS                                                                                                  // 1314\n// ================                                                                                                  // 1315\n                                                                                                                     // 1316\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g                                                                         // 1317\n                                                                                                                     // 1318\nfunction base64clean (str) {                                                                                         // 1319\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not                           // 1320\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')                                                               // 1321\n  // Node converts strings with length < 2 to ''                                                                     // 1322\n  if (str.length < 2) return ''                                                                                      // 1323\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not                            // 1324\n  while (str.length % 4 !== 0) {                                                                                     // 1325\n    str = str + '='                                                                                                  // 1326\n  }                                                                                                                  // 1327\n  return str                                                                                                         // 1328\n}                                                                                                                    // 1329\n                                                                                                                     // 1330\nfunction stringtrim (str) {                                                                                          // 1331\n  if (str.trim) return str.trim()                                                                                    // 1332\n  return str.replace(/^\\s+|\\s+$/g, '')                                                                               // 1333\n}                                                                                                                    // 1334\n                                                                                                                     // 1335\nfunction toHex (n) {                                                                                                 // 1336\n  if (n < 16) return '0' + n.toString(16)                                                                            // 1337\n  return n.toString(16)                                                                                              // 1338\n}                                                                                                                    // 1339\n                                                                                                                     // 1340\nfunction utf8ToBytes (string, units) {                                                                               // 1341\n  units = units || Infinity                                                                                          // 1342\n  var codePoint                                                                                                      // 1343\n  var length = string.length                                                                                         // 1344\n  var leadSurrogate = null                                                                                           // 1345\n  var bytes = []                                                                                                     // 1346\n                                                                                                                     // 1347\n  for (var i = 0; i < length; i++) {                                                                                 // 1348\n    codePoint = string.charCodeAt(i)                                                                                 // 1349\n                                                                                                                     // 1350\n    // is surrogate component                                                                                        // 1351\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {                                                                  // 1352\n      // last char was a lead                                                                                        // 1353\n      if (!leadSurrogate) {                                                                                          // 1354\n        // no lead yet                                                                                               // 1355\n        if (codePoint > 0xDBFF) {                                                                                    // 1356\n          // unexpected trail                                                                                        // 1357\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)                                                        // 1358\n          continue                                                                                                   // 1359\n        } else if (i + 1 === length) {                                                                               // 1360\n          // unpaired lead                                                                                           // 1361\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)                                                        // 1362\n          continue                                                                                                   // 1363\n        }                                                                                                            // 1364\n                                                                                                                     // 1365\n        // valid lead                                                                                                // 1366\n        leadSurrogate = codePoint                                                                                    // 1367\n                                                                                                                     // 1368\n        continue                                                                                                     // 1369\n      }                                                                                                              // 1370\n                                                                                                                     // 1371\n      // 2 leads in a row                                                                                            // 1372\n      if (codePoint < 0xDC00) {                                                                                      // 1373\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)                                                          // 1374\n        leadSurrogate = codePoint                                                                                    // 1375\n        continue                                                                                                     // 1376\n      }                                                                                                              // 1377\n                                                                                                                     // 1378\n      // valid surrogate pair                                                                                        // 1379\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000                                      // 1380\n    } else if (leadSurrogate) {                                                                                      // 1381\n      // valid bmp char, but last char was a lead                                                                    // 1382\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)                                                            // 1383\n    }                                                                                                                // 1384\n                                                                                                                     // 1385\n    leadSurrogate = null                                                                                             // 1386\n                                                                                                                     // 1387\n    // encode utf8                                                                                                   // 1388\n    if (codePoint < 0x80) {                                                                                          // 1389\n      if ((units -= 1) < 0) break                                                                                    // 1390\n      bytes.push(codePoint)                                                                                          // 1391\n    } else if (codePoint < 0x800) {                                                                                  // 1392\n      if ((units -= 2) < 0) break                                                                                    // 1393\n      bytes.push(                                                                                                    // 1394\n        codePoint >> 0x6 | 0xC0,                                                                                     // 1395\n        codePoint & 0x3F | 0x80                                                                                      // 1396\n      )                                                                                                              // 1397\n    } else if (codePoint < 0x10000) {                                                                                // 1398\n      if ((units -= 3) < 0) break                                                                                    // 1399\n      bytes.push(                                                                                                    // 1400\n        codePoint >> 0xC | 0xE0,                                                                                     // 1401\n        codePoint >> 0x6 & 0x3F | 0x80,                                                                              // 1402\n        codePoint & 0x3F | 0x80                                                                                      // 1403\n      )                                                                                                              // 1404\n    } else if (codePoint < 0x110000) {                                                                               // 1405\n      if ((units -= 4) < 0) break                                                                                    // 1406\n      bytes.push(                                                                                                    // 1407\n        codePoint >> 0x12 | 0xF0,                                                                                    // 1408\n        codePoint >> 0xC & 0x3F | 0x80,                                                                              // 1409\n        codePoint >> 0x6 & 0x3F | 0x80,                                                                              // 1410\n        codePoint & 0x3F | 0x80                                                                                      // 1411\n      )                                                                                                              // 1412\n    } else {                                                                                                         // 1413\n      throw new Error('Invalid code point')                                                                          // 1414\n    }                                                                                                                // 1415\n  }                                                                                                                  // 1416\n                                                                                                                     // 1417\n  return bytes                                                                                                       // 1418\n}                                                                                                                    // 1419\n                                                                                                                     // 1420\nfunction asciiToBytes (str) {                                                                                        // 1421\n  var byteArray = []                                                                                                 // 1422\n  for (var i = 0; i < str.length; i++) {                                                                             // 1423\n    // Node's code seems to be doing this and not & 0x7F..                                                           // 1424\n    byteArray.push(str.charCodeAt(i) & 0xFF)                                                                         // 1425\n  }                                                                                                                  // 1426\n  return byteArray                                                                                                   // 1427\n}                                                                                                                    // 1428\n                                                                                                                     // 1429\nfunction utf16leToBytes (str, units) {                                                                               // 1430\n  var c, hi, lo                                                                                                      // 1431\n  var byteArray = []                                                                                                 // 1432\n  for (var i = 0; i < str.length; i++) {                                                                             // 1433\n    if ((units -= 2) < 0) break                                                                                      // 1434\n                                                                                                                     // 1435\n    c = str.charCodeAt(i)                                                                                            // 1436\n    hi = c >> 8                                                                                                      // 1437\n    lo = c % 256                                                                                                     // 1438\n    byteArray.push(lo)                                                                                               // 1439\n    byteArray.push(hi)                                                                                               // 1440\n  }                                                                                                                  // 1441\n                                                                                                                     // 1442\n  return byteArray                                                                                                   // 1443\n}                                                                                                                    // 1444\n                                                                                                                     // 1445\nfunction base64ToBytes (str) {                                                                                       // 1446\n  return base64.toByteArray(base64clean(str))                                                                        // 1447\n}                                                                                                                    // 1448\n                                                                                                                     // 1449\nfunction blitBuffer (src, dst, offset, length) {                                                                     // 1450\n  for (var i = 0; i < length; i++) {                                                                                 // 1451\n    if ((i + offset >= dst.length) || (i >= src.length)) break                                                       // 1452\n    dst[i + offset] = src[i]                                                                                         // 1453\n  }                                                                                                                  // 1454\n  return i                                                                                                           // 1455\n}                                                                                                                    // 1456\n                                                                                                                     // 1457\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"base64-js\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/buffer/node_modules/base64-js/package.json                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"base64-js\";                                                                                          // 1\nexports.version = \"1.1.2\";                                                                                           // 2\nexports.main = \"lib/b64.js\";                                                                                         // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lib\":{\"b64.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/buffer/node_modules/base64-js/lib/b64.js                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n'use strict'                                                                                                         // 1\n                                                                                                                     // 2\nexports.toByteArray = toByteArray                                                                                    // 3\nexports.fromByteArray = fromByteArray                                                                                // 4\n                                                                                                                     // 5\nvar lookup = []                                                                                                      // 6\nvar revLookup = []                                                                                                   // 7\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array                                                     // 8\n                                                                                                                     // 9\nfunction init () {                                                                                                   // 10\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'                                      // 11\n  for (var i = 0, len = code.length; i < len; ++i) {                                                                 // 12\n    lookup[i] = code[i]                                                                                              // 13\n    revLookup[code.charCodeAt(i)] = i                                                                                // 14\n  }                                                                                                                  // 15\n                                                                                                                     // 16\n  revLookup['-'.charCodeAt(0)] = 62                                                                                  // 17\n  revLookup['_'.charCodeAt(0)] = 63                                                                                  // 18\n}                                                                                                                    // 19\n                                                                                                                     // 20\ninit()                                                                                                               // 21\n                                                                                                                     // 22\nfunction toByteArray (b64) {                                                                                         // 23\n  var i, j, l, tmp, placeHolders, arr                                                                                // 24\n  var len = b64.length                                                                                               // 25\n                                                                                                                     // 26\n  if (len % 4 > 0) {                                                                                                 // 27\n    throw new Error('Invalid string. Length must be a multiple of 4')                                                // 28\n  }                                                                                                                  // 29\n                                                                                                                     // 30\n  // the number of equal signs (place holders)                                                                       // 31\n  // if there are two placeholders, than the two characters before it                                                // 32\n  // represent one byte                                                                                              // 33\n  // if there is only one, then the three characters before it represent 2 bytes                                     // 34\n  // this is just a cheap hack to not do indexOf twice                                                               // 35\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0                                             // 36\n                                                                                                                     // 37\n  // base64 is 4/3 + up to two characters of the original data                                                       // 38\n  arr = new Arr(len * 3 / 4 - placeHolders)                                                                          // 39\n                                                                                                                     // 40\n  // if there are placeholders, only get up to the last complete 4 chars                                             // 41\n  l = placeHolders > 0 ? len - 4 : len                                                                               // 42\n                                                                                                                     // 43\n  var L = 0                                                                                                          // 44\n                                                                                                                     // 45\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {                                                                        // 46\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF                                                                                    // 48\n    arr[L++] = (tmp >> 8) & 0xFF                                                                                     // 49\n    arr[L++] = tmp & 0xFF                                                                                            // 50\n  }                                                                                                                  // 51\n                                                                                                                     // 52\n  if (placeHolders === 2) {                                                                                          // 53\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)                              // 54\n    arr[L++] = tmp & 0xFF                                                                                            // 55\n  } else if (placeHolders === 1) {                                                                                   // 56\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF                                                                                     // 58\n    arr[L++] = tmp & 0xFF                                                                                            // 59\n  }                                                                                                                  // 60\n                                                                                                                     // 61\n  return arr                                                                                                         // 62\n}                                                                                                                    // 63\n                                                                                                                     // 64\nfunction tripletToBase64 (num) {                                                                                     // 65\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]          // 66\n}                                                                                                                    // 67\n                                                                                                                     // 68\nfunction encodeChunk (uint8, start, end) {                                                                           // 69\n  var tmp                                                                                                            // 70\n  var output = []                                                                                                    // 71\n  for (var i = start; i < end; i += 3) {                                                                             // 72\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])                                                    // 73\n    output.push(tripletToBase64(tmp))                                                                                // 74\n  }                                                                                                                  // 75\n  return output.join('')                                                                                             // 76\n}                                                                                                                    // 77\n                                                                                                                     // 78\nfunction fromByteArray (uint8) {                                                                                     // 79\n  var tmp                                                                                                            // 80\n  var len = uint8.length                                                                                             // 81\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes                                                    // 82\n  var output = ''                                                                                                    // 83\n  var parts = []                                                                                                     // 84\n  var maxChunkLength = 16383 // must be multiple of 3                                                                // 85\n                                                                                                                     // 86\n  // go through the array every three bytes, we'll deal with trailing stuff later                                    // 87\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {                                          // 88\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))                     // 89\n  }                                                                                                                  // 90\n                                                                                                                     // 91\n  // pad the end with zeros, but make sure to not forget the extra bytes                                             // 92\n  if (extraBytes === 1) {                                                                                            // 93\n    tmp = uint8[len - 1]                                                                                             // 94\n    output += lookup[tmp >> 2]                                                                                       // 95\n    output += lookup[(tmp << 4) & 0x3F]                                                                              // 96\n    output += '=='                                                                                                   // 97\n  } else if (extraBytes === 2) {                                                                                     // 98\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])                                                                   // 99\n    output += lookup[tmp >> 10]                                                                                      // 100\n    output += lookup[(tmp >> 4) & 0x3F]                                                                              // 101\n    output += lookup[(tmp << 2) & 0x3F]                                                                              // 102\n    output += '='                                                                                                    // 103\n  }                                                                                                                  // 104\n                                                                                                                     // 105\n  parts.push(output)                                                                                                 // 106\n                                                                                                                     // 107\n  return parts.join('')                                                                                              // 108\n}                                                                                                                    // 109\n                                                                                                                     // 110\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"ieee754\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/buffer/node_modules/ieee754/package.json                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"ieee754\";                                                                                            // 1\nexports.version = \"1.1.6\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/buffer/node_modules/ieee754/index.js                                  //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {                                                       // 1\n  var e, m                                                                                                           // 2\n  var eLen = nBytes * 8 - mLen - 1                                                                                   // 3\n  var eMax = (1 << eLen) - 1                                                                                         // 4\n  var eBias = eMax >> 1                                                                                              // 5\n  var nBits = -7                                                                                                     // 6\n  var i = isLE ? (nBytes - 1) : 0                                                                                    // 7\n  var d = isLE ? -1 : 1                                                                                              // 8\n  var s = buffer[offset + i]                                                                                         // 9\n                                                                                                                     // 10\n  i += d                                                                                                             // 11\n                                                                                                                     // 12\n  e = s & ((1 << (-nBits)) - 1)                                                                                      // 13\n  s >>= (-nBits)                                                                                                     // 14\n  nBits += eLen                                                                                                      // 15\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}                                         // 16\n                                                                                                                     // 17\n  m = e & ((1 << (-nBits)) - 1)                                                                                      // 18\n  e >>= (-nBits)                                                                                                     // 19\n  nBits += mLen                                                                                                      // 20\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}                                         // 21\n                                                                                                                     // 22\n  if (e === 0) {                                                                                                     // 23\n    e = 1 - eBias                                                                                                    // 24\n  } else if (e === eMax) {                                                                                           // 25\n    return m ? NaN : ((s ? -1 : 1) * Infinity)                                                                       // 26\n  } else {                                                                                                           // 27\n    m = m + Math.pow(2, mLen)                                                                                        // 28\n    e = e - eBias                                                                                                    // 29\n  }                                                                                                                  // 30\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)                                                                    // 31\n}                                                                                                                    // 32\n                                                                                                                     // 33\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {                                               // 34\n  var e, m, c                                                                                                        // 35\n  var eLen = nBytes * 8 - mLen - 1                                                                                   // 36\n  var eMax = (1 << eLen) - 1                                                                                         // 37\n  var eBias = eMax >> 1                                                                                              // 38\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)                                                   // 39\n  var i = isLE ? 0 : (nBytes - 1)                                                                                    // 40\n  var d = isLE ? 1 : -1                                                                                              // 41\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0                                                        // 42\n                                                                                                                     // 43\n  value = Math.abs(value)                                                                                            // 44\n                                                                                                                     // 45\n  if (isNaN(value) || value === Infinity) {                                                                          // 46\n    m = isNaN(value) ? 1 : 0                                                                                         // 47\n    e = eMax                                                                                                         // 48\n  } else {                                                                                                           // 49\n    e = Math.floor(Math.log(value) / Math.LN2)                                                                       // 50\n    if (value * (c = Math.pow(2, -e)) < 1) {                                                                         // 51\n      e--                                                                                                            // 52\n      c *= 2                                                                                                         // 53\n    }                                                                                                                // 54\n    if (e + eBias >= 1) {                                                                                            // 55\n      value += rt / c                                                                                                // 56\n    } else {                                                                                                         // 57\n      value += rt * Math.pow(2, 1 - eBias)                                                                           // 58\n    }                                                                                                                // 59\n    if (value * c >= 2) {                                                                                            // 60\n      e++                                                                                                            // 61\n      c /= 2                                                                                                         // 62\n    }                                                                                                                // 63\n                                                                                                                     // 64\n    if (e + eBias >= eMax) {                                                                                         // 65\n      m = 0                                                                                                          // 66\n      e = eMax                                                                                                       // 67\n    } else if (e + eBias >= 1) {                                                                                     // 68\n      m = (value * c - 1) * Math.pow(2, mLen)                                                                        // 69\n      e = e + eBias                                                                                                  // 70\n    } else {                                                                                                         // 71\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)                                                         // 72\n      e = 0                                                                                                          // 73\n    }                                                                                                                // 74\n  }                                                                                                                  // 75\n                                                                                                                     // 76\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}                                   // 77\n                                                                                                                     // 78\n  e = (e << mLen) | m                                                                                                // 79\n  eLen += mLen                                                                                                       // 80\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}                                    // 81\n                                                                                                                     // 82\n  buffer[offset + i - d] |= s * 128                                                                                  // 83\n}                                                                                                                    // 84\n                                                                                                                     // 85\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"isarray\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/buffer/node_modules/isarray/package.json                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"isarray\";                                                                                            // 1\nexports.version = \"1.0.0\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/buffer/node_modules/isarray/index.js                                  //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar toString = {}.toString;                                                                                          // 1\n                                                                                                                     // 2\nmodule.exports = Array.isArray || function (arr) {                                                                   // 3\n  return toString.call(arr) == '[object Array]';                                                                     // 4\n};                                                                                                                   // 5\n                                                                                                                     // 6\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}},\"util\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/util/package.json                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"util\";                                                                                               // 1\nexports.version = \"0.10.3\";                                                                                          // 2\nexports.main = \"./util.js\";                                                                                          // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"util.js\":[\"./support/isBuffer\",\"inherits\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/util/util.js                                                          //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\nvar formatRegExp = /%[sdj%]/g;                                                                                       // 22\nexports.format = function(f) {                                                                                       // 23\n  if (!isString(f)) {                                                                                                // 24\n    var objects = [];                                                                                                // 25\n    for (var i = 0; i < arguments.length; i++) {                                                                     // 26\n      objects.push(inspect(arguments[i]));                                                                           // 27\n    }                                                                                                                // 28\n    return objects.join(' ');                                                                                        // 29\n  }                                                                                                                  // 30\n                                                                                                                     // 31\n  var i = 1;                                                                                                         // 32\n  var args = arguments;                                                                                              // 33\n  var len = args.length;                                                                                             // 34\n  var str = String(f).replace(formatRegExp, function(x) {                                                            // 35\n    if (x === '%%') return '%';                                                                                      // 36\n    if (i >= len) return x;                                                                                          // 37\n    switch (x) {                                                                                                     // 38\n      case '%s': return String(args[i++]);                                                                           // 39\n      case '%d': return Number(args[i++]);                                                                           // 40\n      case '%j':                                                                                                     // 41\n        try {                                                                                                        // 42\n          return JSON.stringify(args[i++]);                                                                          // 43\n        } catch (_) {                                                                                                // 44\n          return '[Circular]';                                                                                       // 45\n        }                                                                                                            // 46\n      default:                                                                                                       // 47\n        return x;                                                                                                    // 48\n    }                                                                                                                // 49\n  });                                                                                                                // 50\n  for (var x = args[i]; i < len; x = args[++i]) {                                                                    // 51\n    if (isNull(x) || !isObject(x)) {                                                                                 // 52\n      str += ' ' + x;                                                                                                // 53\n    } else {                                                                                                         // 54\n      str += ' ' + inspect(x);                                                                                       // 55\n    }                                                                                                                // 56\n  }                                                                                                                  // 57\n  return str;                                                                                                        // 58\n};                                                                                                                   // 59\n                                                                                                                     // 60\n                                                                                                                     // 61\n// Mark that a method should not be used.                                                                            // 62\n// Returns a modified function which warns once by default.                                                          // 63\n// If --no-deprecation is set, then it is a no-op.                                                                   // 64\nexports.deprecate = function(fn, msg) {                                                                              // 65\n  // Allow for deprecating things in the process of starting up.                                                     // 66\n  if (isUndefined(global.process)) {                                                                                 // 67\n    return function() {                                                                                              // 68\n      return exports.deprecate(fn, msg).apply(this, arguments);                                                      // 69\n    };                                                                                                               // 70\n  }                                                                                                                  // 71\n                                                                                                                     // 72\n  if (process.noDeprecation === true) {                                                                              // 73\n    return fn;                                                                                                       // 74\n  }                                                                                                                  // 75\n                                                                                                                     // 76\n  var warned = false;                                                                                                // 77\n  function deprecated() {                                                                                            // 78\n    if (!warned) {                                                                                                   // 79\n      if (process.throwDeprecation) {                                                                                // 80\n        throw new Error(msg);                                                                                        // 81\n      } else if (process.traceDeprecation) {                                                                         // 82\n        console.trace(msg);                                                                                          // 83\n      } else {                                                                                                       // 84\n        console.error(msg);                                                                                          // 85\n      }                                                                                                              // 86\n      warned = true;                                                                                                 // 87\n    }                                                                                                                // 88\n    return fn.apply(this, arguments);                                                                                // 89\n  }                                                                                                                  // 90\n                                                                                                                     // 91\n  return deprecated;                                                                                                 // 92\n};                                                                                                                   // 93\n                                                                                                                     // 94\n                                                                                                                     // 95\nvar debugs = {};                                                                                                     // 96\nvar debugEnviron;                                                                                                    // 97\nexports.debuglog = function(set) {                                                                                   // 98\n  if (isUndefined(debugEnviron))                                                                                     // 99\n    debugEnviron = process.env.NODE_DEBUG || '';                                                                     // 100\n  set = set.toUpperCase();                                                                                           // 101\n  if (!debugs[set]) {                                                                                                // 102\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {                                                   // 103\n      var pid = process.pid;                                                                                         // 104\n      debugs[set] = function() {                                                                                     // 105\n        var msg = exports.format.apply(exports, arguments);                                                          // 106\n        console.error('%s %d: %s', set, pid, msg);                                                                   // 107\n      };                                                                                                             // 108\n    } else {                                                                                                         // 109\n      debugs[set] = function() {};                                                                                   // 110\n    }                                                                                                                // 111\n  }                                                                                                                  // 112\n  return debugs[set];                                                                                                // 113\n};                                                                                                                   // 114\n                                                                                                                     // 115\n                                                                                                                     // 116\n/**                                                                                                                  // 117\n * Echos the value of a value. Trys to print the value out                                                           // 118\n * in the best way possible given the different types.                                                               // 119\n *                                                                                                                   // 120\n * @param {Object} obj The object to print out.                                                                      // 121\n * @param {Object} opts Optional options object that alters the output.                                              // 122\n */                                                                                                                  // 123\n/* legacy: obj, showHidden, depth, colors*/                                                                          // 124\nfunction inspect(obj, opts) {                                                                                        // 125\n  // default options                                                                                                 // 126\n  var ctx = {                                                                                                        // 127\n    seen: [],                                                                                                        // 128\n    stylize: stylizeNoColor                                                                                          // 129\n  };                                                                                                                 // 130\n  // legacy...                                                                                                       // 131\n  if (arguments.length >= 3) ctx.depth = arguments[2];                                                               // 132\n  if (arguments.length >= 4) ctx.colors = arguments[3];                                                              // 133\n  if (isBoolean(opts)) {                                                                                             // 134\n    // legacy...                                                                                                     // 135\n    ctx.showHidden = opts;                                                                                           // 136\n  } else if (opts) {                                                                                                 // 137\n    // got an \"options\" object                                                                                       // 138\n    exports._extend(ctx, opts);                                                                                      // 139\n  }                                                                                                                  // 140\n  // set default options                                                                                             // 141\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;                                                           // 142\n  if (isUndefined(ctx.depth)) ctx.depth = 2;                                                                         // 143\n  if (isUndefined(ctx.colors)) ctx.colors = false;                                                                   // 144\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;                                                      // 145\n  if (ctx.colors) ctx.stylize = stylizeWithColor;                                                                    // 146\n  return formatValue(ctx, obj, ctx.depth);                                                                           // 147\n}                                                                                                                    // 148\nexports.inspect = inspect;                                                                                           // 149\n                                                                                                                     // 150\n                                                                                                                     // 151\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics                                                            // 152\ninspect.colors = {                                                                                                   // 153\n  'bold' : [1, 22],                                                                                                  // 154\n  'italic' : [3, 23],                                                                                                // 155\n  'underline' : [4, 24],                                                                                             // 156\n  'inverse' : [7, 27],                                                                                               // 157\n  'white' : [37, 39],                                                                                                // 158\n  'grey' : [90, 39],                                                                                                 // 159\n  'black' : [30, 39],                                                                                                // 160\n  'blue' : [34, 39],                                                                                                 // 161\n  'cyan' : [36, 39],                                                                                                 // 162\n  'green' : [32, 39],                                                                                                // 163\n  'magenta' : [35, 39],                                                                                              // 164\n  'red' : [31, 39],                                                                                                  // 165\n  'yellow' : [33, 39]                                                                                                // 166\n};                                                                                                                   // 167\n                                                                                                                     // 168\n// Don't use 'blue' not visible on cmd.exe                                                                           // 169\ninspect.styles = {                                                                                                   // 170\n  'special': 'cyan',                                                                                                 // 171\n  'number': 'yellow',                                                                                                // 172\n  'boolean': 'yellow',                                                                                               // 173\n  'undefined': 'grey',                                                                                               // 174\n  'null': 'bold',                                                                                                    // 175\n  'string': 'green',                                                                                                 // 176\n  'date': 'magenta',                                                                                                 // 177\n  // \"name\": intentionally not styling                                                                               // 178\n  'regexp': 'red'                                                                                                    // 179\n};                                                                                                                   // 180\n                                                                                                                     // 181\n                                                                                                                     // 182\nfunction stylizeWithColor(str, styleType) {                                                                          // 183\n  var style = inspect.styles[styleType];                                                                             // 184\n                                                                                                                     // 185\n  if (style) {                                                                                                       // 186\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +                                                        // 187\n           '\\u001b[' + inspect.colors[style][1] + 'm';                                                               // 188\n  } else {                                                                                                           // 189\n    return str;                                                                                                      // 190\n  }                                                                                                                  // 191\n}                                                                                                                    // 192\n                                                                                                                     // 193\n                                                                                                                     // 194\nfunction stylizeNoColor(str, styleType) {                                                                            // 195\n  return str;                                                                                                        // 196\n}                                                                                                                    // 197\n                                                                                                                     // 198\n                                                                                                                     // 199\nfunction arrayToHash(array) {                                                                                        // 200\n  var hash = {};                                                                                                     // 201\n                                                                                                                     // 202\n  array.forEach(function(val, idx) {                                                                                 // 203\n    hash[val] = true;                                                                                                // 204\n  });                                                                                                                // 205\n                                                                                                                     // 206\n  return hash;                                                                                                       // 207\n}                                                                                                                    // 208\n                                                                                                                     // 209\n                                                                                                                     // 210\nfunction formatValue(ctx, value, recurseTimes) {                                                                     // 211\n  // Provide a hook for user-specified inspect functions.                                                            // 212\n  // Check that value is an object with an inspect function on it                                                    // 213\n  if (ctx.customInspect &&                                                                                           // 214\n      value &&                                                                                                       // 215\n      isFunction(value.inspect) &&                                                                                   // 216\n      // Filter out the util module, it's inspect function is special                                                // 217\n      value.inspect !== exports.inspect &&                                                                           // 218\n      // Also filter out any prototype objects using the circular check.                                             // 219\n      !(value.constructor && value.constructor.prototype === value)) {                                               // 220\n    var ret = value.inspect(recurseTimes, ctx);                                                                      // 221\n    if (!isString(ret)) {                                                                                            // 222\n      ret = formatValue(ctx, ret, recurseTimes);                                                                     // 223\n    }                                                                                                                // 224\n    return ret;                                                                                                      // 225\n  }                                                                                                                  // 226\n                                                                                                                     // 227\n  // Primitive types cannot have properties                                                                          // 228\n  var primitive = formatPrimitive(ctx, value);                                                                       // 229\n  if (primitive) {                                                                                                   // 230\n    return primitive;                                                                                                // 231\n  }                                                                                                                  // 232\n                                                                                                                     // 233\n  // Look up the keys of the object.                                                                                 // 234\n  var keys = Object.keys(value);                                                                                     // 235\n  var visibleKeys = arrayToHash(keys);                                                                               // 236\n                                                                                                                     // 237\n  if (ctx.showHidden) {                                                                                              // 238\n    keys = Object.getOwnPropertyNames(value);                                                                        // 239\n  }                                                                                                                  // 240\n                                                                                                                     // 241\n  // IE doesn't make error fields non-enumerable                                                                     // 242\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx                                               // 243\n  if (isError(value)                                                                                                 // 244\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {                                       // 245\n    return formatError(value);                                                                                       // 246\n  }                                                                                                                  // 247\n                                                                                                                     // 248\n  // Some type of object without properties can be shortcutted.                                                      // 249\n  if (keys.length === 0) {                                                                                           // 250\n    if (isFunction(value)) {                                                                                         // 251\n      var name = value.name ? ': ' + value.name : '';                                                                // 252\n      return ctx.stylize('[Function' + name + ']', 'special');                                                       // 253\n    }                                                                                                                // 254\n    if (isRegExp(value)) {                                                                                           // 255\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');                                           // 256\n    }                                                                                                                // 257\n    if (isDate(value)) {                                                                                             // 258\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');                                               // 259\n    }                                                                                                                // 260\n    if (isError(value)) {                                                                                            // 261\n      return formatError(value);                                                                                     // 262\n    }                                                                                                                // 263\n  }                                                                                                                  // 264\n                                                                                                                     // 265\n  var base = '', array = false, braces = ['{', '}'];                                                                 // 266\n                                                                                                                     // 267\n  // Make Array say that they are Array                                                                              // 268\n  if (isArray(value)) {                                                                                              // 269\n    array = true;                                                                                                    // 270\n    braces = ['[', ']'];                                                                                             // 271\n  }                                                                                                                  // 272\n                                                                                                                     // 273\n  // Make functions say that they are functions                                                                      // 274\n  if (isFunction(value)) {                                                                                           // 275\n    var n = value.name ? ': ' + value.name : '';                                                                     // 276\n    base = ' [Function' + n + ']';                                                                                   // 277\n  }                                                                                                                  // 278\n                                                                                                                     // 279\n  // Make RegExps say that they are RegExps                                                                          // 280\n  if (isRegExp(value)) {                                                                                             // 281\n    base = ' ' + RegExp.prototype.toString.call(value);                                                              // 282\n  }                                                                                                                  // 283\n                                                                                                                     // 284\n  // Make dates with properties first say the date                                                                   // 285\n  if (isDate(value)) {                                                                                               // 286\n    base = ' ' + Date.prototype.toUTCString.call(value);                                                             // 287\n  }                                                                                                                  // 288\n                                                                                                                     // 289\n  // Make error with message first say the error                                                                     // 290\n  if (isError(value)) {                                                                                              // 291\n    base = ' ' + formatError(value);                                                                                 // 292\n  }                                                                                                                  // 293\n                                                                                                                     // 294\n  if (keys.length === 0 && (!array || value.length == 0)) {                                                          // 295\n    return braces[0] + base + braces[1];                                                                             // 296\n  }                                                                                                                  // 297\n                                                                                                                     // 298\n  if (recurseTimes < 0) {                                                                                            // 299\n    if (isRegExp(value)) {                                                                                           // 300\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');                                           // 301\n    } else {                                                                                                         // 302\n      return ctx.stylize('[Object]', 'special');                                                                     // 303\n    }                                                                                                                // 304\n  }                                                                                                                  // 305\n                                                                                                                     // 306\n  ctx.seen.push(value);                                                                                              // 307\n                                                                                                                     // 308\n  var output;                                                                                                        // 309\n  if (array) {                                                                                                       // 310\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);                                               // 311\n  } else {                                                                                                           // 312\n    output = keys.map(function(key) {                                                                                // 313\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);                                      // 314\n    });                                                                                                              // 315\n  }                                                                                                                  // 316\n                                                                                                                     // 317\n  ctx.seen.pop();                                                                                                    // 318\n                                                                                                                     // 319\n  return reduceToSingleString(output, base, braces);                                                                 // 320\n}                                                                                                                    // 321\n                                                                                                                     // 322\n                                                                                                                     // 323\nfunction formatPrimitive(ctx, value) {                                                                               // 324\n  if (isUndefined(value))                                                                                            // 325\n    return ctx.stylize('undefined', 'undefined');                                                                    // 326\n  if (isString(value)) {                                                                                             // 327\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')                                                  // 328\n                                             .replace(/'/g, \"\\\\'\")                                                   // 329\n                                             .replace(/\\\\\"/g, '\"') + '\\'';                                           // 330\n    return ctx.stylize(simple, 'string');                                                                            // 331\n  }                                                                                                                  // 332\n  if (isNumber(value))                                                                                               // 333\n    return ctx.stylize('' + value, 'number');                                                                        // 334\n  if (isBoolean(value))                                                                                              // 335\n    return ctx.stylize('' + value, 'boolean');                                                                       // 336\n  // For some reason typeof null is \"object\", so special case here.                                                  // 337\n  if (isNull(value))                                                                                                 // 338\n    return ctx.stylize('null', 'null');                                                                              // 339\n}                                                                                                                    // 340\n                                                                                                                     // 341\n                                                                                                                     // 342\nfunction formatError(value) {                                                                                        // 343\n  return '[' + Error.prototype.toString.call(value) + ']';                                                           // 344\n}                                                                                                                    // 345\n                                                                                                                     // 346\n                                                                                                                     // 347\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {                                                  // 348\n  var output = [];                                                                                                   // 349\n  for (var i = 0, l = value.length; i < l; ++i) {                                                                    // 350\n    if (hasOwnProperty(value, String(i))) {                                                                          // 351\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,                                              // 352\n          String(i), true));                                                                                         // 353\n    } else {                                                                                                         // 354\n      output.push('');                                                                                               // 355\n    }                                                                                                                // 356\n  }                                                                                                                  // 357\n  keys.forEach(function(key) {                                                                                       // 358\n    if (!key.match(/^\\d+$/)) {                                                                                       // 359\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,                                              // 360\n          key, true));                                                                                               // 361\n    }                                                                                                                // 362\n  });                                                                                                                // 363\n  return output;                                                                                                     // 364\n}                                                                                                                    // 365\n                                                                                                                     // 366\n                                                                                                                     // 367\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {                                         // 368\n  var name, str, desc;                                                                                               // 369\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };                                       // 370\n  if (desc.get) {                                                                                                    // 371\n    if (desc.set) {                                                                                                  // 372\n      str = ctx.stylize('[Getter/Setter]', 'special');                                                               // 373\n    } else {                                                                                                         // 374\n      str = ctx.stylize('[Getter]', 'special');                                                                      // 375\n    }                                                                                                                // 376\n  } else {                                                                                                           // 377\n    if (desc.set) {                                                                                                  // 378\n      str = ctx.stylize('[Setter]', 'special');                                                                      // 379\n    }                                                                                                                // 380\n  }                                                                                                                  // 381\n  if (!hasOwnProperty(visibleKeys, key)) {                                                                           // 382\n    name = '[' + key + ']';                                                                                          // 383\n  }                                                                                                                  // 384\n  if (!str) {                                                                                                        // 385\n    if (ctx.seen.indexOf(desc.value) < 0) {                                                                          // 386\n      if (isNull(recurseTimes)) {                                                                                    // 387\n        str = formatValue(ctx, desc.value, null);                                                                    // 388\n      } else {                                                                                                       // 389\n        str = formatValue(ctx, desc.value, recurseTimes - 1);                                                        // 390\n      }                                                                                                              // 391\n      if (str.indexOf('\\n') > -1) {                                                                                  // 392\n        if (array) {                                                                                                 // 393\n          str = str.split('\\n').map(function(line) {                                                                 // 394\n            return '  ' + line;                                                                                      // 395\n          }).join('\\n').substr(2);                                                                                   // 396\n        } else {                                                                                                     // 397\n          str = '\\n' + str.split('\\n').map(function(line) {                                                          // 398\n            return '   ' + line;                                                                                     // 399\n          }).join('\\n');                                                                                             // 400\n        }                                                                                                            // 401\n      }                                                                                                              // 402\n    } else {                                                                                                         // 403\n      str = ctx.stylize('[Circular]', 'special');                                                                    // 404\n    }                                                                                                                // 405\n  }                                                                                                                  // 406\n  if (isUndefined(name)) {                                                                                           // 407\n    if (array && key.match(/^\\d+$/)) {                                                                               // 408\n      return str;                                                                                                    // 409\n    }                                                                                                                // 410\n    name = JSON.stringify('' + key);                                                                                 // 411\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {                                                                // 412\n      name = name.substr(1, name.length - 2);                                                                        // 413\n      name = ctx.stylize(name, 'name');                                                                              // 414\n    } else {                                                                                                         // 415\n      name = name.replace(/'/g, \"\\\\'\")                                                                               // 416\n                 .replace(/\\\\\"/g, '\"')                                                                               // 417\n                 .replace(/(^\"|\"$)/g, \"'\");                                                                          // 418\n      name = ctx.stylize(name, 'string');                                                                            // 419\n    }                                                                                                                // 420\n  }                                                                                                                  // 421\n                                                                                                                     // 422\n  return name + ': ' + str;                                                                                          // 423\n}                                                                                                                    // 424\n                                                                                                                     // 425\n                                                                                                                     // 426\nfunction reduceToSingleString(output, base, braces) {                                                                // 427\n  var numLinesEst = 0;                                                                                               // 428\n  var length = output.reduce(function(prev, cur) {                                                                   // 429\n    numLinesEst++;                                                                                                   // 430\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;                                                                       // 431\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;                                                     // 432\n  }, 0);                                                                                                             // 433\n                                                                                                                     // 434\n  if (length > 60) {                                                                                                 // 435\n    return braces[0] +                                                                                               // 436\n           (base === '' ? '' : base + '\\n ') +                                                                       // 437\n           ' ' +                                                                                                     // 438\n           output.join(',\\n  ') +                                                                                    // 439\n           ' ' +                                                                                                     // 440\n           braces[1];                                                                                                // 441\n  }                                                                                                                  // 442\n                                                                                                                     // 443\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];                                               // 444\n}                                                                                                                    // 445\n                                                                                                                     // 446\n                                                                                                                     // 447\n// NOTE: These type checking functions intentionally don't use `instanceof`                                          // 448\n// because it is fragile and can be easily faked with `Object.create()`.                                             // 449\nfunction isArray(ar) {                                                                                               // 450\n  return Array.isArray(ar);                                                                                          // 451\n}                                                                                                                    // 452\nexports.isArray = isArray;                                                                                           // 453\n                                                                                                                     // 454\nfunction isBoolean(arg) {                                                                                            // 455\n  return typeof arg === 'boolean';                                                                                   // 456\n}                                                                                                                    // 457\nexports.isBoolean = isBoolean;                                                                                       // 458\n                                                                                                                     // 459\nfunction isNull(arg) {                                                                                               // 460\n  return arg === null;                                                                                               // 461\n}                                                                                                                    // 462\nexports.isNull = isNull;                                                                                             // 463\n                                                                                                                     // 464\nfunction isNullOrUndefined(arg) {                                                                                    // 465\n  return arg == null;                                                                                                // 466\n}                                                                                                                    // 467\nexports.isNullOrUndefined = isNullOrUndefined;                                                                       // 468\n                                                                                                                     // 469\nfunction isNumber(arg) {                                                                                             // 470\n  return typeof arg === 'number';                                                                                    // 471\n}                                                                                                                    // 472\nexports.isNumber = isNumber;                                                                                         // 473\n                                                                                                                     // 474\nfunction isString(arg) {                                                                                             // 475\n  return typeof arg === 'string';                                                                                    // 476\n}                                                                                                                    // 477\nexports.isString = isString;                                                                                         // 478\n                                                                                                                     // 479\nfunction isSymbol(arg) {                                                                                             // 480\n  return typeof arg === 'symbol';                                                                                    // 481\n}                                                                                                                    // 482\nexports.isSymbol = isSymbol;                                                                                         // 483\n                                                                                                                     // 484\nfunction isUndefined(arg) {                                                                                          // 485\n  return arg === void 0;                                                                                             // 486\n}                                                                                                                    // 487\nexports.isUndefined = isUndefined;                                                                                   // 488\n                                                                                                                     // 489\nfunction isRegExp(re) {                                                                                              // 490\n  return isObject(re) && objectToString(re) === '[object RegExp]';                                                   // 491\n}                                                                                                                    // 492\nexports.isRegExp = isRegExp;                                                                                         // 493\n                                                                                                                     // 494\nfunction isObject(arg) {                                                                                             // 495\n  return typeof arg === 'object' && arg !== null;                                                                    // 496\n}                                                                                                                    // 497\nexports.isObject = isObject;                                                                                         // 498\n                                                                                                                     // 499\nfunction isDate(d) {                                                                                                 // 500\n  return isObject(d) && objectToString(d) === '[object Date]';                                                       // 501\n}                                                                                                                    // 502\nexports.isDate = isDate;                                                                                             // 503\n                                                                                                                     // 504\nfunction isError(e) {                                                                                                // 505\n  return isObject(e) &&                                                                                              // 506\n      (objectToString(e) === '[object Error]' || e instanceof Error);                                                // 507\n}                                                                                                                    // 508\nexports.isError = isError;                                                                                           // 509\n                                                                                                                     // 510\nfunction isFunction(arg) {                                                                                           // 511\n  return typeof arg === 'function';                                                                                  // 512\n}                                                                                                                    // 513\nexports.isFunction = isFunction;                                                                                     // 514\n                                                                                                                     // 515\nfunction isPrimitive(arg) {                                                                                          // 516\n  return arg === null ||                                                                                             // 517\n         typeof arg === 'boolean' ||                                                                                 // 518\n         typeof arg === 'number' ||                                                                                  // 519\n         typeof arg === 'string' ||                                                                                  // 520\n         typeof arg === 'symbol' ||  // ES6 symbol                                                                   // 521\n         typeof arg === 'undefined';                                                                                 // 522\n}                                                                                                                    // 523\nexports.isPrimitive = isPrimitive;                                                                                   // 524\n                                                                                                                     // 525\nexports.isBuffer = require('./support/isBuffer');                                                                    // 526\n                                                                                                                     // 527\nfunction objectToString(o) {                                                                                         // 528\n  return Object.prototype.toString.call(o);                                                                          // 529\n}                                                                                                                    // 530\n                                                                                                                     // 531\n                                                                                                                     // 532\nfunction pad(n) {                                                                                                    // 533\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);                                                             // 534\n}                                                                                                                    // 535\n                                                                                                                     // 536\n                                                                                                                     // 537\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',                                         // 538\n              'Oct', 'Nov', 'Dec'];                                                                                  // 539\n                                                                                                                     // 540\n// 26 Feb 16:19:34                                                                                                   // 541\nfunction timestamp() {                                                                                               // 542\n  var d = new Date();                                                                                                // 543\n  var time = [pad(d.getHours()),                                                                                     // 544\n              pad(d.getMinutes()),                                                                                   // 545\n              pad(d.getSeconds())].join(':');                                                                        // 546\n  return [d.getDate(), months[d.getMonth()], time].join(' ');                                                        // 547\n}                                                                                                                    // 548\n                                                                                                                     // 549\n                                                                                                                     // 550\n// log is just a thin wrapper to console.log that prepends a timestamp                                               // 551\nexports.log = function() {                                                                                           // 552\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));                                     // 553\n};                                                                                                                   // 554\n                                                                                                                     // 555\n                                                                                                                     // 556\n/**                                                                                                                  // 557\n * Inherit the prototype methods from one constructor into another.                                                  // 558\n *                                                                                                                   // 559\n * The Function.prototype.inherits from lang.js rewritten as a standalone                                            // 560\n * function (not on Function.prototype). NOTE: If this file is to be loaded                                          // 561\n * during bootstrapping this function needs to be rewritten using some native                                        // 562\n * functions as prototype setup using normal JavaScript does not work as                                             // 563\n * expected during bootstrapping (see mirror.js in r114903).                                                         // 564\n *                                                                                                                   // 565\n * @param {function} ctor Constructor function which needs to inherit the                                            // 566\n *     prototype.                                                                                                    // 567\n * @param {function} superCtor Constructor function to inherit prototype from.                                       // 568\n */                                                                                                                  // 569\nexports.inherits = require('inherits');                                                                              // 570\n                                                                                                                     // 571\nexports._extend = function(origin, add) {                                                                            // 572\n  // Don't do anything if add isn't an object                                                                        // 573\n  if (!add || !isObject(add)) return origin;                                                                         // 574\n                                                                                                                     // 575\n  var keys = Object.keys(add);                                                                                       // 576\n  var i = keys.length;                                                                                               // 577\n  while (i--) {                                                                                                      // 578\n    origin[keys[i]] = add[keys[i]];                                                                                  // 579\n  }                                                                                                                  // 580\n  return origin;                                                                                                     // 581\n};                                                                                                                   // 582\n                                                                                                                     // 583\nfunction hasOwnProperty(obj, prop) {                                                                                 // 584\n  return Object.prototype.hasOwnProperty.call(obj, prop);                                                            // 585\n}                                                                                                                    // 586\n                                                                                                                     // 587\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"support\":{\"isBuffer.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/util/support/isBuffer.js                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.exports = function isBuffer(arg) {                                                                            // 1\n  return arg instanceof Buffer;                                                                                      // 2\n}                                                                                                                    // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"node_modules\":{\"inherits\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/util/node_modules/inherits/package.json                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"inherits\";                                                                                           // 1\nexports.version = \"2.0.1\";                                                                                           // 2\nexports.main = \"./inherits_browser.js\";                                                                              // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"inherits_browser.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/util/node_modules/inherits/inherits_browser.js                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nif (typeof Object.create === 'function') {                                                                           // 1\n  // implementation from standard node.js 'util' module                                                              // 2\n  module.exports = function inherits(ctor, superCtor) {                                                              // 3\n    ctor.super_ = superCtor                                                                                          // 4\n    ctor.prototype = Object.create(superCtor.prototype, {                                                            // 5\n      constructor: {                                                                                                 // 6\n        value: ctor,                                                                                                 // 7\n        enumerable: false,                                                                                           // 8\n        writable: true,                                                                                              // 9\n        configurable: true                                                                                           // 10\n      }                                                                                                              // 11\n    });                                                                                                              // 12\n  };                                                                                                                 // 13\n} else {                                                                                                             // 14\n  // old school shim for old browsers                                                                                // 15\n  module.exports = function inherits(ctor, superCtor) {                                                              // 16\n    ctor.super_ = superCtor                                                                                          // 17\n    var TempCtor = function () {}                                                                                    // 18\n    TempCtor.prototype = superCtor.prototype                                                                         // 19\n    ctor.prototype = new TempCtor()                                                                                  // 20\n    ctor.prototype.constructor = ctor                                                                                // 21\n  }                                                                                                                  // 22\n}                                                                                                                    // 23\n                                                                                                                     // 24\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}},\"string_decoder\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/string_decoder/package.json                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"string_decoder\";                                                                                     // 1\nexports.version = \"0.10.31\";                                                                                         // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"buffer\",\"meteor-node-stubs/deps/buffer\",function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/string_decoder/index.js                                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\nvar Buffer = require('buffer').Buffer;                                                                               // 22\n                                                                                                                     // 23\nvar isBufferEncoding = Buffer.isEncoding                                                                             // 24\n  || function(encoding) {                                                                                            // 25\n       switch (encoding && encoding.toLowerCase()) {                                                                 // 26\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;                                                                                      // 28\n       }                                                                                                             // 29\n     }                                                                                                               // 30\n                                                                                                                     // 31\n                                                                                                                     // 32\nfunction assertEncoding(encoding) {                                                                                  // 33\n  if (encoding && !isBufferEncoding(encoding)) {                                                                     // 34\n    throw new Error('Unknown encoding: ' + encoding);                                                                // 35\n  }                                                                                                                  // 36\n}                                                                                                                    // 37\n                                                                                                                     // 38\n// StringDecoder provides an interface for efficiently splitting a series of                                         // 39\n// buffers into a series of JS strings without breaking apart multi-byte                                             // 40\n// characters. CESU-8 is handled as part of the UTF-8 encoding.                                                      // 41\n//                                                                                                                   // 42\n// @TODO Handling all encodings inside a single object makes it very difficult                                       // 43\n// to reason about this code, so it should be split up in the future.                                                // 44\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code                                      // 45\n// points as used by CESU-8.                                                                                         // 46\nvar StringDecoder = exports.StringDecoder = function(encoding) {                                                     // 47\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');                                            // 48\n  assertEncoding(encoding);                                                                                          // 49\n  switch (this.encoding) {                                                                                           // 50\n    case 'utf8':                                                                                                     // 51\n      // CESU-8 represents each of Surrogate Pair by 3-bytes                                                         // 52\n      this.surrogateSize = 3;                                                                                        // 53\n      break;                                                                                                         // 54\n    case 'ucs2':                                                                                                     // 55\n    case 'utf16le':                                                                                                  // 56\n      // UTF-16 represents each of Surrogate Pair by 2-bytes                                                         // 57\n      this.surrogateSize = 2;                                                                                        // 58\n      this.detectIncompleteChar = utf16DetectIncompleteChar;                                                         // 59\n      break;                                                                                                         // 60\n    case 'base64':                                                                                                   // 61\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.                                                  // 62\n      this.surrogateSize = 3;                                                                                        // 63\n      this.detectIncompleteChar = base64DetectIncompleteChar;                                                        // 64\n      break;                                                                                                         // 65\n    default:                                                                                                         // 66\n      this.write = passThroughWrite;                                                                                 // 67\n      return;                                                                                                        // 68\n  }                                                                                                                  // 69\n                                                                                                                     // 70\n  // Enough space to store all bytes of a single character. UTF-8 needs 4                                            // 71\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).                                                  // 72\n  this.charBuffer = new Buffer(6);                                                                                   // 73\n  // Number of bytes received for the current incomplete multi-byte character.                                       // 74\n  this.charReceived = 0;                                                                                             // 75\n  // Number of bytes expected for the current incomplete multi-byte character.                                       // 76\n  this.charLength = 0;                                                                                               // 77\n};                                                                                                                   // 78\n                                                                                                                     // 79\n                                                                                                                     // 80\n// write decodes the given buffer and returns it as JS string that is                                                // 81\n// guaranteed to not contain any partial multi-byte characters. Any partial                                          // 82\n// character found at the end of the buffer is buffered up, and will be                                              // 83\n// returned when calling write again with the remaining bytes.                                                       // 84\n//                                                                                                                   // 85\n// Note: Converting a Buffer containing an orphan surrogate to a String                                              // 86\n// currently works, but converting a String to a Buffer (via `new Buffer`, or                                        // 87\n// Buffer#write) will replace incomplete surrogates with the unicode                                                 // 88\n// replacement character. See https://codereview.chromium.org/121173009/ .                                           // 89\nStringDecoder.prototype.write = function(buffer) {                                                                   // 90\n  var charStr = '';                                                                                                  // 91\n  // if our last write ended with an incomplete multibyte character                                                  // 92\n  while (this.charLength) {                                                                                          // 93\n    // determine how many remaining bytes this buffer has to offer for this char                                     // 94\n    var available = (buffer.length >= this.charLength - this.charReceived) ?                                         // 95\n        this.charLength - this.charReceived :                                                                        // 96\n        buffer.length;                                                                                               // 97\n                                                                                                                     // 98\n    // add the new bytes to the char buffer                                                                          // 99\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);                                                   // 100\n    this.charReceived += available;                                                                                  // 101\n                                                                                                                     // 102\n    if (this.charReceived < this.charLength) {                                                                       // 103\n      // still not enough chars in this buffer? wait for more ...                                                    // 104\n      return '';                                                                                                     // 105\n    }                                                                                                                // 106\n                                                                                                                     // 107\n    // remove bytes belonging to the current character from the buffer                                               // 108\n    buffer = buffer.slice(available, buffer.length);                                                                 // 109\n                                                                                                                     // 110\n    // get the character that was split                                                                              // 111\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);                                     // 112\n                                                                                                                     // 113\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character                                           // 114\n    var charCode = charStr.charCodeAt(charStr.length - 1);                                                           // 115\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {                                                                  // 116\n      this.charLength += this.surrogateSize;                                                                         // 117\n      charStr = '';                                                                                                  // 118\n      continue;                                                                                                      // 119\n    }                                                                                                                // 120\n    this.charReceived = this.charLength = 0;                                                                         // 121\n                                                                                                                     // 122\n    // if there are no more bytes in this buffer, just emit our char                                                 // 123\n    if (buffer.length === 0) {                                                                                       // 124\n      return charStr;                                                                                                // 125\n    }                                                                                                                // 126\n    break;                                                                                                           // 127\n  }                                                                                                                  // 128\n                                                                                                                     // 129\n  // determine and set charLength / charReceived                                                                     // 130\n  this.detectIncompleteChar(buffer);                                                                                 // 131\n                                                                                                                     // 132\n  var end = buffer.length;                                                                                           // 133\n  if (this.charLength) {                                                                                             // 134\n    // buffer the incomplete character bytes we got                                                                  // 135\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);                                         // 136\n    end -= this.charReceived;                                                                                        // 137\n  }                                                                                                                  // 138\n                                                                                                                     // 139\n  charStr += buffer.toString(this.encoding, 0, end);                                                                 // 140\n                                                                                                                     // 141\n  var end = charStr.length - 1;                                                                                      // 142\n  var charCode = charStr.charCodeAt(end);                                                                            // 143\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character                                             // 144\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {                                                                    // 145\n    var size = this.surrogateSize;                                                                                   // 146\n    this.charLength += size;                                                                                         // 147\n    this.charReceived += size;                                                                                       // 148\n    this.charBuffer.copy(this.charBuffer, size, 0, size);                                                            // 149\n    buffer.copy(this.charBuffer, 0, 0, size);                                                                        // 150\n    return charStr.substring(0, end);                                                                                // 151\n  }                                                                                                                  // 152\n                                                                                                                     // 153\n  // or just emit the charStr                                                                                        // 154\n  return charStr;                                                                                                    // 155\n};                                                                                                                   // 156\n                                                                                                                     // 157\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at                                      // 158\n// the end of the given buffer. If so, it sets this.charLength to the byte                                           // 159\n// length that character, and sets this.charReceived to the number of bytes                                          // 160\n// that are available for this character.                                                                            // 161\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {                                                    // 162\n  // determine how many bytes we have to check at the end of this buffer                                             // 163\n  var i = (buffer.length >= 3) ? 3 : buffer.length;                                                                  // 164\n                                                                                                                     // 165\n  // Figure out if one of the last i bytes of our buffer announces an                                                // 166\n  // incomplete char.                                                                                                // 167\n  for (; i > 0; i--) {                                                                                               // 168\n    var c = buffer[buffer.length - i];                                                                               // 169\n                                                                                                                     // 170\n    // See http://en.wikipedia.org/wiki/UTF-8#Description                                                            // 171\n                                                                                                                     // 172\n    // 110XXXXX                                                                                                      // 173\n    if (i == 1 && c >> 5 == 0x06) {                                                                                  // 174\n      this.charLength = 2;                                                                                           // 175\n      break;                                                                                                         // 176\n    }                                                                                                                // 177\n                                                                                                                     // 178\n    // 1110XXXX                                                                                                      // 179\n    if (i <= 2 && c >> 4 == 0x0E) {                                                                                  // 180\n      this.charLength = 3;                                                                                           // 181\n      break;                                                                                                         // 182\n    }                                                                                                                // 183\n                                                                                                                     // 184\n    // 11110XXX                                                                                                      // 185\n    if (i <= 3 && c >> 3 == 0x1E) {                                                                                  // 186\n      this.charLength = 4;                                                                                           // 187\n      break;                                                                                                         // 188\n    }                                                                                                                // 189\n  }                                                                                                                  // 190\n  this.charReceived = i;                                                                                             // 191\n};                                                                                                                   // 192\n                                                                                                                     // 193\nStringDecoder.prototype.end = function(buffer) {                                                                     // 194\n  var res = '';                                                                                                      // 195\n  if (buffer && buffer.length)                                                                                       // 196\n    res = this.write(buffer);                                                                                        // 197\n                                                                                                                     // 198\n  if (this.charReceived) {                                                                                           // 199\n    var cr = this.charReceived;                                                                                      // 200\n    var buf = this.charBuffer;                                                                                       // 201\n    var enc = this.encoding;                                                                                         // 202\n    res += buf.slice(0, cr).toString(enc);                                                                           // 203\n  }                                                                                                                  // 204\n                                                                                                                     // 205\n  return res;                                                                                                        // 206\n};                                                                                                                   // 207\n                                                                                                                     // 208\nfunction passThroughWrite(buffer) {                                                                                  // 209\n  return buffer.toString(this.encoding);                                                                             // 210\n}                                                                                                                    // 211\n                                                                                                                     // 212\nfunction utf16DetectIncompleteChar(buffer) {                                                                         // 213\n  this.charReceived = buffer.length % 2;                                                                             // 214\n  this.charLength = this.charReceived ? 2 : 0;                                                                       // 215\n}                                                                                                                    // 216\n                                                                                                                     // 217\nfunction base64DetectIncompleteChar(buffer) {                                                                        // 218\n  this.charReceived = buffer.length % 3;                                                                             // 219\n  this.charLength = this.charReceived ? 3 : 0;                                                                       // 220\n}                                                                                                                    // 221\n                                                                                                                     // 222\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"url\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/url/package.json                                                      //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"url\";                                                                                                // 1\nexports.version = \"0.11.0\";                                                                                          // 2\nexports.main = \"./url.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"url.js\":[\"punycode\",\"./util\",\"querystring\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/url/url.js                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n'use strict';                                                                                                        // 22\n                                                                                                                     // 23\nvar punycode = require('punycode');                                                                                  // 24\nvar util = require('./util');                                                                                        // 25\n                                                                                                                     // 26\nexports.parse = urlParse;                                                                                            // 27\nexports.resolve = urlResolve;                                                                                        // 28\nexports.resolveObject = urlResolveObject;                                                                            // 29\nexports.format = urlFormat;                                                                                          // 30\n                                                                                                                     // 31\nexports.Url = Url;                                                                                                   // 32\n                                                                                                                     // 33\nfunction Url() {                                                                                                     // 34\n  this.protocol = null;                                                                                              // 35\n  this.slashes = null;                                                                                               // 36\n  this.auth = null;                                                                                                  // 37\n  this.host = null;                                                                                                  // 38\n  this.port = null;                                                                                                  // 39\n  this.hostname = null;                                                                                              // 40\n  this.hash = null;                                                                                                  // 41\n  this.search = null;                                                                                                // 42\n  this.query = null;                                                                                                 // 43\n  this.pathname = null;                                                                                              // 44\n  this.path = null;                                                                                                  // 45\n  this.href = null;                                                                                                  // 46\n}                                                                                                                    // 47\n                                                                                                                     // 48\n// Reference: RFC 3986, RFC 1808, RFC 2396                                                                           // 49\n                                                                                                                     // 50\n// define these here so at least they only have to be                                                                // 51\n// compiled once on the first module load.                                                                           // 52\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,                                                                           // 53\n    portPattern = /:[0-9]*$/,                                                                                        // 54\n                                                                                                                     // 55\n    // Special case for a simple path URL                                                                            // 56\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,                                                        // 57\n                                                                                                                     // 58\n    // RFC 2396: characters reserved for delimiting URLs.                                                            // 59\n    // We actually just auto-escape these.                                                                           // 60\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],                                                            // 61\n                                                                                                                     // 62\n    // RFC 2396: characters not allowed for various reasons.                                                         // 63\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),                                                         // 64\n                                                                                                                     // 65\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.                                              // 66\n    autoEscape = ['\\''].concat(unwise),                                                                              // 67\n    // Characters that are never ever allowed in a hostname.                                                         // 68\n    // Note that any invalid chars are also handled, but these                                                       // 69\n    // are the ones that are *expected* to be seen, so we fast-path                                                  // 70\n    // them.                                                                                                         // 71\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),                                                     // 72\n    hostEndingChars = ['/', '?', '#'],                                                                               // 73\n    hostnameMaxLen = 255,                                                                                            // 74\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,                                                                  // 75\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,                                                              // 76\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.                                                         // 77\n    unsafeProtocol = {                                                                                               // 78\n      'javascript': true,                                                                                            // 79\n      'javascript:': true                                                                                            // 80\n    },                                                                                                               // 81\n    // protocols that never have a hostname.                                                                         // 82\n    hostlessProtocol = {                                                                                             // 83\n      'javascript': true,                                                                                            // 84\n      'javascript:': true                                                                                            // 85\n    },                                                                                                               // 86\n    // protocols that always contain a // bit.                                                                       // 87\n    slashedProtocol = {                                                                                              // 88\n      'http': true,                                                                                                  // 89\n      'https': true,                                                                                                 // 90\n      'ftp': true,                                                                                                   // 91\n      'gopher': true,                                                                                                // 92\n      'file': true,                                                                                                  // 93\n      'http:': true,                                                                                                 // 94\n      'https:': true,                                                                                                // 95\n      'ftp:': true,                                                                                                  // 96\n      'gopher:': true,                                                                                               // 97\n      'file:': true                                                                                                  // 98\n    },                                                                                                               // 99\n    querystring = require('querystring');                                                                            // 100\n                                                                                                                     // 101\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {                                                        // 102\n  if (url && util.isObject(url) && url instanceof Url) return url;                                                   // 103\n                                                                                                                     // 104\n  var u = new Url;                                                                                                   // 105\n  u.parse(url, parseQueryString, slashesDenoteHost);                                                                 // 106\n  return u;                                                                                                          // 107\n}                                                                                                                    // 108\n                                                                                                                     // 109\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {                                           // 110\n  if (!util.isString(url)) {                                                                                         // 111\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);                                      // 112\n  }                                                                                                                  // 113\n                                                                                                                     // 114\n  // Copy chrome, IE, opera backslash-handling behavior.                                                             // 115\n  // Back slashes before the query string get converted to forward slashes                                           // 116\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916                                                  // 117\n  var queryIndex = url.indexOf('?'),                                                                                 // 118\n      splitter =                                                                                                     // 119\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',                                          // 120\n      uSplit = url.split(splitter),                                                                                  // 121\n      slashRegex = /\\\\/g;                                                                                            // 122\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');                                                                    // 123\n  url = uSplit.join(splitter);                                                                                       // 124\n                                                                                                                     // 125\n  var rest = url;                                                                                                    // 126\n                                                                                                                     // 127\n  // trim before proceeding.                                                                                         // 128\n  // This is to support parse stuff like \"  http://foo.com  \\n\"                                                      // 129\n  rest = rest.trim();                                                                                                // 130\n                                                                                                                     // 131\n  if (!slashesDenoteHost && url.split('#').length === 1) {                                                           // 132\n    // Try fast path regexp                                                                                          // 133\n    var simplePath = simplePathPattern.exec(rest);                                                                   // 134\n    if (simplePath) {                                                                                                // 135\n      this.path = rest;                                                                                              // 136\n      this.href = rest;                                                                                              // 137\n      this.pathname = simplePath[1];                                                                                 // 138\n      if (simplePath[2]) {                                                                                           // 139\n        this.search = simplePath[2];                                                                                 // 140\n        if (parseQueryString) {                                                                                      // 141\n          this.query = querystring.parse(this.search.substr(1));                                                     // 142\n        } else {                                                                                                     // 143\n          this.query = this.search.substr(1);                                                                        // 144\n        }                                                                                                            // 145\n      } else if (parseQueryString) {                                                                                 // 146\n        this.search = '';                                                                                            // 147\n        this.query = {};                                                                                             // 148\n      }                                                                                                              // 149\n      return this;                                                                                                   // 150\n    }                                                                                                                // 151\n  }                                                                                                                  // 152\n                                                                                                                     // 153\n  var proto = protocolPattern.exec(rest);                                                                            // 154\n  if (proto) {                                                                                                       // 155\n    proto = proto[0];                                                                                                // 156\n    var lowerProto = proto.toLowerCase();                                                                            // 157\n    this.protocol = lowerProto;                                                                                      // 158\n    rest = rest.substr(proto.length);                                                                                // 159\n  }                                                                                                                  // 160\n                                                                                                                     // 161\n  // figure out if it's got a host                                                                                   // 162\n  // user@server is *always* interpreted as a hostname, and url                                                      // 163\n  // resolution will treat //foo/bar as host=foo,path=bar because that's                                             // 164\n  // how the browser resolves relative URLs.                                                                         // 165\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {                                            // 166\n    var slashes = rest.substr(0, 2) === '//';                                                                        // 167\n    if (slashes && !(proto && hostlessProtocol[proto])) {                                                            // 168\n      rest = rest.substr(2);                                                                                         // 169\n      this.slashes = true;                                                                                           // 170\n    }                                                                                                                // 171\n  }                                                                                                                  // 172\n                                                                                                                     // 173\n  if (!hostlessProtocol[proto] &&                                                                                    // 174\n      (slashes || (proto && !slashedProtocol[proto]))) {                                                             // 175\n                                                                                                                     // 176\n    // there's a hostname.                                                                                           // 177\n    // the first instance of /, ?, ;, or # ends the host.                                                            // 178\n    //                                                                                                               // 179\n    // If there is an @ in the hostname, then non-host chars *are* allowed                                           // 180\n    // to the left of the last @ sign, unless some host-ending character                                             // 181\n    // comes *before* the @-sign.                                                                                    // 182\n    // URLs are obnoxious.                                                                                           // 183\n    //                                                                                                               // 184\n    // ex:                                                                                                           // 185\n    // http://a@b@c/ => user:a@b host:c                                                                              // 186\n    // http://a@b?@c => user:a host:c path:/?@c                                                                      // 187\n                                                                                                                     // 188\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.                                                 // 189\n    // Review our test case against browsers more comprehensively.                                                   // 190\n                                                                                                                     // 191\n    // find the first instance of any hostEndingChars                                                                // 192\n    var hostEnd = -1;                                                                                                // 193\n    for (var i = 0; i < hostEndingChars.length; i++) {                                                               // 194\n      var hec = rest.indexOf(hostEndingChars[i]);                                                                    // 195\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))                                                           // 196\n        hostEnd = hec;                                                                                               // 197\n    }                                                                                                                // 198\n                                                                                                                     // 199\n    // at this point, either we have an explicit point where the                                                     // 200\n    // auth portion cannot go past, or the last @ char is the decider.                                               // 201\n    var auth, atSign;                                                                                                // 202\n    if (hostEnd === -1) {                                                                                            // 203\n      // atSign can be anywhere.                                                                                     // 204\n      atSign = rest.lastIndexOf('@');                                                                                // 205\n    } else {                                                                                                         // 206\n      // atSign must be in auth portion.                                                                             // 207\n      // http://a@b/c@d => host:b auth:a path:/c@d                                                                   // 208\n      atSign = rest.lastIndexOf('@', hostEnd);                                                                       // 209\n    }                                                                                                                // 210\n                                                                                                                     // 211\n    // Now we have a portion which is definitely the auth.                                                           // 212\n    // Pull that off.                                                                                                // 213\n    if (atSign !== -1) {                                                                                             // 214\n      auth = rest.slice(0, atSign);                                                                                  // 215\n      rest = rest.slice(atSign + 1);                                                                                 // 216\n      this.auth = decodeURIComponent(auth);                                                                          // 217\n    }                                                                                                                // 218\n                                                                                                                     // 219\n    // the host is the remaining to the left of the first non-host char                                              // 220\n    hostEnd = -1;                                                                                                    // 221\n    for (var i = 0; i < nonHostChars.length; i++) {                                                                  // 222\n      var hec = rest.indexOf(nonHostChars[i]);                                                                       // 223\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))                                                           // 224\n        hostEnd = hec;                                                                                               // 225\n    }                                                                                                                // 226\n    // if we still have not hit it, then the entire thing is a host.                                                 // 227\n    if (hostEnd === -1)                                                                                              // 228\n      hostEnd = rest.length;                                                                                         // 229\n                                                                                                                     // 230\n    this.host = rest.slice(0, hostEnd);                                                                              // 231\n    rest = rest.slice(hostEnd);                                                                                      // 232\n                                                                                                                     // 233\n    // pull out port.                                                                                                // 234\n    this.parseHost();                                                                                                // 235\n                                                                                                                     // 236\n    // we've indicated that there is a hostname,                                                                     // 237\n    // so even if it's empty, it has to be present.                                                                  // 238\n    this.hostname = this.hostname || '';                                                                             // 239\n                                                                                                                     // 240\n    // if hostname begins with [ and ends with ]                                                                     // 241\n    // assume that it's an IPv6 address.                                                                             // 242\n    var ipv6Hostname = this.hostname[0] === '[' &&                                                                   // 243\n        this.hostname[this.hostname.length - 1] === ']';                                                             // 244\n                                                                                                                     // 245\n    // validate a little.                                                                                            // 246\n    if (!ipv6Hostname) {                                                                                             // 247\n      var hostparts = this.hostname.split(/\\./);                                                                     // 248\n      for (var i = 0, l = hostparts.length; i < l; i++) {                                                            // 249\n        var part = hostparts[i];                                                                                     // 250\n        if (!part) continue;                                                                                         // 251\n        if (!part.match(hostnamePartPattern)) {                                                                      // 252\n          var newpart = '';                                                                                          // 253\n          for (var j = 0, k = part.length; j < k; j++) {                                                             // 254\n            if (part.charCodeAt(j) > 127) {                                                                          // 255\n              // we replace non-ASCII char with a temporary placeholder                                              // 256\n              // we need this to make sure size of hostname is not                                                   // 257\n              // broken by replacing non-ASCII by nothing                                                            // 258\n              newpart += 'x';                                                                                        // 259\n            } else {                                                                                                 // 260\n              newpart += part[j];                                                                                    // 261\n            }                                                                                                        // 262\n          }                                                                                                          // 263\n          // we test again with ASCII char only                                                                      // 264\n          if (!newpart.match(hostnamePartPattern)) {                                                                 // 265\n            var validParts = hostparts.slice(0, i);                                                                  // 266\n            var notHost = hostparts.slice(i + 1);                                                                    // 267\n            var bit = part.match(hostnamePartStart);                                                                 // 268\n            if (bit) {                                                                                               // 269\n              validParts.push(bit[1]);                                                                               // 270\n              notHost.unshift(bit[2]);                                                                               // 271\n            }                                                                                                        // 272\n            if (notHost.length) {                                                                                    // 273\n              rest = '/' + notHost.join('.') + rest;                                                                 // 274\n            }                                                                                                        // 275\n            this.hostname = validParts.join('.');                                                                    // 276\n            break;                                                                                                   // 277\n          }                                                                                                          // 278\n        }                                                                                                            // 279\n      }                                                                                                              // 280\n    }                                                                                                                // 281\n                                                                                                                     // 282\n    if (this.hostname.length > hostnameMaxLen) {                                                                     // 283\n      this.hostname = '';                                                                                            // 284\n    } else {                                                                                                         // 285\n      // hostnames are always lower case.                                                                            // 286\n      this.hostname = this.hostname.toLowerCase();                                                                   // 287\n    }                                                                                                                // 288\n                                                                                                                     // 289\n    if (!ipv6Hostname) {                                                                                             // 290\n      // IDNA Support: Returns a punycoded representation of \"domain\".                                               // 291\n      // It only converts parts of the domain name that                                                              // 292\n      // have non-ASCII characters, i.e. it doesn't matter if                                                        // 293\n      // you call it with a domain that already is ASCII-only.                                                       // 294\n      this.hostname = punycode.toASCII(this.hostname);                                                               // 295\n    }                                                                                                                // 296\n                                                                                                                     // 297\n    var p = this.port ? ':' + this.port : '';                                                                        // 298\n    var h = this.hostname || '';                                                                                     // 299\n    this.host = h + p;                                                                                               // 300\n    this.href += this.host;                                                                                          // 301\n                                                                                                                     // 302\n    // strip [ and ] from the hostname                                                                               // 303\n    // the host field still retains them, though                                                                     // 304\n    if (ipv6Hostname) {                                                                                              // 305\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);                                             // 306\n      if (rest[0] !== '/') {                                                                                         // 307\n        rest = '/' + rest;                                                                                           // 308\n      }                                                                                                              // 309\n    }                                                                                                                // 310\n  }                                                                                                                  // 311\n                                                                                                                     // 312\n  // now rest is set to the post-host stuff.                                                                         // 313\n  // chop off any delim chars.                                                                                       // 314\n  if (!unsafeProtocol[lowerProto]) {                                                                                 // 315\n                                                                                                                     // 316\n    // First, make 100% sure that any \"autoEscape\" chars get                                                         // 317\n    // escaped, even if encodeURIComponent doesn't think they                                                        // 318\n    // need to be.                                                                                                   // 319\n    for (var i = 0, l = autoEscape.length; i < l; i++) {                                                             // 320\n      var ae = autoEscape[i];                                                                                        // 321\n      if (rest.indexOf(ae) === -1)                                                                                   // 322\n        continue;                                                                                                    // 323\n      var esc = encodeURIComponent(ae);                                                                              // 324\n      if (esc === ae) {                                                                                              // 325\n        esc = escape(ae);                                                                                            // 326\n      }                                                                                                              // 327\n      rest = rest.split(ae).join(esc);                                                                               // 328\n    }                                                                                                                // 329\n  }                                                                                                                  // 330\n                                                                                                                     // 331\n                                                                                                                     // 332\n  // chop off from the tail first.                                                                                   // 333\n  var hash = rest.indexOf('#');                                                                                      // 334\n  if (hash !== -1) {                                                                                                 // 335\n    // got a fragment string.                                                                                        // 336\n    this.hash = rest.substr(hash);                                                                                   // 337\n    rest = rest.slice(0, hash);                                                                                      // 338\n  }                                                                                                                  // 339\n  var qm = rest.indexOf('?');                                                                                        // 340\n  if (qm !== -1) {                                                                                                   // 341\n    this.search = rest.substr(qm);                                                                                   // 342\n    this.query = rest.substr(qm + 1);                                                                                // 343\n    if (parseQueryString) {                                                                                          // 344\n      this.query = querystring.parse(this.query);                                                                    // 345\n    }                                                                                                                // 346\n    rest = rest.slice(0, qm);                                                                                        // 347\n  } else if (parseQueryString) {                                                                                     // 348\n    // no query string, but parseQueryString still requested                                                         // 349\n    this.search = '';                                                                                                // 350\n    this.query = {};                                                                                                 // 351\n  }                                                                                                                  // 352\n  if (rest) this.pathname = rest;                                                                                    // 353\n  if (slashedProtocol[lowerProto] &&                                                                                 // 354\n      this.hostname && !this.pathname) {                                                                             // 355\n    this.pathname = '/';                                                                                             // 356\n  }                                                                                                                  // 357\n                                                                                                                     // 358\n  //to support http.request                                                                                          // 359\n  if (this.pathname || this.search) {                                                                                // 360\n    var p = this.pathname || '';                                                                                     // 361\n    var s = this.search || '';                                                                                       // 362\n    this.path = p + s;                                                                                               // 363\n  }                                                                                                                  // 364\n                                                                                                                     // 365\n  // finally, reconstruct the href based on what has been validated.                                                 // 366\n  this.href = this.format();                                                                                         // 367\n  return this;                                                                                                       // 368\n};                                                                                                                   // 369\n                                                                                                                     // 370\n// format a parsed object into a url string                                                                          // 371\nfunction urlFormat(obj) {                                                                                            // 372\n  // ensure it's an object, and not a string url.                                                                    // 373\n  // If it's an obj, this is a no-op.                                                                                // 374\n  // this way, you can call url_format() on strings                                                                  // 375\n  // to clean up potentially wonky urls.                                                                             // 376\n  if (util.isString(obj)) obj = urlParse(obj);                                                                       // 377\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);                                                  // 378\n  return obj.format();                                                                                               // 379\n}                                                                                                                    // 380\n                                                                                                                     // 381\nUrl.prototype.format = function() {                                                                                  // 382\n  var auth = this.auth || '';                                                                                        // 383\n  if (auth) {                                                                                                        // 384\n    auth = encodeURIComponent(auth);                                                                                 // 385\n    auth = auth.replace(/%3A/i, ':');                                                                                // 386\n    auth += '@';                                                                                                     // 387\n  }                                                                                                                  // 388\n                                                                                                                     // 389\n  var protocol = this.protocol || '',                                                                                // 390\n      pathname = this.pathname || '',                                                                                // 391\n      hash = this.hash || '',                                                                                        // 392\n      host = false,                                                                                                  // 393\n      query = '';                                                                                                    // 394\n                                                                                                                     // 395\n  if (this.host) {                                                                                                   // 396\n    host = auth + this.host;                                                                                         // 397\n  } else if (this.hostname) {                                                                                        // 398\n    host = auth + (this.hostname.indexOf(':') === -1 ?                                                               // 399\n        this.hostname :                                                                                              // 400\n        '[' + this.hostname + ']');                                                                                  // 401\n    if (this.port) {                                                                                                 // 402\n      host += ':' + this.port;                                                                                       // 403\n    }                                                                                                                // 404\n  }                                                                                                                  // 405\n                                                                                                                     // 406\n  if (this.query &&                                                                                                  // 407\n      util.isObject(this.query) &&                                                                                   // 408\n      Object.keys(this.query).length) {                                                                              // 409\n    query = querystring.stringify(this.query);                                                                       // 410\n  }                                                                                                                  // 411\n                                                                                                                     // 412\n  var search = this.search || (query && ('?' + query)) || '';                                                        // 413\n                                                                                                                     // 414\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';                                                      // 415\n                                                                                                                     // 416\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.                                                 // 417\n  // unless they had them to begin with.                                                                             // 418\n  if (this.slashes ||                                                                                                // 419\n      (!protocol || slashedProtocol[protocol]) && host !== false) {                                                  // 420\n    host = '//' + (host || '');                                                                                      // 421\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;                                           // 422\n  } else if (!host) {                                                                                                // 423\n    host = '';                                                                                                       // 424\n  }                                                                                                                  // 425\n                                                                                                                     // 426\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;                                                             // 427\n  if (search && search.charAt(0) !== '?') search = '?' + search;                                                     // 428\n                                                                                                                     // 429\n  pathname = pathname.replace(/[?#]/g, function(match) {                                                             // 430\n    return encodeURIComponent(match);                                                                                // 431\n  });                                                                                                                // 432\n  search = search.replace('#', '%23');                                                                               // 433\n                                                                                                                     // 434\n  return protocol + host + pathname + search + hash;                                                                 // 435\n};                                                                                                                   // 436\n                                                                                                                     // 437\nfunction urlResolve(source, relative) {                                                                              // 438\n  return urlParse(source, false, true).resolve(relative);                                                            // 439\n}                                                                                                                    // 440\n                                                                                                                     // 441\nUrl.prototype.resolve = function(relative) {                                                                         // 442\n  return this.resolveObject(urlParse(relative, false, true)).format();                                               // 443\n};                                                                                                                   // 444\n                                                                                                                     // 445\nfunction urlResolveObject(source, relative) {                                                                        // 446\n  if (!source) return relative;                                                                                      // 447\n  return urlParse(source, false, true).resolveObject(relative);                                                      // 448\n}                                                                                                                    // 449\n                                                                                                                     // 450\nUrl.prototype.resolveObject = function(relative) {                                                                   // 451\n  if (util.isString(relative)) {                                                                                     // 452\n    var rel = new Url();                                                                                             // 453\n    rel.parse(relative, false, true);                                                                                // 454\n    relative = rel;                                                                                                  // 455\n  }                                                                                                                  // 456\n                                                                                                                     // 457\n  var result = new Url();                                                                                            // 458\n  var tkeys = Object.keys(this);                                                                                     // 459\n  for (var tk = 0; tk < tkeys.length; tk++) {                                                                        // 460\n    var tkey = tkeys[tk];                                                                                            // 461\n    result[tkey] = this[tkey];                                                                                       // 462\n  }                                                                                                                  // 463\n                                                                                                                     // 464\n  // hash is always overridden, no matter what.                                                                      // 465\n  // even href=\"\" will remove it.                                                                                    // 466\n  result.hash = relative.hash;                                                                                       // 467\n                                                                                                                     // 468\n  // if the relative url is empty, then there's nothing left to do here.                                             // 469\n  if (relative.href === '') {                                                                                        // 470\n    result.href = result.format();                                                                                   // 471\n    return result;                                                                                                   // 472\n  }                                                                                                                  // 473\n                                                                                                                     // 474\n  // hrefs like //foo/bar always cut to the protocol.                                                                // 475\n  if (relative.slashes && !relative.protocol) {                                                                      // 476\n    // take everything except the protocol from relative                                                             // 477\n    var rkeys = Object.keys(relative);                                                                               // 478\n    for (var rk = 0; rk < rkeys.length; rk++) {                                                                      // 479\n      var rkey = rkeys[rk];                                                                                          // 480\n      if (rkey !== 'protocol')                                                                                       // 481\n        result[rkey] = relative[rkey];                                                                               // 482\n    }                                                                                                                // 483\n                                                                                                                     // 484\n    //urlParse appends trailing / to urls like http://www.example.com                                                // 485\n    if (slashedProtocol[result.protocol] &&                                                                          // 486\n        result.hostname && !result.pathname) {                                                                       // 487\n      result.path = result.pathname = '/';                                                                           // 488\n    }                                                                                                                // 489\n                                                                                                                     // 490\n    result.href = result.format();                                                                                   // 491\n    return result;                                                                                                   // 492\n  }                                                                                                                  // 493\n                                                                                                                     // 494\n  if (relative.protocol && relative.protocol !== result.protocol) {                                                  // 495\n    // if it's a known url protocol, then changing                                                                   // 496\n    // the protocol does weird things                                                                                // 497\n    // first, if it's not file:, then we MUST have a host,                                                           // 498\n    // and if there was a path                                                                                       // 499\n    // to begin with, then we MUST have a path.                                                                      // 500\n    // if it is file:, then the host is dropped,                                                                     // 501\n    // because that's known to be hostless.                                                                          // 502\n    // anything else is assumed to be absolute.                                                                      // 503\n    if (!slashedProtocol[relative.protocol]) {                                                                       // 504\n      var keys = Object.keys(relative);                                                                              // 505\n      for (var v = 0; v < keys.length; v++) {                                                                        // 506\n        var k = keys[v];                                                                                             // 507\n        result[k] = relative[k];                                                                                     // 508\n      }                                                                                                              // 509\n      result.href = result.format();                                                                                 // 510\n      return result;                                                                                                 // 511\n    }                                                                                                                // 512\n                                                                                                                     // 513\n    result.protocol = relative.protocol;                                                                             // 514\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {                                                    // 515\n      var relPath = (relative.pathname || '').split('/');                                                            // 516\n      while (relPath.length && !(relative.host = relPath.shift()));                                                  // 517\n      if (!relative.host) relative.host = '';                                                                        // 518\n      if (!relative.hostname) relative.hostname = '';                                                                // 519\n      if (relPath[0] !== '') relPath.unshift('');                                                                    // 520\n      if (relPath.length < 2) relPath.unshift('');                                                                   // 521\n      result.pathname = relPath.join('/');                                                                           // 522\n    } else {                                                                                                         // 523\n      result.pathname = relative.pathname;                                                                           // 524\n    }                                                                                                                // 525\n    result.search = relative.search;                                                                                 // 526\n    result.query = relative.query;                                                                                   // 527\n    result.host = relative.host || '';                                                                               // 528\n    result.auth = relative.auth;                                                                                     // 529\n    result.hostname = relative.hostname || relative.host;                                                            // 530\n    result.port = relative.port;                                                                                     // 531\n    // to support http.request                                                                                       // 532\n    if (result.pathname || result.search) {                                                                          // 533\n      var p = result.pathname || '';                                                                                 // 534\n      var s = result.search || '';                                                                                   // 535\n      result.path = p + s;                                                                                           // 536\n    }                                                                                                                // 537\n    result.slashes = result.slashes || relative.slashes;                                                             // 538\n    result.href = result.format();                                                                                   // 539\n    return result;                                                                                                   // 540\n  }                                                                                                                  // 541\n                                                                                                                     // 542\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),                                          // 543\n      isRelAbs = (                                                                                                   // 544\n          relative.host ||                                                                                           // 545\n          relative.pathname && relative.pathname.charAt(0) === '/'                                                   // 546\n      ),                                                                                                             // 547\n      mustEndAbs = (isRelAbs || isSourceAbs ||                                                                       // 548\n                    (result.host && relative.pathname)),                                                             // 549\n      removeAllDots = mustEndAbs,                                                                                    // 550\n      srcPath = result.pathname && result.pathname.split('/') || [],                                                 // 551\n      relPath = relative.pathname && relative.pathname.split('/') || [],                                             // 552\n      psychotic = result.protocol && !slashedProtocol[result.protocol];                                              // 553\n                                                                                                                     // 554\n  // if the url is a non-slashed url, then relative                                                                  // 555\n  // links like ../.. should be able                                                                                 // 556\n  // to crawl up to the hostname, as well.  This is strange.                                                         // 557\n  // result.protocol has already been set by now.                                                                    // 558\n  // Later on, put the first path part into the host field.                                                          // 559\n  if (psychotic) {                                                                                                   // 560\n    result.hostname = '';                                                                                            // 561\n    result.port = null;                                                                                              // 562\n    if (result.host) {                                                                                               // 563\n      if (srcPath[0] === '') srcPath[0] = result.host;                                                               // 564\n      else srcPath.unshift(result.host);                                                                             // 565\n    }                                                                                                                // 566\n    result.host = '';                                                                                                // 567\n    if (relative.protocol) {                                                                                         // 568\n      relative.hostname = null;                                                                                      // 569\n      relative.port = null;                                                                                          // 570\n      if (relative.host) {                                                                                           // 571\n        if (relPath[0] === '') relPath[0] = relative.host;                                                           // 572\n        else relPath.unshift(relative.host);                                                                         // 573\n      }                                                                                                              // 574\n      relative.host = null;                                                                                          // 575\n    }                                                                                                                // 576\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');                                             // 577\n  }                                                                                                                  // 578\n                                                                                                                     // 579\n  if (isRelAbs) {                                                                                                    // 580\n    // it's absolute.                                                                                                // 581\n    result.host = (relative.host || relative.host === '') ?                                                          // 582\n                  relative.host : result.host;                                                                       // 583\n    result.hostname = (relative.hostname || relative.hostname === '') ?                                              // 584\n                      relative.hostname : result.hostname;                                                           // 585\n    result.search = relative.search;                                                                                 // 586\n    result.query = relative.query;                                                                                   // 587\n    srcPath = relPath;                                                                                               // 588\n    // fall through to the dot-handling below.                                                                       // 589\n  } else if (relPath.length) {                                                                                       // 590\n    // it's relative                                                                                                 // 591\n    // throw away the existing file, and take the new path instead.                                                  // 592\n    if (!srcPath) srcPath = [];                                                                                      // 593\n    srcPath.pop();                                                                                                   // 594\n    srcPath = srcPath.concat(relPath);                                                                               // 595\n    result.search = relative.search;                                                                                 // 596\n    result.query = relative.query;                                                                                   // 597\n  } else if (!util.isNullOrUndefined(relative.search)) {                                                             // 598\n    // just pull out the search.                                                                                     // 599\n    // like href='?foo'.                                                                                             // 600\n    // Put this after the other two cases because it simplifies the booleans                                         // 601\n    if (psychotic) {                                                                                                 // 602\n      result.hostname = result.host = srcPath.shift();                                                               // 603\n      //occationaly the auth can get stuck only in host                                                              // 604\n      //this especially happens in cases like                                                                        // 605\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')                                                 // 606\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?                                                 // 607\n                       result.host.split('@') : false;                                                               // 608\n      if (authInHost) {                                                                                              // 609\n        result.auth = authInHost.shift();                                                                            // 610\n        result.host = result.hostname = authInHost.shift();                                                          // 611\n      }                                                                                                              // 612\n    }                                                                                                                // 613\n    result.search = relative.search;                                                                                 // 614\n    result.query = relative.query;                                                                                   // 615\n    //to support http.request                                                                                        // 616\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {                                              // 617\n      result.path = (result.pathname ? result.pathname : '') +                                                       // 618\n                    (result.search ? result.search : '');                                                            // 619\n    }                                                                                                                // 620\n    result.href = result.format();                                                                                   // 621\n    return result;                                                                                                   // 622\n  }                                                                                                                  // 623\n                                                                                                                     // 624\n  if (!srcPath.length) {                                                                                             // 625\n    // no path at all.  easy.                                                                                        // 626\n    // we've already handled the other stuff above.                                                                  // 627\n    result.pathname = null;                                                                                          // 628\n    //to support http.request                                                                                        // 629\n    if (result.search) {                                                                                             // 630\n      result.path = '/' + result.search;                                                                             // 631\n    } else {                                                                                                         // 632\n      result.path = null;                                                                                            // 633\n    }                                                                                                                // 634\n    result.href = result.format();                                                                                   // 635\n    return result;                                                                                                   // 636\n  }                                                                                                                  // 637\n                                                                                                                     // 638\n  // if a url ENDs in . or .., then it must get a trailing slash.                                                    // 639\n  // however, if it ends in anything else non-slashy,                                                                // 640\n  // then it must NOT get a trailing slash.                                                                          // 641\n  var last = srcPath.slice(-1)[0];                                                                                   // 642\n  var hasTrailingSlash = (                                                                                           // 643\n      (result.host || relative.host || srcPath.length > 1) &&                                                        // 644\n      (last === '.' || last === '..') || last === '');                                                               // 645\n                                                                                                                     // 646\n  // strip single dots, resolve double dots to parent dir                                                            // 647\n  // if the path tries to go above the root, `up` ends up > 0                                                        // 648\n  var up = 0;                                                                                                        // 649\n  for (var i = srcPath.length; i >= 0; i--) {                                                                        // 650\n    last = srcPath[i];                                                                                               // 651\n    if (last === '.') {                                                                                              // 652\n      srcPath.splice(i, 1);                                                                                          // 653\n    } else if (last === '..') {                                                                                      // 654\n      srcPath.splice(i, 1);                                                                                          // 655\n      up++;                                                                                                          // 656\n    } else if (up) {                                                                                                 // 657\n      srcPath.splice(i, 1);                                                                                          // 658\n      up--;                                                                                                          // 659\n    }                                                                                                                // 660\n  }                                                                                                                  // 661\n                                                                                                                     // 662\n  // if the path is allowed to go above the root, restore leading ..s                                                // 663\n  if (!mustEndAbs && !removeAllDots) {                                                                               // 664\n    for (; up--; up) {                                                                                               // 665\n      srcPath.unshift('..');                                                                                         // 666\n    }                                                                                                                // 667\n  }                                                                                                                  // 668\n                                                                                                                     // 669\n  if (mustEndAbs && srcPath[0] !== '' &&                                                                             // 670\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {                                                               // 671\n    srcPath.unshift('');                                                                                             // 672\n  }                                                                                                                  // 673\n                                                                                                                     // 674\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {                                                  // 675\n    srcPath.push('');                                                                                                // 676\n  }                                                                                                                  // 677\n                                                                                                                     // 678\n  var isAbsolute = srcPath[0] === '' ||                                                                              // 679\n      (srcPath[0] && srcPath[0].charAt(0) === '/');                                                                  // 680\n                                                                                                                     // 681\n  // put the host back                                                                                               // 682\n  if (psychotic) {                                                                                                   // 683\n    result.hostname = result.host = isAbsolute ? '' :                                                                // 684\n                                    srcPath.length ? srcPath.shift() : '';                                           // 685\n    //occationaly the auth can get stuck only in host                                                                // 686\n    //this especially happens in cases like                                                                          // 687\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')                                                   // 688\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?                                                   // 689\n                     result.host.split('@') : false;                                                                 // 690\n    if (authInHost) {                                                                                                // 691\n      result.auth = authInHost.shift();                                                                              // 692\n      result.host = result.hostname = authInHost.shift();                                                            // 693\n    }                                                                                                                // 694\n  }                                                                                                                  // 695\n                                                                                                                     // 696\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);                                                        // 697\n                                                                                                                     // 698\n  if (mustEndAbs && !isAbsolute) {                                                                                   // 699\n    srcPath.unshift('');                                                                                             // 700\n  }                                                                                                                  // 701\n                                                                                                                     // 702\n  if (!srcPath.length) {                                                                                             // 703\n    result.pathname = null;                                                                                          // 704\n    result.path = null;                                                                                              // 705\n  } else {                                                                                                           // 706\n    result.pathname = srcPath.join('/');                                                                             // 707\n  }                                                                                                                  // 708\n                                                                                                                     // 709\n  //to support request.http                                                                                          // 710\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {                                                // 711\n    result.path = (result.pathname ? result.pathname : '') +                                                         // 712\n                  (result.search ? result.search : '');                                                              // 713\n  }                                                                                                                  // 714\n  result.auth = relative.auth || result.auth;                                                                        // 715\n  result.slashes = result.slashes || relative.slashes;                                                               // 716\n  result.href = result.format();                                                                                     // 717\n  return result;                                                                                                     // 718\n};                                                                                                                   // 719\n                                                                                                                     // 720\nUrl.prototype.parseHost = function() {                                                                               // 721\n  var host = this.host;                                                                                              // 722\n  var port = portPattern.exec(host);                                                                                 // 723\n  if (port) {                                                                                                        // 724\n    port = port[0];                                                                                                  // 725\n    if (port !== ':') {                                                                                              // 726\n      this.port = port.substr(1);                                                                                    // 727\n    }                                                                                                                // 728\n    host = host.substr(0, host.length - port.length);                                                                // 729\n  }                                                                                                                  // 730\n  if (host) this.hostname = host;                                                                                    // 731\n};                                                                                                                   // 732\n                                                                                                                     // 733\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"punycode\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/url/node_modules/punycode/package.json                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"punycode\";                                                                                           // 1\nexports.version = \"1.3.2\";                                                                                           // 2\nexports.main = \"punycode.js\";                                                                                        // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"punycode.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/url/node_modules/punycode/punycode.js                                 //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/*! https://mths.be/punycode v1.3.2 by @mathias */                                                                   // 1\n;(function(root) {                                                                                                   // 2\n                                                                                                                     // 3\n\t/** Detect free variables */                                                                                        // 4\n\tvar freeExports = typeof exports == 'object' && exports &&                                                          // 5\n\t\t!exports.nodeType && exports;                                                                                      // 6\n\tvar freeModule = typeof module == 'object' && module &&                                                             // 7\n\t\t!module.nodeType && module;                                                                                        // 8\n\tvar freeGlobal = typeof global == 'object' && global;                                                               // 9\n\tif (                                                                                                                // 10\n\t\tfreeGlobal.global === freeGlobal ||                                                                                // 11\n\t\tfreeGlobal.window === freeGlobal ||                                                                                // 12\n\t\tfreeGlobal.self === freeGlobal                                                                                     // 13\n\t) {                                                                                                                 // 14\n\t\troot = freeGlobal;                                                                                                 // 15\n\t}                                                                                                                   // 16\n                                                                                                                     // 17\n\t/**                                                                                                                 // 18\n\t * The `punycode` object.                                                                                           // 19\n\t * @name punycode                                                                                                   // 20\n\t * @type Object                                                                                                     // 21\n\t */                                                                                                                 // 22\n\tvar punycode,                                                                                                       // 23\n                                                                                                                     // 24\n\t/** Highest positive signed 32-bit float value */                                                                   // 25\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1                                                                   // 26\n                                                                                                                     // 27\n\t/** Bootstring parameters */                                                                                        // 28\n\tbase = 36,                                                                                                          // 29\n\ttMin = 1,                                                                                                           // 30\n\ttMax = 26,                                                                                                          // 31\n\tskew = 38,                                                                                                          // 32\n\tdamp = 700,                                                                                                         // 33\n\tinitialBias = 72,                                                                                                   // 34\n\tinitialN = 128, // 0x80                                                                                             // 35\n\tdelimiter = '-', // '\\x2D'                                                                                          // 36\n                                                                                                                     // 37\n\t/** Regular expressions */                                                                                          // 38\n\tregexPunycode = /^xn--/,                                                                                            // 39\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars                                        // 40\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators                                               // 41\n                                                                                                                     // 42\n\t/** Error messages */                                                                                               // 43\n\terrors = {                                                                                                          // 44\n\t\t'overflow': 'Overflow: input needs wider integers to process',                                                     // 45\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',                                                     // 46\n\t\t'invalid-input': 'Invalid input'                                                                                   // 47\n\t},                                                                                                                  // 48\n                                                                                                                     // 49\n\t/** Convenience shortcuts */                                                                                        // 50\n\tbaseMinusTMin = base - tMin,                                                                                        // 51\n\tfloor = Math.floor,                                                                                                 // 52\n\tstringFromCharCode = String.fromCharCode,                                                                           // 53\n                                                                                                                     // 54\n\t/** Temporary variable */                                                                                           // 55\n\tkey;                                                                                                                // 56\n                                                                                                                     // 57\n\t/*--------------------------------------------------------------------------*/                                      // 58\n                                                                                                                     // 59\n\t/**                                                                                                                 // 60\n\t * A generic error utility function.                                                                                // 61\n\t * @private                                                                                                         // 62\n\t * @param {String} type The error type.                                                                             // 63\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.                                        // 64\n\t */                                                                                                                 // 65\n\tfunction error(type) {                                                                                              // 66\n\t\tthrow RangeError(errors[type]);                                                                                    // 67\n\t}                                                                                                                   // 68\n                                                                                                                     // 69\n\t/**                                                                                                                 // 70\n\t * A generic `Array#map` utility function.                                                                          // 71\n\t * @private                                                                                                         // 72\n\t * @param {Array} array The array to iterate over.                                                                  // 73\n\t * @param {Function} callback The function that gets called for every array                                         // 74\n\t * item.                                                                                                            // 75\n\t * @returns {Array} A new array of values returned by the callback function.                                        // 76\n\t */                                                                                                                 // 77\n\tfunction map(array, fn) {                                                                                           // 78\n\t\tvar length = array.length;                                                                                         // 79\n\t\tvar result = [];                                                                                                   // 80\n\t\twhile (length--) {                                                                                                 // 81\n\t\t\tresult[length] = fn(array[length]);                                                                               // 82\n\t\t}                                                                                                                  // 83\n\t\treturn result;                                                                                                     // 84\n\t}                                                                                                                   // 85\n                                                                                                                     // 86\n\t/**                                                                                                                 // 87\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email                                      // 88\n\t * addresses.                                                                                                       // 89\n\t * @private                                                                                                         // 90\n\t * @param {String} domain The domain name or email address.                                                         // 91\n\t * @param {Function} callback The function that gets called for every                                               // 92\n\t * character.                                                                                                       // 93\n\t * @returns {Array} A new string of characters returned by the callback                                             // 94\n\t * function.                                                                                                        // 95\n\t */                                                                                                                 // 96\n\tfunction mapDomain(string, fn) {                                                                                    // 97\n\t\tvar parts = string.split('@');                                                                                     // 98\n\t\tvar result = '';                                                                                                   // 99\n\t\tif (parts.length > 1) {                                                                                            // 100\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave                                            // 101\n\t\t\t// the local part (i.e. everything up to `@`) intact.                                                             // 102\n\t\t\tresult = parts[0] + '@';                                                                                          // 103\n\t\t\tstring = parts[1];                                                                                                // 104\n\t\t}                                                                                                                  // 105\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.                                                            // 106\n\t\tstring = string.replace(regexSeparators, '\\x2E');                                                                  // 107\n\t\tvar labels = string.split('.');                                                                                    // 108\n\t\tvar encoded = map(labels, fn).join('.');                                                                           // 109\n\t\treturn result + encoded;                                                                                           // 110\n\t}                                                                                                                   // 111\n                                                                                                                     // 112\n\t/**                                                                                                                 // 113\n\t * Creates an array containing the numeric code points of each Unicode                                              // 114\n\t * character in the string. While JavaScript uses UCS-2 internally,                                                 // 115\n\t * this function will convert a pair of surrogate halves (each of which                                             // 116\n\t * UCS-2 exposes as separate characters) into a single code point,                                                  // 117\n\t * matching UTF-16.                                                                                                 // 118\n\t * @see `punycode.ucs2.encode`                                                                                      // 119\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>                                                        // 120\n\t * @memberOf punycode.ucs2                                                                                          // 121\n\t * @name decode                                                                                                     // 122\n\t * @param {String} string The Unicode input string (UCS-2).                                                         // 123\n\t * @returns {Array} The new array of code points.                                                                   // 124\n\t */                                                                                                                 // 125\n\tfunction ucs2decode(string) {                                                                                       // 126\n\t\tvar output = [],                                                                                                   // 127\n\t\t    counter = 0,                                                                                                   // 128\n\t\t    length = string.length,                                                                                        // 129\n\t\t    value,                                                                                                         // 130\n\t\t    extra;                                                                                                         // 131\n\t\twhile (counter < length) {                                                                                         // 132\n\t\t\tvalue = string.charCodeAt(counter++);                                                                             // 133\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {                                                     // 134\n\t\t\t\t// high surrogate, and there is a next character                                                                 // 135\n\t\t\t\textra = string.charCodeAt(counter++);                                                                            // 136\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate                                                               // 137\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);                                               // 138\n\t\t\t\t} else {                                                                                                         // 139\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next                                            // 140\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair                                                          // 141\n\t\t\t\t\toutput.push(value);                                                                                             // 142\n\t\t\t\t\tcounter--;                                                                                                      // 143\n\t\t\t\t}                                                                                                                // 144\n\t\t\t} else {                                                                                                          // 145\n\t\t\t\toutput.push(value);                                                                                              // 146\n\t\t\t}                                                                                                                 // 147\n\t\t}                                                                                                                  // 148\n\t\treturn output;                                                                                                     // 149\n\t}                                                                                                                   // 150\n                                                                                                                     // 151\n\t/**                                                                                                                 // 152\n\t * Creates a string based on an array of numeric code points.                                                       // 153\n\t * @see `punycode.ucs2.decode`                                                                                      // 154\n\t * @memberOf punycode.ucs2                                                                                          // 155\n\t * @name encode                                                                                                     // 156\n\t * @param {Array} codePoints The array of numeric code points.                                                      // 157\n\t * @returns {String} The new Unicode string (UCS-2).                                                                // 158\n\t */                                                                                                                 // 159\n\tfunction ucs2encode(array) {                                                                                        // 160\n\t\treturn map(array, function(value) {                                                                                // 161\n\t\t\tvar output = '';                                                                                                  // 162\n\t\t\tif (value > 0xFFFF) {                                                                                             // 163\n\t\t\t\tvalue -= 0x10000;                                                                                                // 164\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);                                                     // 165\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;                                                                                  // 166\n\t\t\t}                                                                                                                 // 167\n\t\t\toutput += stringFromCharCode(value);                                                                              // 168\n\t\t\treturn output;                                                                                                    // 169\n\t\t}).join('');                                                                                                       // 170\n\t}                                                                                                                   // 171\n                                                                                                                     // 172\n\t/**                                                                                                                 // 173\n\t * Converts a basic code point into a digit/integer.                                                                // 174\n\t * @see `digitToBasic()`                                                                                            // 175\n\t * @private                                                                                                         // 176\n\t * @param {Number} codePoint The basic numeric code point value.                                                    // 177\n\t * @returns {Number} The numeric value of a basic code point (for use in                                            // 178\n\t * representing integers) in the range `0` to `base - 1`, or `base` if                                              // 179\n\t * the code point does not represent a value.                                                                       // 180\n\t */                                                                                                                 // 181\n\tfunction basicToDigit(codePoint) {                                                                                  // 182\n\t\tif (codePoint - 48 < 10) {                                                                                         // 183\n\t\t\treturn codePoint - 22;                                                                                            // 184\n\t\t}                                                                                                                  // 185\n\t\tif (codePoint - 65 < 26) {                                                                                         // 186\n\t\t\treturn codePoint - 65;                                                                                            // 187\n\t\t}                                                                                                                  // 188\n\t\tif (codePoint - 97 < 26) {                                                                                         // 189\n\t\t\treturn codePoint - 97;                                                                                            // 190\n\t\t}                                                                                                                  // 191\n\t\treturn base;                                                                                                       // 192\n\t}                                                                                                                   // 193\n                                                                                                                     // 194\n\t/**                                                                                                                 // 195\n\t * Converts a digit/integer into a basic code point.                                                                // 196\n\t * @see `basicToDigit()`                                                                                            // 197\n\t * @private                                                                                                         // 198\n\t * @param {Number} digit The numeric value of a basic code point.                                                   // 199\n\t * @returns {Number} The basic code point whose value (when used for                                                // 200\n\t * representing integers) is `digit`, which needs to be in the range                                                // 201\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is                                                  // 202\n\t * used; else, the lowercase form is used. The behavior is undefined                                                // 203\n\t * if `flag` is non-zero and `digit` has no uppercase form.                                                         // 204\n\t */                                                                                                                 // 205\n\tfunction digitToBasic(digit, flag) {                                                                                // 206\n\t\t//  0..25 map to ASCII a..z or A..Z                                                                                // 207\n\t\t// 26..35 map to ASCII 0..9                                                                                        // 208\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);                                                        // 209\n\t}                                                                                                                   // 210\n                                                                                                                     // 211\n\t/**                                                                                                                 // 212\n\t * Bias adaptation function as per section 3.4 of RFC 3492.                                                         // 213\n\t * http://tools.ietf.org/html/rfc3492#section-3.4                                                                   // 214\n\t * @private                                                                                                         // 215\n\t */                                                                                                                 // 216\n\tfunction adapt(delta, numPoints, firstTime) {                                                                       // 217\n\t\tvar k = 0;                                                                                                         // 218\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;                                                              // 219\n\t\tdelta += floor(delta / numPoints);                                                                                 // 220\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {                                      // 221\n\t\t\tdelta = floor(delta / baseMinusTMin);                                                                             // 222\n\t\t}                                                                                                                  // 223\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));                                                    // 224\n\t}                                                                                                                   // 225\n                                                                                                                     // 226\n\t/**                                                                                                                 // 227\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode                                          // 228\n\t * symbols.                                                                                                         // 229\n\t * @memberOf punycode                                                                                               // 230\n\t * @param {String} input The Punycode string of ASCII-only symbols.                                                 // 231\n\t * @returns {String} The resulting string of Unicode symbols.                                                       // 232\n\t */                                                                                                                 // 233\n\tfunction decode(input) {                                                                                            // 234\n\t\t// Don't use UCS-2                                                                                                 // 235\n\t\tvar output = [],                                                                                                   // 236\n\t\t    inputLength = input.length,                                                                                    // 237\n\t\t    out,                                                                                                           // 238\n\t\t    i = 0,                                                                                                         // 239\n\t\t    n = initialN,                                                                                                  // 240\n\t\t    bias = initialBias,                                                                                            // 241\n\t\t    basic,                                                                                                         // 242\n\t\t    j,                                                                                                             // 243\n\t\t    index,                                                                                                         // 244\n\t\t    oldi,                                                                                                          // 245\n\t\t    w,                                                                                                             // 246\n\t\t    k,                                                                                                             // 247\n\t\t    digit,                                                                                                         // 248\n\t\t    t,                                                                                                             // 249\n\t\t    /** Cached calculation results */                                                                              // 250\n\t\t    baseMinusT;                                                                                                    // 251\n                                                                                                                     // 252\n\t\t// Handle the basic code points: let `basic` be the number of input code                                           // 253\n\t\t// points before the last delimiter, or `0` if there is none, then copy                                            // 254\n\t\t// the first basic code points to the output.                                                                      // 255\n                                                                                                                     // 256\n\t\tbasic = input.lastIndexOf(delimiter);                                                                              // 257\n\t\tif (basic < 0) {                                                                                                   // 258\n\t\t\tbasic = 0;                                                                                                        // 259\n\t\t}                                                                                                                  // 260\n                                                                                                                     // 261\n\t\tfor (j = 0; j < basic; ++j) {                                                                                      // 262\n\t\t\t// if it's not a basic code point                                                                                 // 263\n\t\t\tif (input.charCodeAt(j) >= 0x80) {                                                                                // 264\n\t\t\t\terror('not-basic');                                                                                              // 265\n\t\t\t}                                                                                                                 // 266\n\t\t\toutput.push(input.charCodeAt(j));                                                                                 // 267\n\t\t}                                                                                                                  // 268\n                                                                                                                     // 269\n\t\t// Main decoding loop: start just after the last delimiter if any basic code                                       // 270\n\t\t// points were copied; start at the beginning otherwise.                                                           // 271\n                                                                                                                     // 272\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {                          // 273\n                                                                                                                     // 274\n\t\t\t// `index` is the index of the next character to be consumed.                                                     // 275\n\t\t\t// Decode a generalized variable-length integer into `delta`,                                                     // 276\n\t\t\t// which gets added to `i`. The overflow checking is easier                                                       // 277\n\t\t\t// if we increase `i` as we go, then subtract off its starting                                                    // 278\n\t\t\t// value at the end to obtain `delta`.                                                                            // 279\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {                                                  // 280\n                                                                                                                     // 281\n\t\t\t\tif (index >= inputLength) {                                                                                      // 282\n\t\t\t\t\terror('invalid-input');                                                                                         // 283\n\t\t\t\t}                                                                                                                // 284\n                                                                                                                     // 285\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));                                                                 // 286\n                                                                                                                     // 287\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {                                                          // 288\n\t\t\t\t\terror('overflow');                                                                                              // 289\n\t\t\t\t}                                                                                                                // 290\n                                                                                                                     // 291\n\t\t\t\ti += digit * w;                                                                                                  // 292\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);                                                     // 293\n                                                                                                                     // 294\n\t\t\t\tif (digit < t) {                                                                                                 // 295\n\t\t\t\t\tbreak;                                                                                                          // 296\n\t\t\t\t}                                                                                                                // 297\n                                                                                                                     // 298\n\t\t\t\tbaseMinusT = base - t;                                                                                           // 299\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {                                                                            // 300\n\t\t\t\t\terror('overflow');                                                                                              // 301\n\t\t\t\t}                                                                                                                // 302\n                                                                                                                     // 303\n\t\t\t\tw *= baseMinusT;                                                                                                 // 304\n                                                                                                                     // 305\n\t\t\t}                                                                                                                 // 306\n                                                                                                                     // 307\n\t\t\tout = output.length + 1;                                                                                          // 308\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);                                                                           // 309\n                                                                                                                     // 310\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,                                                             // 311\n\t\t\t// incrementing `n` each time, so we'll fix that now:                                                             // 312\n\t\t\tif (floor(i / out) > maxInt - n) {                                                                                // 313\n\t\t\t\terror('overflow');                                                                                               // 314\n\t\t\t}                                                                                                                 // 315\n                                                                                                                     // 316\n\t\t\tn += floor(i / out);                                                                                              // 317\n\t\t\ti %= out;                                                                                                         // 318\n                                                                                                                     // 319\n\t\t\t// Insert `n` at position `i` of the output                                                                       // 320\n\t\t\toutput.splice(i++, 0, n);                                                                                         // 321\n                                                                                                                     // 322\n\t\t}                                                                                                                  // 323\n                                                                                                                     // 324\n\t\treturn ucs2encode(output);                                                                                         // 325\n\t}                                                                                                                   // 326\n                                                                                                                     // 327\n\t/**                                                                                                                 // 328\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a                                             // 329\n\t * Punycode string of ASCII-only symbols.                                                                           // 330\n\t * @memberOf punycode                                                                                               // 331\n\t * @param {String} input The string of Unicode symbols.                                                             // 332\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.                                           // 333\n\t */                                                                                                                 // 334\n\tfunction encode(input) {                                                                                            // 335\n\t\tvar n,                                                                                                             // 336\n\t\t    delta,                                                                                                         // 337\n\t\t    handledCPCount,                                                                                                // 338\n\t\t    basicLength,                                                                                                   // 339\n\t\t    bias,                                                                                                          // 340\n\t\t    j,                                                                                                             // 341\n\t\t    m,                                                                                                             // 342\n\t\t    q,                                                                                                             // 343\n\t\t    k,                                                                                                             // 344\n\t\t    t,                                                                                                             // 345\n\t\t    currentValue,                                                                                                  // 346\n\t\t    output = [],                                                                                                   // 347\n\t\t    /** `inputLength` will hold the number of code points in `input`. */                                           // 348\n\t\t    inputLength,                                                                                                   // 349\n\t\t    /** Cached calculation results */                                                                              // 350\n\t\t    handledCPCountPlusOne,                                                                                         // 351\n\t\t    baseMinusT,                                                                                                    // 352\n\t\t    qMinusT;                                                                                                       // 353\n                                                                                                                     // 354\n\t\t// Convert the input in UCS-2 to Unicode                                                                           // 355\n\t\tinput = ucs2decode(input);                                                                                         // 356\n                                                                                                                     // 357\n\t\t// Cache the length                                                                                                // 358\n\t\tinputLength = input.length;                                                                                        // 359\n                                                                                                                     // 360\n\t\t// Initialize the state                                                                                            // 361\n\t\tn = initialN;                                                                                                      // 362\n\t\tdelta = 0;                                                                                                         // 363\n\t\tbias = initialBias;                                                                                                // 364\n                                                                                                                     // 365\n\t\t// Handle the basic code points                                                                                    // 366\n\t\tfor (j = 0; j < inputLength; ++j) {                                                                                // 367\n\t\t\tcurrentValue = input[j];                                                                                          // 368\n\t\t\tif (currentValue < 0x80) {                                                                                        // 369\n\t\t\t\toutput.push(stringFromCharCode(currentValue));                                                                   // 370\n\t\t\t}                                                                                                                 // 371\n\t\t}                                                                                                                  // 372\n                                                                                                                     // 373\n\t\thandledCPCount = basicLength = output.length;                                                                      // 374\n                                                                                                                     // 375\n\t\t// `handledCPCount` is the number of code points that have been handled;                                           // 376\n\t\t// `basicLength` is the number of basic code points.                                                               // 377\n                                                                                                                     // 378\n\t\t// Finish the basic string - if it is not empty - with a delimiter                                                 // 379\n\t\tif (basicLength) {                                                                                                 // 380\n\t\t\toutput.push(delimiter);                                                                                           // 381\n\t\t}                                                                                                                  // 382\n                                                                                                                     // 383\n\t\t// Main encoding loop:                                                                                             // 384\n\t\twhile (handledCPCount < inputLength) {                                                                             // 385\n                                                                                                                     // 386\n\t\t\t// All non-basic code points < n have been handled already. Find the next                                         // 387\n\t\t\t// larger one:                                                                                                    // 388\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {                                                                   // 389\n\t\t\t\tcurrentValue = input[j];                                                                                         // 390\n\t\t\t\tif (currentValue >= n && currentValue < m) {                                                                     // 391\n\t\t\t\t\tm = currentValue;                                                                                               // 392\n\t\t\t\t}                                                                                                                // 393\n\t\t\t}                                                                                                                 // 394\n                                                                                                                     // 395\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,                                         // 396\n\t\t\t// but guard against overflow                                                                                     // 397\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;                                                                       // 398\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {                                                    // 399\n\t\t\t\terror('overflow');                                                                                               // 400\n\t\t\t}                                                                                                                 // 401\n                                                                                                                     // 402\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;                                                                         // 403\n\t\t\tn = m;                                                                                                            // 404\n                                                                                                                     // 405\n\t\t\tfor (j = 0; j < inputLength; ++j) {                                                                               // 406\n\t\t\t\tcurrentValue = input[j];                                                                                         // 407\n                                                                                                                     // 408\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {                                                                      // 409\n\t\t\t\t\terror('overflow');                                                                                              // 410\n\t\t\t\t}                                                                                                                // 411\n                                                                                                                     // 412\n\t\t\t\tif (currentValue == n) {                                                                                         // 413\n\t\t\t\t\t// Represent delta as a generalized variable-length integer                                                     // 414\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {                                                      // 415\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);                                                   // 416\n\t\t\t\t\t\tif (q < t) {                                                                                                   // 417\n\t\t\t\t\t\t\tbreak;                                                                                                        // 418\n\t\t\t\t\t\t}                                                                                                              // 419\n\t\t\t\t\t\tqMinusT = q - t;                                                                                               // 420\n\t\t\t\t\t\tbaseMinusT = base - t;                                                                                         // 421\n\t\t\t\t\t\toutput.push(                                                                                                   // 422\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))                                                 // 423\n\t\t\t\t\t\t);                                                                                                             // 424\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);                                                                               // 425\n\t\t\t\t\t}                                                                                                               // 426\n                                                                                                                     // 427\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));                                                            // 428\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);                                      // 429\n\t\t\t\t\tdelta = 0;                                                                                                      // 430\n\t\t\t\t\t++handledCPCount;                                                                                               // 431\n\t\t\t\t}                                                                                                                // 432\n\t\t\t}                                                                                                                 // 433\n                                                                                                                     // 434\n\t\t\t++delta;                                                                                                          // 435\n\t\t\t++n;                                                                                                              // 436\n                                                                                                                     // 437\n\t\t}                                                                                                                  // 438\n\t\treturn output.join('');                                                                                            // 439\n\t}                                                                                                                   // 440\n                                                                                                                     // 441\n\t/**                                                                                                                 // 442\n\t * Converts a Punycode string representing a domain name or an email address                                        // 443\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.                                        // 444\n\t * it doesn't matter if you call it on a string that has already been                                               // 445\n\t * converted to Unicode.                                                                                            // 446\n\t * @memberOf punycode                                                                                               // 447\n\t * @param {String} input The Punycoded domain name or email address to                                              // 448\n\t * convert to Unicode.                                                                                              // 449\n\t * @returns {String} The Unicode representation of the given Punycode                                               // 450\n\t * string.                                                                                                          // 451\n\t */                                                                                                                 // 452\n\tfunction toUnicode(input) {                                                                                         // 453\n\t\treturn mapDomain(input, function(string) {                                                                         // 454\n\t\t\treturn regexPunycode.test(string)                                                                                 // 455\n\t\t\t\t? decode(string.slice(4).toLowerCase())                                                                          // 456\n\t\t\t\t: string;                                                                                                        // 457\n\t\t});                                                                                                                // 458\n\t}                                                                                                                   // 459\n                                                                                                                     // 460\n\t/**                                                                                                                 // 461\n\t * Converts a Unicode string representing a domain name or an email address to                                      // 462\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,                                         // 463\n\t * i.e. it doesn't matter if you call it with a domain that's already in                                            // 464\n\t * ASCII.                                                                                                           // 465\n\t * @memberOf punycode                                                                                               // 466\n\t * @param {String} input The domain name or email address to convert, as a                                          // 467\n\t * Unicode string.                                                                                                  // 468\n\t * @returns {String} The Punycode representation of the given domain name or                                        // 469\n\t * email address.                                                                                                   // 470\n\t */                                                                                                                 // 471\n\tfunction toASCII(input) {                                                                                           // 472\n\t\treturn mapDomain(input, function(string) {                                                                         // 473\n\t\t\treturn regexNonASCII.test(string)                                                                                 // 474\n\t\t\t\t? 'xn--' + encode(string)                                                                                        // 475\n\t\t\t\t: string;                                                                                                        // 476\n\t\t});                                                                                                                // 477\n\t}                                                                                                                   // 478\n                                                                                                                     // 479\n\t/*--------------------------------------------------------------------------*/                                      // 480\n                                                                                                                     // 481\n\t/** Define the public API */                                                                                        // 482\n\tpunycode = {                                                                                                        // 483\n\t\t/**                                                                                                                // 484\n\t\t * A string representing the current Punycode.js version number.                                                   // 485\n\t\t * @memberOf punycode                                                                                              // 486\n\t\t * @type String                                                                                                    // 487\n\t\t */                                                                                                                // 488\n\t\t'version': '1.3.2',                                                                                                // 489\n\t\t/**                                                                                                                // 490\n\t\t * An object of methods to convert from JavaScript's internal character                                            // 491\n\t\t * representation (UCS-2) to Unicode code points, and back.                                                        // 492\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>                                                       // 493\n\t\t * @memberOf punycode                                                                                              // 494\n\t\t * @type Object                                                                                                    // 495\n\t\t */                                                                                                                // 496\n\t\t'ucs2': {                                                                                                          // 497\n\t\t\t'decode': ucs2decode,                                                                                             // 498\n\t\t\t'encode': ucs2encode                                                                                              // 499\n\t\t},                                                                                                                 // 500\n\t\t'decode': decode,                                                                                                  // 501\n\t\t'encode': encode,                                                                                                  // 502\n\t\t'toASCII': toASCII,                                                                                                // 503\n\t\t'toUnicode': toUnicode                                                                                             // 504\n\t};                                                                                                                  // 505\n                                                                                                                     // 506\n\t/** Expose `punycode` */                                                                                            // 507\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns                                      // 508\n\t// like the following:                                                                                              // 509\n\tif (                                                                                                                // 510\n\t\ttypeof define == 'function' &&                                                                                     // 511\n\t\ttypeof define.amd == 'object' &&                                                                                   // 512\n\t\tdefine.amd                                                                                                         // 513\n\t) {                                                                                                                 // 514\n\t\tdefine('punycode', function() {                                                                                    // 515\n\t\t\treturn punycode;                                                                                                  // 516\n\t\t});                                                                                                                // 517\n\t} else if (freeExports && freeModule) {                                                                             // 518\n\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+                                              // 519\n\t\t\tfreeModule.exports = punycode;                                                                                    // 520\n\t\t} else { // in Narwhal or RingoJS v0.7.0-                                                                          // 521\n\t\t\tfor (key in punycode) {                                                                                           // 522\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);                                              // 523\n\t\t\t}                                                                                                                 // 524\n\t\t}                                                                                                                  // 525\n\t} else { // in Rhino or a web browser                                                                               // 526\n\t\troot.punycode = punycode;                                                                                          // 527\n\t}                                                                                                                   // 528\n                                                                                                                     // 529\n}(this));                                                                                                            // 530\n                                                                                                                     // 531\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"querystring\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/url/node_modules/querystring/package.json                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"querystring\";                                                                                        // 1\nexports.version = \"0.2.0\";                                                                                           // 2\n                                                                                                                     // 3\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"./decode\",\"./encode\",function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/url/node_modules/querystring/index.js                                 //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n'use strict';                                                                                                        // 1\n                                                                                                                     // 2\nexports.decode = exports.parse = require('./decode');                                                                // 3\nexports.encode = exports.stringify = require('./encode');                                                            // 4\n                                                                                                                     // 5\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"decode.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/url/node_modules/querystring/decode.js                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n'use strict';                                                                                                        // 22\n                                                                                                                     // 23\n// If obj.hasOwnProperty has been overridden, then calling                                                           // 24\n// obj.hasOwnProperty(prop) will break.                                                                              // 25\n// See: https://github.com/joyent/node/issues/1707                                                                   // 26\nfunction hasOwnProperty(obj, prop) {                                                                                 // 27\n  return Object.prototype.hasOwnProperty.call(obj, prop);                                                            // 28\n}                                                                                                                    // 29\n                                                                                                                     // 30\nmodule.exports = function(qs, sep, eq, options) {                                                                    // 31\n  sep = sep || '&';                                                                                                  // 32\n  eq = eq || '=';                                                                                                    // 33\n  var obj = {};                                                                                                      // 34\n                                                                                                                     // 35\n  if (typeof qs !== 'string' || qs.length === 0) {                                                                   // 36\n    return obj;                                                                                                      // 37\n  }                                                                                                                  // 38\n                                                                                                                     // 39\n  var regexp = /\\+/g;                                                                                                // 40\n  qs = qs.split(sep);                                                                                                // 41\n                                                                                                                     // 42\n  var maxKeys = 1000;                                                                                                // 43\n  if (options && typeof options.maxKeys === 'number') {                                                              // 44\n    maxKeys = options.maxKeys;                                                                                       // 45\n  }                                                                                                                  // 46\n                                                                                                                     // 47\n  var len = qs.length;                                                                                               // 48\n  // maxKeys <= 0 means that we should not limit keys count                                                          // 49\n  if (maxKeys > 0 && len > maxKeys) {                                                                                // 50\n    len = maxKeys;                                                                                                   // 51\n  }                                                                                                                  // 52\n                                                                                                                     // 53\n  for (var i = 0; i < len; ++i) {                                                                                    // 54\n    var x = qs[i].replace(regexp, '%20'),                                                                            // 55\n        idx = x.indexOf(eq),                                                                                         // 56\n        kstr, vstr, k, v;                                                                                            // 57\n                                                                                                                     // 58\n    if (idx >= 0) {                                                                                                  // 59\n      kstr = x.substr(0, idx);                                                                                       // 60\n      vstr = x.substr(idx + 1);                                                                                      // 61\n    } else {                                                                                                         // 62\n      kstr = x;                                                                                                      // 63\n      vstr = '';                                                                                                     // 64\n    }                                                                                                                // 65\n                                                                                                                     // 66\n    k = decodeURIComponent(kstr);                                                                                    // 67\n    v = decodeURIComponent(vstr);                                                                                    // 68\n                                                                                                                     // 69\n    if (!hasOwnProperty(obj, k)) {                                                                                   // 70\n      obj[k] = v;                                                                                                    // 71\n    } else if (Array.isArray(obj[k])) {                                                                              // 72\n      obj[k].push(v);                                                                                                // 73\n    } else {                                                                                                         // 74\n      obj[k] = [obj[k], v];                                                                                          // 75\n    }                                                                                                                // 76\n  }                                                                                                                  // 77\n                                                                                                                     // 78\n  return obj;                                                                                                        // 79\n};                                                                                                                   // 80\n                                                                                                                     // 81\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"encode.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/url/node_modules/querystring/encode.js                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n'use strict';                                                                                                        // 22\n                                                                                                                     // 23\nvar stringifyPrimitive = function(v) {                                                                               // 24\n  switch (typeof v) {                                                                                                // 25\n    case 'string':                                                                                                   // 26\n      return v;                                                                                                      // 27\n                                                                                                                     // 28\n    case 'boolean':                                                                                                  // 29\n      return v ? 'true' : 'false';                                                                                   // 30\n                                                                                                                     // 31\n    case 'number':                                                                                                   // 32\n      return isFinite(v) ? v : '';                                                                                   // 33\n                                                                                                                     // 34\n    default:                                                                                                         // 35\n      return '';                                                                                                     // 36\n  }                                                                                                                  // 37\n};                                                                                                                   // 38\n                                                                                                                     // 39\nmodule.exports = function(obj, sep, eq, name) {                                                                      // 40\n  sep = sep || '&';                                                                                                  // 41\n  eq = eq || '=';                                                                                                    // 42\n  if (obj === null) {                                                                                                // 43\n    obj = undefined;                                                                                                 // 44\n  }                                                                                                                  // 45\n                                                                                                                     // 46\n  if (typeof obj === 'object') {                                                                                     // 47\n    return Object.keys(obj).map(function(k) {                                                                        // 48\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;                                                       // 49\n      if (Array.isArray(obj[k])) {                                                                                   // 50\n        return obj[k].map(function(v) {                                                                              // 51\n          return ks + encodeURIComponent(stringifyPrimitive(v));                                                     // 52\n        }).join(sep);                                                                                                // 53\n      } else {                                                                                                       // 54\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));                                                  // 55\n      }                                                                                                              // 56\n    }).join(sep);                                                                                                    // 57\n                                                                                                                     // 58\n  }                                                                                                                  // 59\n                                                                                                                     // 60\n  if (!name) return '';                                                                                              // 61\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +                                                         // 62\n         encodeURIComponent(stringifyPrimitive(obj));                                                                // 63\n};                                                                                                                   // 64\n                                                                                                                     // 65\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"util.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/url/util.js                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n'use strict';                                                                                                        // 1\n                                                                                                                     // 2\nmodule.exports = {                                                                                                   // 3\n  isString: function(arg) {                                                                                          // 4\n    return typeof(arg) === 'string';                                                                                 // 5\n  },                                                                                                                 // 6\n  isObject: function(arg) {                                                                                          // 7\n    return typeof(arg) === 'object' && arg !== null;                                                                 // 8\n  },                                                                                                                 // 9\n  isNull: function(arg) {                                                                                            // 10\n    return arg === null;                                                                                             // 11\n  },                                                                                                                 // 12\n  isNullOrUndefined: function(arg) {                                                                                 // 13\n    return arg == null;                                                                                              // 14\n  }                                                                                                                  // 15\n};                                                                                                                   // 16\n                                                                                                                     // 17\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"path-browserify\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/path-browserify/package.json                                          //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"path-browserify\";                                                                                    // 1\nexports.version = \"0.0.0\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/path-browserify/index.js                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n// resolves . and .. elements in a path array with directory names there                                             // 22\n// must be no slashes, empty elements, or device names (c:\\) in the array                                            // 23\n// (so also no leading and trailing slashes - it does not distinguish                                                // 24\n// relative and absolute paths)                                                                                      // 25\nfunction normalizeArray(parts, allowAboveRoot) {                                                                     // 26\n  // if the path tries to go above the root, `up` ends up > 0                                                        // 27\n  var up = 0;                                                                                                        // 28\n  for (var i = parts.length - 1; i >= 0; i--) {                                                                      // 29\n    var last = parts[i];                                                                                             // 30\n    if (last === '.') {                                                                                              // 31\n      parts.splice(i, 1);                                                                                            // 32\n    } else if (last === '..') {                                                                                      // 33\n      parts.splice(i, 1);                                                                                            // 34\n      up++;                                                                                                          // 35\n    } else if (up) {                                                                                                 // 36\n      parts.splice(i, 1);                                                                                            // 37\n      up--;                                                                                                          // 38\n    }                                                                                                                // 39\n  }                                                                                                                  // 40\n                                                                                                                     // 41\n  // if the path is allowed to go above the root, restore leading ..s                                                // 42\n  if (allowAboveRoot) {                                                                                              // 43\n    for (; up--; up) {                                                                                               // 44\n      parts.unshift('..');                                                                                           // 45\n    }                                                                                                                // 46\n  }                                                                                                                  // 47\n                                                                                                                     // 48\n  return parts;                                                                                                      // 49\n}                                                                                                                    // 50\n                                                                                                                     // 51\n// Split a filename into [root, dir, basename, ext], unix version                                                    // 52\n// 'root' is just a slash, or nothing.                                                                               // 53\nvar splitPathRe =                                                                                                    // 54\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;                                                 // 55\nvar splitPath = function(filename) {                                                                                 // 56\n  return splitPathRe.exec(filename).slice(1);                                                                        // 57\n};                                                                                                                   // 58\n                                                                                                                     // 59\n// path.resolve([from ...], to)                                                                                      // 60\n// posix version                                                                                                     // 61\nexports.resolve = function() {                                                                                       // 62\n  var resolvedPath = '',                                                                                             // 63\n      resolvedAbsolute = false;                                                                                      // 64\n                                                                                                                     // 65\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {                                            // 66\n    var path = (i >= 0) ? arguments[i] : process.cwd();                                                              // 67\n                                                                                                                     // 68\n    // Skip empty and invalid entries                                                                                // 69\n    if (typeof path !== 'string') {                                                                                  // 70\n      throw new TypeError('Arguments to path.resolve must be strings');                                              // 71\n    } else if (!path) {                                                                                              // 72\n      continue;                                                                                                      // 73\n    }                                                                                                                // 74\n                                                                                                                     // 75\n    resolvedPath = path + '/' + resolvedPath;                                                                        // 76\n    resolvedAbsolute = path.charAt(0) === '/';                                                                       // 77\n  }                                                                                                                  // 78\n                                                                                                                     // 79\n  // At this point the path should be resolved to a full absolute path, but                                          // 80\n  // handle relative paths to be safe (might happen when process.cwd() fails)                                        // 81\n                                                                                                                     // 82\n  // Normalize the path                                                                                              // 83\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {                                        // 84\n    return !!p;                                                                                                      // 85\n  }), !resolvedAbsolute).join('/');                                                                                  // 86\n                                                                                                                     // 87\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';                                                      // 88\n};                                                                                                                   // 89\n                                                                                                                     // 90\n// path.normalize(path)                                                                                              // 91\n// posix version                                                                                                     // 92\nexports.normalize = function(path) {                                                                                 // 93\n  var isAbsolute = exports.isAbsolute(path),                                                                         // 94\n      trailingSlash = substr(path, -1) === '/';                                                                      // 95\n                                                                                                                     // 96\n  // Normalize the path                                                                                              // 97\n  path = normalizeArray(filter(path.split('/'), function(p) {                                                        // 98\n    return !!p;                                                                                                      // 99\n  }), !isAbsolute).join('/');                                                                                        // 100\n                                                                                                                     // 101\n  if (!path && !isAbsolute) {                                                                                        // 102\n    path = '.';                                                                                                      // 103\n  }                                                                                                                  // 104\n  if (path && trailingSlash) {                                                                                       // 105\n    path += '/';                                                                                                     // 106\n  }                                                                                                                  // 107\n                                                                                                                     // 108\n  return (isAbsolute ? '/' : '') + path;                                                                             // 109\n};                                                                                                                   // 110\n                                                                                                                     // 111\n// posix version                                                                                                     // 112\nexports.isAbsolute = function(path) {                                                                                // 113\n  return path.charAt(0) === '/';                                                                                     // 114\n};                                                                                                                   // 115\n                                                                                                                     // 116\n// posix version                                                                                                     // 117\nexports.join = function() {                                                                                          // 118\n  var paths = Array.prototype.slice.call(arguments, 0);                                                              // 119\n  return exports.normalize(filter(paths, function(p, index) {                                                        // 120\n    if (typeof p !== 'string') {                                                                                     // 121\n      throw new TypeError('Arguments to path.join must be strings');                                                 // 122\n    }                                                                                                                // 123\n    return p;                                                                                                        // 124\n  }).join('/'));                                                                                                     // 125\n};                                                                                                                   // 126\n                                                                                                                     // 127\n                                                                                                                     // 128\n// path.relative(from, to)                                                                                           // 129\n// posix version                                                                                                     // 130\nexports.relative = function(from, to) {                                                                              // 131\n  from = exports.resolve(from).substr(1);                                                                            // 132\n  to = exports.resolve(to).substr(1);                                                                                // 133\n                                                                                                                     // 134\n  function trim(arr) {                                                                                               // 135\n    var start = 0;                                                                                                   // 136\n    for (; start < arr.length; start++) {                                                                            // 137\n      if (arr[start] !== '') break;                                                                                  // 138\n    }                                                                                                                // 139\n                                                                                                                     // 140\n    var end = arr.length - 1;                                                                                        // 141\n    for (; end >= 0; end--) {                                                                                        // 142\n      if (arr[end] !== '') break;                                                                                    // 143\n    }                                                                                                                // 144\n                                                                                                                     // 145\n    if (start > end) return [];                                                                                      // 146\n    return arr.slice(start, end - start + 1);                                                                        // 147\n  }                                                                                                                  // 148\n                                                                                                                     // 149\n  var fromParts = trim(from.split('/'));                                                                             // 150\n  var toParts = trim(to.split('/'));                                                                                 // 151\n                                                                                                                     // 152\n  var length = Math.min(fromParts.length, toParts.length);                                                           // 153\n  var samePartsLength = length;                                                                                      // 154\n  for (var i = 0; i < length; i++) {                                                                                 // 155\n    if (fromParts[i] !== toParts[i]) {                                                                               // 156\n      samePartsLength = i;                                                                                           // 157\n      break;                                                                                                         // 158\n    }                                                                                                                // 159\n  }                                                                                                                  // 160\n                                                                                                                     // 161\n  var outputParts = [];                                                                                              // 162\n  for (var i = samePartsLength; i < fromParts.length; i++) {                                                         // 163\n    outputParts.push('..');                                                                                          // 164\n  }                                                                                                                  // 165\n                                                                                                                     // 166\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));                                                  // 167\n                                                                                                                     // 168\n  return outputParts.join('/');                                                                                      // 169\n};                                                                                                                   // 170\n                                                                                                                     // 171\nexports.sep = '/';                                                                                                   // 172\nexports.delimiter = ':';                                                                                             // 173\n                                                                                                                     // 174\nexports.dirname = function(path) {                                                                                   // 175\n  var result = splitPath(path),                                                                                      // 176\n      root = result[0],                                                                                              // 177\n      dir = result[1];                                                                                               // 178\n                                                                                                                     // 179\n  if (!root && !dir) {                                                                                               // 180\n    // No dirname whatsoever                                                                                         // 181\n    return '.';                                                                                                      // 182\n  }                                                                                                                  // 183\n                                                                                                                     // 184\n  if (dir) {                                                                                                         // 185\n    // It has a dirname, strip trailing slash                                                                        // 186\n    dir = dir.substr(0, dir.length - 1);                                                                             // 187\n  }                                                                                                                  // 188\n                                                                                                                     // 189\n  return root + dir;                                                                                                 // 190\n};                                                                                                                   // 191\n                                                                                                                     // 192\n                                                                                                                     // 193\nexports.basename = function(path, ext) {                                                                             // 194\n  var f = splitPath(path)[2];                                                                                        // 195\n  // TODO: make this comparison case-insensitive on windows?                                                         // 196\n  if (ext && f.substr(-1 * ext.length) === ext) {                                                                    // 197\n    f = f.substr(0, f.length - ext.length);                                                                          // 198\n  }                                                                                                                  // 199\n  return f;                                                                                                          // 200\n};                                                                                                                   // 201\n                                                                                                                     // 202\n                                                                                                                     // 203\nexports.extname = function(path) {                                                                                   // 204\n  return splitPath(path)[3];                                                                                         // 205\n};                                                                                                                   // 206\n                                                                                                                     // 207\nfunction filter (xs, f) {                                                                                            // 208\n    if (xs.filter) return xs.filter(f);                                                                              // 209\n    var res = [];                                                                                                    // 210\n    for (var i = 0; i < xs.length; i++) {                                                                            // 211\n        if (f(xs[i], i, xs)) res.push(xs[i]);                                                                        // 212\n    }                                                                                                                // 213\n    return res;                                                                                                      // 214\n}                                                                                                                    // 215\n                                                                                                                     // 216\n// String.prototype.substr - negative index don't work in IE8                                                        // 217\nvar substr = 'ab'.substr(-1) === 'b'                                                                                 // 218\n    ? function (str, start, len) { return str.substr(start, len) }                                                   // 219\n    : function (str, start, len) {                                                                                   // 220\n        if (start < 0) start = str.length + start;                                                                   // 221\n        return str.substr(start, len);                                                                               // 222\n    }                                                                                                                // 223\n;                                                                                                                    // 224\n                                                                                                                     // 225\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"process\":{\"browser.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/process/browser.js                                                    //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// shim for using process in browser                                                                                 // 1\n                                                                                                                     // 2\nvar process = module.exports = {};                                                                                   // 3\nvar queue = [];                                                                                                      // 4\nvar draining = false;                                                                                                // 5\nvar currentQueue;                                                                                                    // 6\nvar queueIndex = -1;                                                                                                 // 7\n                                                                                                                     // 8\nfunction cleanUpNextTick() {                                                                                         // 9\n    draining = false;                                                                                                // 10\n    if (currentQueue.length) {                                                                                       // 11\n        queue = currentQueue.concat(queue);                                                                          // 12\n    } else {                                                                                                         // 13\n        queueIndex = -1;                                                                                             // 14\n    }                                                                                                                // 15\n    if (queue.length) {                                                                                              // 16\n        drainQueue();                                                                                                // 17\n    }                                                                                                                // 18\n}                                                                                                                    // 19\n                                                                                                                     // 20\nfunction drainQueue() {                                                                                              // 21\n    if (draining) {                                                                                                  // 22\n        return;                                                                                                      // 23\n    }                                                                                                                // 24\n    var timeout = setTimeout(cleanUpNextTick);                                                                       // 25\n    draining = true;                                                                                                 // 26\n                                                                                                                     // 27\n    var len = queue.length;                                                                                          // 28\n    while(len) {                                                                                                     // 29\n        currentQueue = queue;                                                                                        // 30\n        queue = [];                                                                                                  // 31\n        while (++queueIndex < len) {                                                                                 // 32\n            if (currentQueue) {                                                                                      // 33\n                currentQueue[queueIndex].run();                                                                      // 34\n            }                                                                                                        // 35\n        }                                                                                                            // 36\n        queueIndex = -1;                                                                                             // 37\n        len = queue.length;                                                                                          // 38\n    }                                                                                                                // 39\n    currentQueue = null;                                                                                             // 40\n    draining = false;                                                                                                // 41\n    clearTimeout(timeout);                                                                                           // 42\n}                                                                                                                    // 43\n                                                                                                                     // 44\nprocess.nextTick = function (fun) {                                                                                  // 45\n    var args = new Array(arguments.length - 1);                                                                      // 46\n    if (arguments.length > 1) {                                                                                      // 47\n        for (var i = 1; i < arguments.length; i++) {                                                                 // 48\n            args[i - 1] = arguments[i];                                                                              // 49\n        }                                                                                                            // 50\n    }                                                                                                                // 51\n    queue.push(new Item(fun, args));                                                                                 // 52\n    if (queue.length === 1 && !draining) {                                                                           // 53\n        setTimeout(drainQueue, 0);                                                                                   // 54\n    }                                                                                                                // 55\n};                                                                                                                   // 56\n                                                                                                                     // 57\n// v8 likes predictible objects                                                                                      // 58\nfunction Item(fun, array) {                                                                                          // 59\n    this.fun = fun;                                                                                                  // 60\n    this.array = array;                                                                                              // 61\n}                                                                                                                    // 62\nItem.prototype.run = function () {                                                                                   // 63\n    this.fun.apply(null, this.array);                                                                                // 64\n};                                                                                                                   // 65\nprocess.title = 'browser';                                                                                           // 66\nprocess.browser = true;                                                                                              // 67\nprocess.env = {};                                                                                                    // 68\nprocess.argv = [];                                                                                                   // 69\nprocess.version = ''; // empty string to avoid regexp issues                                                         // 70\nprocess.versions = {};                                                                                               // 71\n                                                                                                                     // 72\nfunction noop() {}                                                                                                   // 73\n                                                                                                                     // 74\nprocess.on = noop;                                                                                                   // 75\nprocess.addListener = noop;                                                                                          // 76\nprocess.once = noop;                                                                                                 // 77\nprocess.off = noop;                                                                                                  // 78\nprocess.removeListener = noop;                                                                                       // 79\nprocess.removeAllListeners = noop;                                                                                   // 80\nprocess.emit = noop;                                                                                                 // 81\n                                                                                                                     // 82\nprocess.binding = function (name) {                                                                                  // 83\n    throw new Error('process.binding is not supported');                                                             // 84\n};                                                                                                                   // 85\n                                                                                                                     // 86\nprocess.cwd = function () { return '/' };                                                                            // 87\nprocess.chdir = function (dir) {                                                                                     // 88\n    throw new Error('process.chdir is not supported');                                                               // 89\n};                                                                                                                   // 90\nprocess.umask = function() { return 0; };                                                                            // 91\n                                                                                                                     // 92\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"domain-browser\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/domain-browser/package.json                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"domain-browser\";                                                                                     // 1\nexports.version = \"1.1.7\";                                                                                           // 2\nexports.main = \"./index.js\";                                                                                         // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"events\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/node_modules/domain-browser/index.js                                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// This file should be ES5 compatible                                                                                // 1\n/* eslint prefer-spread:0, no-var:0, prefer-reflect:0, no-magic-numbers:0 */                                         // 2\n'use strict'                                                                                                         // 3\nmodule.exports = (function () {                                                                                      // 4\n\t// Import Events                                                                                                    // 5\n\tvar events = require('events')                                                                                      // 6\n                                                                                                                     // 7\n\t// Export Domain                                                                                                    // 8\n\tvar domain = {}                                                                                                     // 9\n\tdomain.createDomain = domain.create = function () {                                                                 // 10\n\t\tvar d = new events.EventEmitter()                                                                                  // 11\n                                                                                                                     // 12\n\t\tfunction emitError (e) {                                                                                           // 13\n\t\t\td.emit('error', e)                                                                                                // 14\n\t\t}                                                                                                                  // 15\n                                                                                                                     // 16\n\t\td.add = function (emitter) {                                                                                       // 17\n\t\t\temitter.on('error', emitError)                                                                                    // 18\n\t\t}                                                                                                                  // 19\n\t\td.remove = function (emitter) {                                                                                    // 20\n\t\t\temitter.removeListener('error', emitError)                                                                        // 21\n\t\t}                                                                                                                  // 22\n\t\td.bind = function (fn) {                                                                                           // 23\n\t\t\treturn function () {                                                                                              // 24\n\t\t\t\tvar args = Array.prototype.slice.call(arguments)                                                                 // 25\n\t\t\t\ttry {                                                                                                            // 26\n\t\t\t\t\tfn.apply(null, args)                                                                                            // 27\n\t\t\t\t}                                                                                                                // 28\n\t\t\t\tcatch (err) {                                                                                                    // 29\n\t\t\t\t\temitError(err)                                                                                                  // 30\n\t\t\t\t}                                                                                                                // 31\n\t\t\t}                                                                                                                 // 32\n\t\t}                                                                                                                  // 33\n\t\td.intercept = function (fn) {                                                                                      // 34\n\t\t\treturn function (err) {                                                                                           // 35\n\t\t\t\tif ( err ) {                                                                                                     // 36\n\t\t\t\t\temitError(err)                                                                                                  // 37\n\t\t\t\t}                                                                                                                // 38\n\t\t\t\telse {                                                                                                           // 39\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments, 1)                                                             // 40\n\t\t\t\t\ttry {                                                                                                           // 41\n\t\t\t\t\t\tfn.apply(null, args)                                                                                           // 42\n\t\t\t\t\t}                                                                                                               // 43\n\t\t\t\t\tcatch (err) {                                                                                                   // 44\n\t\t\t\t\t\temitError(err)                                                                                                 // 45\n\t\t\t\t\t}                                                                                                               // 46\n\t\t\t\t}                                                                                                                // 47\n\t\t\t}                                                                                                                 // 48\n\t\t}                                                                                                                  // 49\n\t\td.run = function (fn) {                                                                                            // 50\n\t\t\ttry {                                                                                                             // 51\n\t\t\t\tfn()                                                                                                             // 52\n\t\t\t}                                                                                                                 // 53\n\t\t\tcatch (err) {                                                                                                     // 54\n\t\t\t\temitError(err)                                                                                                   // 55\n\t\t\t}                                                                                                                 // 56\n\t\t\treturn this                                                                                                       // 57\n\t\t}                                                                                                                  // 58\n\t\td.dispose = function () {                                                                                          // 59\n\t\t\tthis.removeAllListeners()                                                                                         // 60\n\t\t\treturn this                                                                                                       // 61\n\t\t}                                                                                                                  // 62\n\t\td.enter = d.exit = function () {                                                                                   // 63\n\t\t\treturn this                                                                                                       // 64\n\t\t}                                                                                                                  // 65\n\t\treturn d                                                                                                           // 66\n\t}                                                                                                                   // 67\n\treturn domain                                                                                                       // 68\n}).call(this)                                                                                                        // 69\n                                                                                                                     // 70\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}},\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/package.json                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"meteor-node-stubs\";                                                                                  // 1\nexports.version = \"0.2.3\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"./map.json\",function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/index.js                                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar map = require(\"./map.json\");                                                                                     // 1\nvar meteorAliases = {};                                                                                              // 2\n                                                                                                                     // 3\nObject.keys(map).forEach(function (id) {                                                                             // 4\n  if (typeof map[id] === \"string\") {                                                                                 // 5\n    try {                                                                                                            // 6\n      exports[id] = meteorAliases[id + \".js\"] =                                                                      // 7\n        require.resolve(map[id]);                                                                                    // 8\n    } catch (e) {                                                                                                    // 9\n      // Resolution can fail at runtime if the stub was not included in the                                          // 10\n      // bundle because nothing depended on it.                                                                      // 11\n    }                                                                                                                // 12\n  } else {                                                                                                           // 13\n    exports[id] = map[id];                                                                                           // 14\n    meteorAliases[id + \".js\"] = function(){};                                                                        // 15\n  }                                                                                                                  // 16\n});                                                                                                                  // 17\n                                                                                                                     // 18\nif (typeof meteorInstall === \"function\") {                                                                           // 19\n  meteorInstall({                                                                                                    // 20\n    // Install the aliases into a node_modules directory one level up from                                           // 21\n    // the root directory, so that they do not clutter the namespace                                                 // 22\n    // available to apps and packages.                                                                               // 23\n    \"..\": {                                                                                                          // 24\n      node_modules: meteorAliases                                                                                    // 25\n    }                                                                                                                // 26\n  });                                                                                                                // 27\n}                                                                                                                    // 28\n                                                                                                                     // 29\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"map.json\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor-node-stubs/map.json                                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.exports = {                                                                                                   // 1\n  \"assert\": \"assert/\",                                                                                               // 2\n  \"buffer\": \"buffer/\",                                                                                               // 3\n  \"child_process\": null,                                                                                             // 4\n  \"cluster\": null,                                                                                                   // 5\n  \"console\": \"console-browserify\",                                                                                   // 6\n  \"constants\": \"constants-browserify\",                                                                               // 7\n  \"crypto\": \"crypto-browserify\",                                                                                     // 8\n  \"dgram\": null,                                                                                                     // 9\n  \"dns\": null,                                                                                                       // 10\n  \"domain\": \"domain-browser\",                                                                                        // 11\n  \"events\": \"events/\",                                                                                               // 12\n  \"fs\": null,                                                                                                        // 13\n  \"http\": \"http-browserify\",                                                                                         // 14\n  \"https\": \"https-browserify\",                                                                                       // 15\n  \"module\": null,                                                                                                    // 16\n  \"net\": null,                                                                                                       // 17\n  \"os\": \"os-browserify/browser.js\",                                                                                  // 18\n  \"path\": \"path-browserify\",                                                                                         // 19\n  \"process\": \"process/browser.js\",                                                                                   // 20\n  \"punycode\": \"punycode/\",                                                                                           // 21\n  \"querystring\": \"querystring-es3/\",                                                                                 // 22\n  \"readline\": null,                                                                                                  // 23\n  \"repl\": null,                                                                                                      // 24\n  \"stream\": \"stream-browserify\",                                                                                     // 25\n  \"_stream_duplex\": \"readable-stream/duplex.js\",                                                                     // 26\n  \"_stream_passthrough\": \"readable-stream/passthrough.js\",                                                           // 27\n  \"_stream_readable\": \"readable-stream/readable.js\",                                                                 // 28\n  \"_stream_transform\": \"readable-stream/transform.js\",                                                               // 29\n  \"_stream_writable\": \"readable-stream/writable.js\",                                                                 // 30\n  \"string_decoder\": \"string_decoder/\",                                                                               // 31\n  \"sys\": \"util/util.js\",                                                                                             // 32\n  \"timers\": \"timers-browserify\",                                                                                     // 33\n  \"tls\": null,                                                                                                       // 34\n  \"tty\": \"tty-browserify\",                                                                                           // 35\n  \"url\": \"url/\",                                                                                                     // 36\n  \"util\": \"util/util.js\",                                                                                            // 37\n  \"vm\": \"vm-browserify\",                                                                                             // 38\n  \"zlib\": \"browserify-zlib\"                                                                                          // 39\n};                                                                                                                   // 40\n                                                                                                                     // 41\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"docker-modem\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/docker-modem/package.json                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"docker-modem\";                                                                                       // 1\nexports.version = \"0.3.1\";                                                                                           // 2\nexports.main = \"./lib/modem\";                                                                                        // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lib\":{\"modem.js\":[\"querystring\",\"follow-redirects\",\"fs\",\"path\",\"url\",\"readable-stream\",\"./http_duplex\",\"debug\",\"util\",\"split-ca\",\"JSONStream\",\"meteor-node-stubs/deps/querystring\",\"meteor-node-stubs/deps/fs\",\"meteor-node-stubs/deps/path\",\"meteor-node-stubs/deps/url\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/docker-modem/lib/modem.js                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar querystring = require('querystring'),                                                                            // 1\n  http = require('follow-redirects'),                                                                                // 2\n  fs = require('fs'),                                                                                                // 3\n  path = require('path'),                                                                                            // 4\n  url = require('url'),                                                                                              // 5\n  stream = require('readable-stream'),                                                                               // 6\n  HttpDuplex = require('./http_duplex'),                                                                             // 7\n  debug = require('debug')('modem'),                                                                                 // 8\n  util = require('util'),                                                                                            // 9\n  splitca = require('split-ca'),                                                                                     // 10\n  JSONStream = require('JSONStream');                                                                                // 11\n                                                                                                                     // 12\nvar defaultOpts = function() {                                                                                       // 13\n  var split;                                                                                                         // 14\n  var opts = {};                                                                                                     // 15\n                                                                                                                     // 16\n  if (!process.env.DOCKER_HOST) {                                                                                    // 17\n    opts.socketPath = '/var/run/docker.sock';                                                                        // 18\n  } else if (process.env.DOCKER_HOST.indexOf('unix://') === 0) {                                                     // 19\n    // Strip off unix://, fall back to default of /var/run/docker.sock if                                            // 20\n    // unix:// was passed without a path                                                                             // 21\n    opts.socketPath = process.env.DOCKER_HOST.substring(7) || '/var/run/docker.sock';                                // 22\n  } else {                                                                                                           // 23\n    split = /(?:tcp:\\/\\/)?(.*?):([0-9]+)/g.exec(process.env.DOCKER_HOST);                                            // 24\n                                                                                                                     // 25\n    if (!split || split.length !== 3) {                                                                              // 26\n      throw new Error('DOCKER_HOST env variable should be something like tcp://localhost:1234');                     // 27\n    }                                                                                                                // 28\n                                                                                                                     // 29\n    opts.port = split[2];                                                                                            // 30\n                                                                                                                     // 31\n    if (process.env.DOCKER_TLS_VERIFY === '1' || opts.port === '2376') {                                             // 32\n      opts.protocol = 'https';                                                                                       // 33\n    } else {                                                                                                         // 34\n      opts.protocol = 'http';                                                                                        // 35\n    }                                                                                                                // 36\n                                                                                                                     // 37\n    opts.host = split[1];                                                                                            // 38\n                                                                                                                     // 39\n    if (process.env.DOCKER_CERT_PATH) {                                                                              // 40\n      opts.ca = splitca(path.join(process.env.DOCKER_CERT_PATH, 'ca.pem'));                                          // 41\n      opts.cert = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'cert.pem'));                              // 42\n      opts.key = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'key.pem'));                                // 43\n    }                                                                                                                // 44\n  }                                                                                                                  // 45\n                                                                                                                     // 46\n  return opts;                                                                                                       // 47\n};                                                                                                                   // 48\n                                                                                                                     // 49\nvar Modem = function(opts) {                                                                                         // 50\n  if (!opts) {                                                                                                       // 51\n    opts = defaultOpts();                                                                                            // 52\n  }                                                                                                                  // 53\n                                                                                                                     // 54\n  this.socketPath = opts.socketPath;                                                                                 // 55\n  this.host = opts.host;                                                                                             // 56\n  this.port = opts.port;                                                                                             // 57\n  this.version = opts.version;                                                                                       // 58\n  this.key = opts.key;                                                                                               // 59\n  this.cert = opts.cert;                                                                                             // 60\n  this.ca = opts.ca;                                                                                                 // 61\n  this.timeout = opts.timeout;                                                                                       // 62\n  this.checkServerIdentity = opts.checkServerIdentity;                                                               // 63\n                                                                                                                     // 64\n  if (this.key && this.cert && this.ca) {                                                                            // 65\n    this.protocol = 'https';                                                                                         // 66\n  }                                                                                                                  // 67\n  this.protocol = opts.protocol || this.protocol || 'http';                                                          // 68\n};                                                                                                                   // 69\n                                                                                                                     // 70\nModem.prototype.dial = function(options, callback) {                                                                 // 71\n  var opts, address, data;                                                                                           // 72\n  var self = this;                                                                                                   // 73\n                                                                                                                     // 74\n  if (options.options) {                                                                                             // 75\n    opts = options.options;                                                                                          // 76\n  }                                                                                                                  // 77\n                                                                                                                     // 78\n  if (this.version) {                                                                                                // 79\n    options.path = '/' + this.version + options.path;                                                                // 80\n  }                                                                                                                  // 81\n                                                                                                                     // 82\n  if (this.host) {                                                                                                   // 83\n    var parsed = url.parse(self.host);                                                                               // 84\n    address = url.format({                                                                                           // 85\n      'protocol': parsed.protocol || self.protocol,                                                                  // 86\n      'hostname': parsed.hostname || self.host,                                                                      // 87\n      'port': self.port                                                                                              // 88\n    });                                                                                                              // 89\n    address = url.resolve(address, options.path);                                                                    // 90\n  } else {                                                                                                           // 91\n    address = options.path;                                                                                          // 92\n  }                                                                                                                  // 93\n                                                                                                                     // 94\n  if (options.path.indexOf('?') !== -1) {                                                                            // 95\n    if (opts && Object.keys(opts).length > 0) {                                                                      // 96\n      address += this.buildQuerystring(opts);                                                                        // 97\n    } else {                                                                                                         // 98\n      address = address.substring(0, address.length - 1);                                                            // 99\n    }                                                                                                                // 100\n  }                                                                                                                  // 101\n                                                                                                                     // 102\n  var optionsf = {                                                                                                   // 103\n    path: address,                                                                                                   // 104\n    method: options.method,                                                                                          // 105\n    headers: options.headers || {},                                                                                  // 106\n    key: self.key,                                                                                                   // 107\n    cert: self.cert,                                                                                                 // 108\n    ca: self.ca                                                                                                      // 109\n  };                                                                                                                 // 110\n                                                                                                                     // 111\n  if (this.checkServerIdentity) {                                                                                    // 112\n    optionsf.checkServerIdentity = this.checkServerIdentity;                                                         // 113\n  }                                                                                                                  // 114\n                                                                                                                     // 115\n  if (options.authconfig) {                                                                                          // 116\n    optionsf.headers['X-Registry-Auth'] = options.authconfig.key || options.authconfig.base64 ||                     // 117\n      new Buffer(JSON.stringify(options.authconfig)).toString('base64');                                             // 118\n  }                                                                                                                  // 119\n                                                                                                                     // 120\n  if (options.registryconfig) {                                                                                      // 121\n    optionsf.headers['X-Registry-Config'] = options.registryconfig.base64 ||                                         // 122\n      new Buffer(JSON.stringify(options.registryconfig)).toString('base64');                                         // 123\n  }                                                                                                                  // 124\n                                                                                                                     // 125\n  if (options.file) {                                                                                                // 126\n    if (typeof options.file === 'string') {                                                                          // 127\n      data = fs.readFileSync(path.resolve(options.file));                                                            // 128\n    } else {                                                                                                         // 129\n      data = options.file;                                                                                           // 130\n    }                                                                                                                // 131\n    optionsf.headers['Content-Type'] = 'application/tar';                                                            // 132\n  } else if (opts && options.method === 'POST') {                                                                    // 133\n    data = JSON.stringify(opts);                                                                                     // 134\n    optionsf.headers['Content-Type'] = 'application/json';                                                           // 135\n  }                                                                                                                  // 136\n                                                                                                                     // 137\n  if (typeof data === \"string\") {                                                                                    // 138\n    optionsf.headers['Content-Length'] = Buffer.byteLength(data);                                                    // 139\n  } else if (Buffer.isBuffer(data) === true) {                                                                       // 140\n    optionsf.headers['Content-Length'] = data.length;                                                                // 141\n  }                                                                                                                  // 142\n                                                                                                                     // 143\n  if (options.hijack) {                                                                                              // 144\n    optionsf.headers.Connection = 'Upgrade';                                                                         // 145\n    optionsf.headers.Upgrade = 'tcp';                                                                                // 146\n  }                                                                                                                  // 147\n                                                                                                                     // 148\n  if (this.socketPath) {                                                                                             // 149\n    optionsf.socketPath = this.socketPath;                                                                           // 150\n  } else {                                                                                                           // 151\n    var urlp = url.parse(address);                                                                                   // 152\n    optionsf.hostname = urlp.hostname;                                                                               // 153\n    optionsf.port = urlp.port;                                                                                       // 154\n    optionsf.path = urlp.path;                                                                                       // 155\n  }                                                                                                                  // 156\n                                                                                                                     // 157\n  this.buildRequest(optionsf, options, data, callback);                                                              // 158\n};                                                                                                                   // 159\n                                                                                                                     // 160\nModem.prototype.buildRequest = function(options, context, data, callback) {                                          // 161\n  var self = this;                                                                                                   // 162\n  var req = http[self.protocol].request(options, function() {});                                                     // 163\n                                                                                                                     // 164\n  debug('Sending: %s', util.inspect(options, {                                                                       // 165\n    showHidden: true,                                                                                                // 166\n    depth: null                                                                                                      // 167\n  }));                                                                                                               // 168\n                                                                                                                     // 169\n  if (self.timeout) {                                                                                                // 170\n    req.on('socket', function(socket) {                                                                              // 171\n      socket.setTimeout(self.timeout);                                                                               // 172\n      socket.on('timeout', function() {                                                                              // 173\n        debug('Timeout of %s ms exceeded', self.timeout);                                                            // 174\n        req.abort();                                                                                                 // 175\n      });                                                                                                            // 176\n    });                                                                                                              // 177\n  }                                                                                                                  // 178\n                                                                                                                     // 179\n  if (context.hijack === true) {                                                                                     // 180\n    req.on('upgrade', function(res, sock, head) {                                                                    // 181\n      return callback(null, sock);                                                                                   // 182\n    });                                                                                                              // 183\n  }                                                                                                                  // 184\n                                                                                                                     // 185\n  req.on('response', function(res) {                                                                                 // 186\n    if (context.isStream === true) {                                                                                 // 187\n      self.buildPayload(null, context.isStream, context.statusCodes, context.openStdin, req, res, null, callback);   // 188\n    } else {                                                                                                         // 189\n      var chunks = '';                                                                                               // 190\n      res.on('data', function(chunk) {                                                                               // 191\n        chunks += chunk;                                                                                             // 192\n      });                                                                                                            // 193\n                                                                                                                     // 194\n      res.on('end', function() {                                                                                     // 195\n        debug('Received: %s', chunks);                                                                               // 196\n                                                                                                                     // 197\n        var json;                                                                                                    // 198\n        try {                                                                                                        // 199\n          json = JSON.parse(chunks);                                                                                 // 200\n        } catch (e) {                                                                                                // 201\n          json = chunks;                                                                                             // 202\n        }                                                                                                            // 203\n        self.buildPayload(null, context.isStream, context.statusCodes, false, req, res, json, callback);             // 204\n      });                                                                                                            // 205\n    }                                                                                                                // 206\n  });                                                                                                                // 207\n                                                                                                                     // 208\n  req.on('error', function(error) {                                                                                  // 209\n    self.buildPayload(error, context.isStream, context.statusCodes, false, {}, {}, null, callback);                  // 210\n  });                                                                                                                // 211\n                                                                                                                     // 212\n  if (typeof data === \"string\" || Buffer.isBuffer(data)) {                                                           // 213\n    req.write(data);                                                                                                 // 214\n  } else if (data) {                                                                                                 // 215\n    data.pipe(req);                                                                                                  // 216\n  }                                                                                                                  // 217\n                                                                                                                     // 218\n  if (!context.hijack && !context.openStdin && (typeof data === \"string\" || data === undefined || Buffer.isBuffer(data))) {\n    req.end();                                                                                                       // 220\n  }                                                                                                                  // 221\n};                                                                                                                   // 222\n                                                                                                                     // 223\nModem.prototype.buildPayload = function(err, isStream, statusCodes, openStdin, req, res, json, cb) {                 // 224\n  if (err) return cb(err, null);                                                                                     // 225\n                                                                                                                     // 226\n  if (statusCodes[res.statusCode] !== true) {                                                                        // 227\n    getCause(isStream, res, json, function(err, cause) {                                                             // 228\n      var msg = new Error(                                                                                           // 229\n        '(HTTP code ' + res.statusCode + ') ' +                                                                      // 230\n        (statusCodes[res.statusCode] || 'unexpected') + ' - ' +                                                      // 231\n        (cause.message || cause) + ' '                                                                               // 232\n      );                                                                                                             // 233\n      msg.reason = statusCodes[res.statusCode];                                                                      // 234\n      msg.statusCode = res.statusCode;                                                                               // 235\n      msg.json = json;                                                                                               // 236\n      cb(msg, null);                                                                                                 // 237\n    });                                                                                                              // 238\n  } else {                                                                                                           // 239\n    if (openStdin) {                                                                                                 // 240\n      cb(null, new HttpDuplex(req, res));                                                                            // 241\n    } else if (isStream) {                                                                                           // 242\n      cb(null, res);                                                                                                 // 243\n    } else {                                                                                                         // 244\n      cb(null, json);                                                                                                // 245\n    }                                                                                                                // 246\n  }                                                                                                                  // 247\n                                                                                                                     // 248\n  function getCause(isStream, res, json, callback) {                                                                 // 249\n    var chunks = '';                                                                                                 // 250\n    if (isStream) {                                                                                                  // 251\n      res.on('data', function(chunk) {                                                                               // 252\n        chunks += chunk;                                                                                             // 253\n      });                                                                                                            // 254\n      res.on('end', function() {                                                                                     // 255\n        callback(null, chunks);                                                                                      // 256\n      });                                                                                                            // 257\n    } else {                                                                                                         // 258\n      callback(null, json);                                                                                          // 259\n    }                                                                                                                // 260\n  }                                                                                                                  // 261\n};                                                                                                                   // 262\n                                                                                                                     // 263\nModem.prototype.demuxStream = function(stream, stdout, stderr) {                                                     // 264\n  var header = null;                                                                                                 // 265\n                                                                                                                     // 266\n  stream.on('readable', function() {                                                                                 // 267\n    header = header || stream.read(8);                                                                               // 268\n    while (header !== null) {                                                                                        // 269\n      var type = header.readUInt8(0);                                                                                // 270\n      var payload = stream.read(header.readUInt32BE(4));                                                             // 271\n      if (payload === null) break;                                                                                   // 272\n      if (type == 2) {                                                                                               // 273\n        stderr.write(payload);                                                                                       // 274\n      } else {                                                                                                       // 275\n        stdout.write(payload);                                                                                       // 276\n      }                                                                                                              // 277\n      header = stream.read(8);                                                                                       // 278\n    }                                                                                                                // 279\n  });                                                                                                                // 280\n};                                                                                                                   // 281\n                                                                                                                     // 282\nModem.prototype.followProgress = function(stream, onFinished, onProgress) {                                          // 283\n  var parser = JSONStream.parse(),                                                                                   // 284\n    output = [];                                                                                                     // 285\n                                                                                                                     // 286\n  parser.on('root', onStreamEvent);                                                                                  // 287\n  parser.on('error', onStreamError);                                                                                 // 288\n  parser.on('end', onStreamEnd);                                                                                     // 289\n                                                                                                                     // 290\n  stream.pipe(parser);                                                                                               // 291\n                                                                                                                     // 292\n  function onStreamEvent(evt) {                                                                                      // 293\n    if (!(evt instanceof Object)) {                                                                                  // 294\n      evt = {};                                                                                                      // 295\n    }                                                                                                                // 296\n                                                                                                                     // 297\n    output.push(evt);                                                                                                // 298\n                                                                                                                     // 299\n    if (evt.error) {                                                                                                 // 300\n      return onStreamError(evt.error);                                                                               // 301\n    }                                                                                                                // 302\n                                                                                                                     // 303\n    if (onProgress) {                                                                                                // 304\n      onProgress(evt);                                                                                               // 305\n    }                                                                                                                // 306\n  }                                                                                                                  // 307\n                                                                                                                     // 308\n  function onStreamError(err) {                                                                                      // 309\n    parser.removeListener('root', onStreamEvent);                                                                    // 310\n    parser.removeListener('error', onStreamError);                                                                   // 311\n    parser.removeListener('end', onStreamEnd);                                                                       // 312\n    onFinished(err, output);                                                                                         // 313\n  }                                                                                                                  // 314\n                                                                                                                     // 315\n  function onStreamEnd() {                                                                                           // 316\n    onFinished(null, output);                                                                                        // 317\n  }                                                                                                                  // 318\n};                                                                                                                   // 319\n                                                                                                                     // 320\nModem.prototype.buildQuerystring = function(opts) {                                                                  // 321\n  var clone = {};                                                                                                    // 322\n                                                                                                                     // 323\n  // serialize map values as JSON strings, else querystring truncates.                                               // 324\n  Object.keys(opts).map(function(key, i) {                                                                           // 325\n    clone[key] = (opts[key] && typeof opts[key] === 'object') ?                                                      // 326\n      JSON.stringify(opts[key]) : opts[key];                                                                         // 327\n  });                                                                                                                // 328\n                                                                                                                     // 329\n  return querystring.stringify(clone);                                                                               // 330\n};                                                                                                                   // 331\n                                                                                                                     // 332\nmodule.exports = Modem;                                                                                              // 333\n                                                                                                                     // 334\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"http_duplex.js\":[\"util\",\"readable-stream\",\"meteor-node-stubs/deps/util\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/docker-modem/lib/http_duplex.js                                                                      //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.exports = HttpDuplex;                                                                                         // 1\n                                                                                                                     // 2\nvar util = require('util'),                                                                                          // 3\n  stream = require('readable-stream');                                                                               // 4\n                                                                                                                     // 5\nutil.inherits(HttpDuplex, stream.Duplex);                                                                            // 6\n                                                                                                                     // 7\nfunction HttpDuplex(req, res, options) {                                                                             // 8\n  var self = this;                                                                                                   // 9\n                                                                                                                     // 10\n  if (!(self instanceof HttpDuplex)) return new HttpDuplex(req, res);                                                // 11\n                                                                                                                     // 12\n  stream.Duplex.call(self, options);                                                                                 // 13\n  self._output = null;                                                                                               // 14\n                                                                                                                     // 15\n  self.connect(req, res);                                                                                            // 16\n}                                                                                                                    // 17\n                                                                                                                     // 18\nHttpDuplex.prototype.connect = function(req, res) {                                                                  // 19\n  var self = this;                                                                                                   // 20\n  self.req = req;                                                                                                    // 21\n  self._output = res;                                                                                                // 22\n  self.emit('response', res);                                                                                        // 23\n                                                                                                                     // 24\n  res.on('data', function(c) {                                                                                       // 25\n    if (!self.push(c)) self._output.pause();                                                                         // 26\n  });                                                                                                                // 27\n  res.on('end', function() {                                                                                         // 28\n    self.push(null);                                                                                                 // 29\n  });                                                                                                                // 30\n};                                                                                                                   // 31\n                                                                                                                     // 32\nHttpDuplex.prototype._read = function(n) {                                                                           // 33\n  if (this._output) this._output.resume();                                                                           // 34\n};                                                                                                                   // 35\n                                                                                                                     // 36\nHttpDuplex.prototype._write = function(chunk, encoding, cb) {                                                        // 37\n  this.req.write(chunk, encoding);                                                                                   // 38\n  cb();                                                                                                              // 39\n};                                                                                                                   // 40\n                                                                                                                     // 41\nHttpDuplex.prototype.end = function(chunk, encoding, cb) {                                                           // 42\n  this._output.socket.destroy();                                                                                     // 43\n  return this.req.end(chunk, encoding, cb);                                                                          // 44\n};                                                                                                                   // 45\n                                                                                                                     // 46\nHttpDuplex.prototype.destroy = function() {                                                                          // 47\n  this.req.destroy();                                                                                                // 48\n  this._output.socket.destroy();                                                                                     // 49\n};                                                                                                                   // 50\n                                                                                                                     // 51\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}},\"follow-redirects\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/follow-redirects/package.json                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"follow-redirects\";                                                                                   // 1\nexports.version = \"0.0.3\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"https\",\"http\",\"url\",\"underscore\",\"meteor-node-stubs/deps/https\",\"meteor-node-stubs/deps/http\",\"meteor-node-stubs/deps/url\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/follow-redirects/index.js                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar nativeHttps = require('https'),                                                                                  // 1\n  nativeHttp = require('http'),                                                                                      // 2\n  url = require('url'),                                                                                              // 3\n  _ = require('underscore');                                                                                         // 4\n                                                                                                                     // 5\nvar maxRedirects = module.exports.maxRedirects = 5;                                                                  // 6\n                                                                                                                     // 7\nvar protocols = {                                                                                                    // 8\n  https: nativeHttps,                                                                                                // 9\n  http: nativeHttp                                                                                                   // 10\n};                                                                                                                   // 11\n                                                                                                                     // 12\n// Only use GETs on redirects                                                                                        // 13\nfor (var protocol in protocols) {                                                                                    // 14\n  // h is either our cloned http or https object                                                                     // 15\n  var h =  function() {};                                                                                            // 16\n  h.prototype = protocols[protocol];                                                                                 // 17\n  h = new h();                                                                                                       // 18\n                                                                                                                     // 19\n  module.exports[protocol] = h;                                                                                      // 20\n                                                                                                                     // 21\n  h.request = function (h) {                                                                                         // 22\n    return function (options, callback, redirectOptions) {                                                           // 23\n                                                                                                                     // 24\n      redirectOptions = redirectOptions || {};                                                                       // 25\n                                                                                                                     // 26\n      var max = (typeof options === 'object' && 'maxRedirects' in options) ? options.maxRedirects : exports.maxRedirects;\n                                                                                                                     // 28\n      var redirect = _.extend({                                                                                      // 29\n        count: 0,                                                                                                    // 30\n        max: max,                                                                                                    // 31\n        clientRequest: null,                                                                                         // 32\n        userCallback: callback                                                                                       // 33\n      }, redirectOptions);                                                                                           // 34\n                                                                                                                     // 35\n      //console.log(redirect.count);                                                                                 // 36\n      //console.log(redirect.max);                                                                                   // 37\n      /**                                                                                                            // 38\n       * Emit error if too many redirects                                                                            // 39\n       */                                                                                                            // 40\n      if (redirect.count > redirect.max) {                                                                           // 41\n        var err = new Error('Max redirects exceeded. To allow more redirects, pass options.maxRedirects property.');\n        redirect.clientRequest.emit('error', err);                                                                   // 43\n        return redirect.clientRequest;                                                                               // 44\n      }                                                                                                              // 45\n                                                                                                                     // 46\n      redirect.count++;                                                                                              // 47\n                                                                                                                     // 48\n      /**                                                                                                            // 49\n       * Parse URL from options                                                                                      // 50\n       */                                                                                                            // 51\n      var reqUrl;                                                                                                    // 52\n      if (typeof options === 'string') {                                                                             // 53\n        reqUrl = options;                                                                                            // 54\n      }                                                                                                              // 55\n      else {                                                                                                         // 56\n        reqUrl = url.format(_.extend({ protocol: protocol }, options));                                              // 57\n      }                                                                                                              // 58\n                                                                                                                     // 59\n      /*                                                                                                             // 60\n       * Build client request                                                                                        // 61\n       */                                                                                                            // 62\n      var clientRequest = h.__proto__.request(options, redirectCallback(reqUrl, redirect));                          // 63\n                                                                                                                     // 64\n      // Save user's clientRequest so we can emit errors later                                                       // 65\n      if (!redirect.clientRequest) redirect.clientRequest = clientRequest;                                           // 66\n                                                                                                                     // 67\n      /**                                                                                                            // 68\n       * ClientRequest callback for redirects                                                                        // 69\n       */                                                                                                            // 70\n      function redirectCallback (reqUrl, redirect) {                                                                 // 71\n        return function (res) {                                                                                      // 72\n          // status must be 300-399 for redirects                                                                    // 73\n          if (res.statusCode < 300 || res.statusCode > 399) {                                                        // 74\n            //console.log('[' + res.statusCode + '] callback user on url ' + reqUrl);                                // 75\n            return redirect.userCallback(res);                                                                       // 76\n          }                                                                                                          // 77\n                                                                                                                     // 78\n          // no `Location:` header => nowhere to redirect                                                            // 79\n          if (!('location' in res.headers)) {                                                                        // 80\n            //console.log('[no location header] callback user on url ' + reqUrl);                                    // 81\n            return redirect.userCallback(res);                                                                       // 82\n          }                                                                                                          // 83\n                                                                                                                     // 84\n          // save the original clientRequest to our redirectOptions so we can emit errors later                      // 85\n                                                                                                                     // 86\n          // need to use url.resolve() in case location is a relative URL                                            // 87\n          var redirectUrl = url.resolve(reqUrl, res.headers['location']);                                            // 88\n          // we need to call the right api (http vs https) depending on protocol                                     // 89\n          var proto = url.parse(redirectUrl).protocol;                                                               // 90\n          proto = proto.substr(0, proto.length - 1);                                                                 // 91\n          //console.log('Redirecting from ' + reqUrl + ' to ' + redirectUrl);                                        // 92\n          return module.exports[proto].get(redirectUrl, redirectCallback(reqUrl, redirect), redirect);               // 93\n        };                                                                                                           // 94\n      }                                                                                                              // 95\n                                                                                                                     // 96\n      return clientRequest;                                                                                          // 97\n    }                                                                                                                // 98\n  }(h);                                                                                                              // 99\n                                                                                                                     // 100\n  // see https://github.com/joyent/node/blob/master/lib/http.js#L1623                                                // 101\n  h.get = function (h) {                                                                                             // 102\n    return function (options, cb, redirectOptions) {                                                                 // 103\n      var req = h.request(options, cb, redirectOptions);                                                             // 104\n      req.end();                                                                                                     // 105\n      return req;                                                                                                    // 106\n    };                                                                                                               // 107\n  }(h);                                                                                                              // 108\n}                                                                                                                    // 109\n                                                                                                                     // 110\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"underscore\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/underscore/package.json                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"underscore\";                                                                                         // 1\nexports.version = \"1.8.3\";                                                                                           // 2\nexports.main = \"underscore.js\";                                                                                      // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"underscore.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/underscore/underscore.js                                                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n//     Underscore.js 1.8.3                                                                                           // 1\n//     http://underscorejs.org                                                                                       // 2\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors                            // 3\n//     Underscore may be freely distributed under the MIT license.                                                   // 4\n                                                                                                                     // 5\n(function() {                                                                                                        // 6\n                                                                                                                     // 7\n  // Baseline setup                                                                                                  // 8\n  // --------------                                                                                                  // 9\n                                                                                                                     // 10\n  // Establish the root object, `window` in the browser, or `exports` on the server.                                 // 11\n  var root = this;                                                                                                   // 12\n                                                                                                                     // 13\n  // Save the previous value of the `_` variable.                                                                    // 14\n  var previousUnderscore = root._;                                                                                   // 15\n                                                                                                                     // 16\n  // Save bytes in the minified (but not gzipped) version:                                                           // 17\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;                     // 18\n                                                                                                                     // 19\n  // Create quick reference variables for speed access to core prototypes.                                           // 20\n  var                                                                                                                // 21\n    push             = ArrayProto.push,                                                                              // 22\n    slice            = ArrayProto.slice,                                                                             // 23\n    toString         = ObjProto.toString,                                                                            // 24\n    hasOwnProperty   = ObjProto.hasOwnProperty;                                                                      // 25\n                                                                                                                     // 26\n  // All **ECMAScript 5** native function implementations that we hope to use                                        // 27\n  // are declared here.                                                                                              // 28\n  var                                                                                                                // 29\n    nativeIsArray      = Array.isArray,                                                                              // 30\n    nativeKeys         = Object.keys,                                                                                // 31\n    nativeBind         = FuncProto.bind,                                                                             // 32\n    nativeCreate       = Object.create;                                                                              // 33\n                                                                                                                     // 34\n  // Naked function reference for surrogate-prototype-swapping.                                                      // 35\n  var Ctor = function(){};                                                                                           // 36\n                                                                                                                     // 37\n  // Create a safe reference to the Underscore object for use below.                                                 // 38\n  var _ = function(obj) {                                                                                            // 39\n    if (obj instanceof _) return obj;                                                                                // 40\n    if (!(this instanceof _)) return new _(obj);                                                                     // 41\n    this._wrapped = obj;                                                                                             // 42\n  };                                                                                                                 // 43\n                                                                                                                     // 44\n  // Export the Underscore object for **Node.js**, with                                                              // 45\n  // backwards-compatibility for the old `require()` API. If we're in                                                // 46\n  // the browser, add `_` as a global object.                                                                        // 47\n  if (typeof exports !== 'undefined') {                                                                              // 48\n    if (typeof module !== 'undefined' && module.exports) {                                                           // 49\n      exports = module.exports = _;                                                                                  // 50\n    }                                                                                                                // 51\n    exports._ = _;                                                                                                   // 52\n  } else {                                                                                                           // 53\n    root._ = _;                                                                                                      // 54\n  }                                                                                                                  // 55\n                                                                                                                     // 56\n  // Current version.                                                                                                // 57\n  _.VERSION = '1.8.3';                                                                                               // 58\n                                                                                                                     // 59\n  // Internal function that returns an efficient (for current engines) version                                       // 60\n  // of the passed-in callback, to be repeatedly applied in other Underscore                                         // 61\n  // functions.                                                                                                      // 62\n  var optimizeCb = function(func, context, argCount) {                                                               // 63\n    if (context === void 0) return func;                                                                             // 64\n    switch (argCount == null ? 3 : argCount) {                                                                       // 65\n      case 1: return function(value) {                                                                               // 66\n        return func.call(context, value);                                                                            // 67\n      };                                                                                                             // 68\n      case 2: return function(value, other) {                                                                        // 69\n        return func.call(context, value, other);                                                                     // 70\n      };                                                                                                             // 71\n      case 3: return function(value, index, collection) {                                                            // 72\n        return func.call(context, value, index, collection);                                                         // 73\n      };                                                                                                             // 74\n      case 4: return function(accumulator, value, index, collection) {                                               // 75\n        return func.call(context, accumulator, value, index, collection);                                            // 76\n      };                                                                                                             // 77\n    }                                                                                                                // 78\n    return function() {                                                                                              // 79\n      return func.apply(context, arguments);                                                                         // 80\n    };                                                                                                               // 81\n  };                                                                                                                 // 82\n                                                                                                                     // 83\n  // A mostly-internal function to generate callbacks that can be applied                                            // 84\n  // to each element in a collection, returning the desired result  either                                          // 85\n  // identity, an arbitrary callback, a property matcher, or a property accessor.                                    // 86\n  var cb = function(value, context, argCount) {                                                                      // 87\n    if (value == null) return _.identity;                                                                            // 88\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);                                            // 89\n    if (_.isObject(value)) return _.matcher(value);                                                                  // 90\n    return _.property(value);                                                                                        // 91\n  };                                                                                                                 // 92\n  _.iteratee = function(value, context) {                                                                            // 93\n    return cb(value, context, Infinity);                                                                             // 94\n  };                                                                                                                 // 95\n                                                                                                                     // 96\n  // An internal function for creating assigner functions.                                                           // 97\n  var createAssigner = function(keysFunc, undefinedOnly) {                                                           // 98\n    return function(obj) {                                                                                           // 99\n      var length = arguments.length;                                                                                 // 100\n      if (length < 2 || obj == null) return obj;                                                                     // 101\n      for (var index = 1; index < length; index++) {                                                                 // 102\n        var source = arguments[index],                                                                               // 103\n            keys = keysFunc(source),                                                                                 // 104\n            l = keys.length;                                                                                         // 105\n        for (var i = 0; i < l; i++) {                                                                                // 106\n          var key = keys[i];                                                                                         // 107\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];                                         // 108\n        }                                                                                                            // 109\n      }                                                                                                              // 110\n      return obj;                                                                                                    // 111\n    };                                                                                                               // 112\n  };                                                                                                                 // 113\n                                                                                                                     // 114\n  // An internal function for creating a new object that inherits from another.                                      // 115\n  var baseCreate = function(prototype) {                                                                             // 116\n    if (!_.isObject(prototype)) return {};                                                                           // 117\n    if (nativeCreate) return nativeCreate(prototype);                                                                // 118\n    Ctor.prototype = prototype;                                                                                      // 119\n    var result = new Ctor;                                                                                           // 120\n    Ctor.prototype = null;                                                                                           // 121\n    return result;                                                                                                   // 122\n  };                                                                                                                 // 123\n                                                                                                                     // 124\n  var property = function(key) {                                                                                     // 125\n    return function(obj) {                                                                                           // 126\n      return obj == null ? void 0 : obj[key];                                                                        // 127\n    };                                                                                                               // 128\n  };                                                                                                                 // 129\n                                                                                                                     // 130\n  // Helper for collection methods to determine whether a collection                                                 // 131\n  // should be iterated as an array or as an object                                                                  // 132\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength                                      // 133\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094                                                              // 134\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;                                                                         // 135\n  var getLength = property('length');                                                                                // 136\n  var isArrayLike = function(collection) {                                                                           // 137\n    var length = getLength(collection);                                                                              // 138\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;                                    // 139\n  };                                                                                                                 // 140\n                                                                                                                     // 141\n  // Collection Functions                                                                                            // 142\n  // --------------------                                                                                            // 143\n                                                                                                                     // 144\n  // The cornerstone, an `each` implementation, aka `forEach`.                                                       // 145\n  // Handles raw objects in addition to array-likes. Treats all                                                      // 146\n  // sparse array-likes as if they were dense.                                                                       // 147\n  _.each = _.forEach = function(obj, iteratee, context) {                                                            // 148\n    iteratee = optimizeCb(iteratee, context);                                                                        // 149\n    var i, length;                                                                                                   // 150\n    if (isArrayLike(obj)) {                                                                                          // 151\n      for (i = 0, length = obj.length; i < length; i++) {                                                            // 152\n        iteratee(obj[i], i, obj);                                                                                    // 153\n      }                                                                                                              // 154\n    } else {                                                                                                         // 155\n      var keys = _.keys(obj);                                                                                        // 156\n      for (i = 0, length = keys.length; i < length; i++) {                                                           // 157\n        iteratee(obj[keys[i]], keys[i], obj);                                                                        // 158\n      }                                                                                                              // 159\n    }                                                                                                                // 160\n    return obj;                                                                                                      // 161\n  };                                                                                                                 // 162\n                                                                                                                     // 163\n  // Return the results of applying the iteratee to each element.                                                    // 164\n  _.map = _.collect = function(obj, iteratee, context) {                                                             // 165\n    iteratee = cb(iteratee, context);                                                                                // 166\n    var keys = !isArrayLike(obj) && _.keys(obj),                                                                     // 167\n        length = (keys || obj).length,                                                                               // 168\n        results = Array(length);                                                                                     // 169\n    for (var index = 0; index < length; index++) {                                                                   // 170\n      var currentKey = keys ? keys[index] : index;                                                                   // 171\n      results[index] = iteratee(obj[currentKey], currentKey, obj);                                                   // 172\n    }                                                                                                                // 173\n    return results;                                                                                                  // 174\n  };                                                                                                                 // 175\n                                                                                                                     // 176\n  // Create a reducing function iterating left or right.                                                             // 177\n  function createReduce(dir) {                                                                                       // 178\n    // Optimized iterator function as using arguments.length                                                         // 179\n    // in the main function will deoptimize the, see #1991.                                                          // 180\n    function iterator(obj, iteratee, memo, keys, index, length) {                                                    // 181\n      for (; index >= 0 && index < length; index += dir) {                                                           // 182\n        var currentKey = keys ? keys[index] : index;                                                                 // 183\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);                                                     // 184\n      }                                                                                                              // 185\n      return memo;                                                                                                   // 186\n    }                                                                                                                // 187\n                                                                                                                     // 188\n    return function(obj, iteratee, memo, context) {                                                                  // 189\n      iteratee = optimizeCb(iteratee, context, 4);                                                                   // 190\n      var keys = !isArrayLike(obj) && _.keys(obj),                                                                   // 191\n          length = (keys || obj).length,                                                                             // 192\n          index = dir > 0 ? 0 : length - 1;                                                                          // 193\n      // Determine the initial value if none is provided.                                                            // 194\n      if (arguments.length < 3) {                                                                                    // 195\n        memo = obj[keys ? keys[index] : index];                                                                      // 196\n        index += dir;                                                                                                // 197\n      }                                                                                                              // 198\n      return iterator(obj, iteratee, memo, keys, index, length);                                                     // 199\n    };                                                                                                               // 200\n  }                                                                                                                  // 201\n                                                                                                                     // 202\n  // **Reduce** builds up a single result from a list of values, aka `inject`,                                       // 203\n  // or `foldl`.                                                                                                     // 204\n  _.reduce = _.foldl = _.inject = createReduce(1);                                                                   // 205\n                                                                                                                     // 206\n  // The right-associative version of reduce, also known as `foldr`.                                                 // 207\n  _.reduceRight = _.foldr = createReduce(-1);                                                                        // 208\n                                                                                                                     // 209\n  // Return the first value which passes a truth test. Aliased as `detect`.                                          // 210\n  _.find = _.detect = function(obj, predicate, context) {                                                            // 211\n    var key;                                                                                                         // 212\n    if (isArrayLike(obj)) {                                                                                          // 213\n      key = _.findIndex(obj, predicate, context);                                                                    // 214\n    } else {                                                                                                         // 215\n      key = _.findKey(obj, predicate, context);                                                                      // 216\n    }                                                                                                                // 217\n    if (key !== void 0 && key !== -1) return obj[key];                                                               // 218\n  };                                                                                                                 // 219\n                                                                                                                     // 220\n  // Return all the elements that pass a truth test.                                                                 // 221\n  // Aliased as `select`.                                                                                            // 222\n  _.filter = _.select = function(obj, predicate, context) {                                                          // 223\n    var results = [];                                                                                                // 224\n    predicate = cb(predicate, context);                                                                              // 225\n    _.each(obj, function(value, index, list) {                                                                       // 226\n      if (predicate(value, index, list)) results.push(value);                                                        // 227\n    });                                                                                                              // 228\n    return results;                                                                                                  // 229\n  };                                                                                                                 // 230\n                                                                                                                     // 231\n  // Return all the elements for which a truth test fails.                                                           // 232\n  _.reject = function(obj, predicate, context) {                                                                     // 233\n    return _.filter(obj, _.negate(cb(predicate)), context);                                                          // 234\n  };                                                                                                                 // 235\n                                                                                                                     // 236\n  // Determine whether all of the elements match a truth test.                                                       // 237\n  // Aliased as `all`.                                                                                               // 238\n  _.every = _.all = function(obj, predicate, context) {                                                              // 239\n    predicate = cb(predicate, context);                                                                              // 240\n    var keys = !isArrayLike(obj) && _.keys(obj),                                                                     // 241\n        length = (keys || obj).length;                                                                               // 242\n    for (var index = 0; index < length; index++) {                                                                   // 243\n      var currentKey = keys ? keys[index] : index;                                                                   // 244\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;                                                // 245\n    }                                                                                                                // 246\n    return true;                                                                                                     // 247\n  };                                                                                                                 // 248\n                                                                                                                     // 249\n  // Determine if at least one element in the object matches a truth test.                                           // 250\n  // Aliased as `any`.                                                                                               // 251\n  _.some = _.any = function(obj, predicate, context) {                                                               // 252\n    predicate = cb(predicate, context);                                                                              // 253\n    var keys = !isArrayLike(obj) && _.keys(obj),                                                                     // 254\n        length = (keys || obj).length;                                                                               // 255\n    for (var index = 0; index < length; index++) {                                                                   // 256\n      var currentKey = keys ? keys[index] : index;                                                                   // 257\n      if (predicate(obj[currentKey], currentKey, obj)) return true;                                                  // 258\n    }                                                                                                                // 259\n    return false;                                                                                                    // 260\n  };                                                                                                                 // 261\n                                                                                                                     // 262\n  // Determine if the array or object contains a given item (using `===`).                                           // 263\n  // Aliased as `includes` and `include`.                                                                            // 264\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {                                      // 265\n    if (!isArrayLike(obj)) obj = _.values(obj);                                                                      // 266\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;                                                        // 267\n    return _.indexOf(obj, item, fromIndex) >= 0;                                                                     // 268\n  };                                                                                                                 // 269\n                                                                                                                     // 270\n  // Invoke a method (with arguments) on every item in a collection.                                                 // 271\n  _.invoke = function(obj, method) {                                                                                 // 272\n    var args = slice.call(arguments, 2);                                                                             // 273\n    var isFunc = _.isFunction(method);                                                                               // 274\n    return _.map(obj, function(value) {                                                                              // 275\n      var func = isFunc ? method : value[method];                                                                    // 276\n      return func == null ? func : func.apply(value, args);                                                          // 277\n    });                                                                                                              // 278\n  };                                                                                                                 // 279\n                                                                                                                     // 280\n  // Convenience version of a common use case of `map`: fetching a property.                                         // 281\n  _.pluck = function(obj, key) {                                                                                     // 282\n    return _.map(obj, _.property(key));                                                                              // 283\n  };                                                                                                                 // 284\n                                                                                                                     // 285\n  // Convenience version of a common use case of `filter`: selecting only objects                                    // 286\n  // containing specific `key:value` pairs.                                                                          // 287\n  _.where = function(obj, attrs) {                                                                                   // 288\n    return _.filter(obj, _.matcher(attrs));                                                                          // 289\n  };                                                                                                                 // 290\n                                                                                                                     // 291\n  // Convenience version of a common use case of `find`: getting the first object                                    // 292\n  // containing specific `key:value` pairs.                                                                          // 293\n  _.findWhere = function(obj, attrs) {                                                                               // 294\n    return _.find(obj, _.matcher(attrs));                                                                            // 295\n  };                                                                                                                 // 296\n                                                                                                                     // 297\n  // Return the maximum element (or element-based computation).                                                      // 298\n  _.max = function(obj, iteratee, context) {                                                                         // 299\n    var result = -Infinity, lastComputed = -Infinity,                                                                // 300\n        value, computed;                                                                                             // 301\n    if (iteratee == null && obj != null) {                                                                           // 302\n      obj = isArrayLike(obj) ? obj : _.values(obj);                                                                  // 303\n      for (var i = 0, length = obj.length; i < length; i++) {                                                        // 304\n        value = obj[i];                                                                                              // 305\n        if (value > result) {                                                                                        // 306\n          result = value;                                                                                            // 307\n        }                                                                                                            // 308\n      }                                                                                                              // 309\n    } else {                                                                                                         // 310\n      iteratee = cb(iteratee, context);                                                                              // 311\n      _.each(obj, function(value, index, list) {                                                                     // 312\n        computed = iteratee(value, index, list);                                                                     // 313\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {                             // 314\n          result = value;                                                                                            // 315\n          lastComputed = computed;                                                                                   // 316\n        }                                                                                                            // 317\n      });                                                                                                            // 318\n    }                                                                                                                // 319\n    return result;                                                                                                   // 320\n  };                                                                                                                 // 321\n                                                                                                                     // 322\n  // Return the minimum element (or element-based computation).                                                      // 323\n  _.min = function(obj, iteratee, context) {                                                                         // 324\n    var result = Infinity, lastComputed = Infinity,                                                                  // 325\n        value, computed;                                                                                             // 326\n    if (iteratee == null && obj != null) {                                                                           // 327\n      obj = isArrayLike(obj) ? obj : _.values(obj);                                                                  // 328\n      for (var i = 0, length = obj.length; i < length; i++) {                                                        // 329\n        value = obj[i];                                                                                              // 330\n        if (value < result) {                                                                                        // 331\n          result = value;                                                                                            // 332\n        }                                                                                                            // 333\n      }                                                                                                              // 334\n    } else {                                                                                                         // 335\n      iteratee = cb(iteratee, context);                                                                              // 336\n      _.each(obj, function(value, index, list) {                                                                     // 337\n        computed = iteratee(value, index, list);                                                                     // 338\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {                               // 339\n          result = value;                                                                                            // 340\n          lastComputed = computed;                                                                                   // 341\n        }                                                                                                            // 342\n      });                                                                                                            // 343\n    }                                                                                                                // 344\n    return result;                                                                                                   // 345\n  };                                                                                                                 // 346\n                                                                                                                     // 347\n  // Shuffle a collection, using the modern version of the                                                           // 348\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).                                      // 349\n  _.shuffle = function(obj) {                                                                                        // 350\n    var set = isArrayLike(obj) ? obj : _.values(obj);                                                                // 351\n    var length = set.length;                                                                                         // 352\n    var shuffled = Array(length);                                                                                    // 353\n    for (var index = 0, rand; index < length; index++) {                                                             // 354\n      rand = _.random(0, index);                                                                                     // 355\n      if (rand !== index) shuffled[index] = shuffled[rand];                                                          // 356\n      shuffled[rand] = set[index];                                                                                   // 357\n    }                                                                                                                // 358\n    return shuffled;                                                                                                 // 359\n  };                                                                                                                 // 360\n                                                                                                                     // 361\n  // Sample **n** random values from a collection.                                                                   // 362\n  // If **n** is not specified, returns a single random element.                                                     // 363\n  // The internal `guard` argument allows it to work with `map`.                                                     // 364\n  _.sample = function(obj, n, guard) {                                                                               // 365\n    if (n == null || guard) {                                                                                        // 366\n      if (!isArrayLike(obj)) obj = _.values(obj);                                                                    // 367\n      return obj[_.random(obj.length - 1)];                                                                          // 368\n    }                                                                                                                // 369\n    return _.shuffle(obj).slice(0, Math.max(0, n));                                                                  // 370\n  };                                                                                                                 // 371\n                                                                                                                     // 372\n  // Sort the object's values by a criterion produced by an iteratee.                                                // 373\n  _.sortBy = function(obj, iteratee, context) {                                                                      // 374\n    iteratee = cb(iteratee, context);                                                                                // 375\n    return _.pluck(_.map(obj, function(value, index, list) {                                                         // 376\n      return {                                                                                                       // 377\n        value: value,                                                                                                // 378\n        index: index,                                                                                                // 379\n        criteria: iteratee(value, index, list)                                                                       // 380\n      };                                                                                                             // 381\n    }).sort(function(left, right) {                                                                                  // 382\n      var a = left.criteria;                                                                                         // 383\n      var b = right.criteria;                                                                                        // 384\n      if (a !== b) {                                                                                                 // 385\n        if (a > b || a === void 0) return 1;                                                                         // 386\n        if (a < b || b === void 0) return -1;                                                                        // 387\n      }                                                                                                              // 388\n      return left.index - right.index;                                                                               // 389\n    }), 'value');                                                                                                    // 390\n  };                                                                                                                 // 391\n                                                                                                                     // 392\n  // An internal function used for aggregate \"group by\" operations.                                                  // 393\n  var group = function(behavior) {                                                                                   // 394\n    return function(obj, iteratee, context) {                                                                        // 395\n      var result = {};                                                                                               // 396\n      iteratee = cb(iteratee, context);                                                                              // 397\n      _.each(obj, function(value, index) {                                                                           // 398\n        var key = iteratee(value, index, obj);                                                                       // 399\n        behavior(result, value, key);                                                                                // 400\n      });                                                                                                            // 401\n      return result;                                                                                                 // 402\n    };                                                                                                               // 403\n  };                                                                                                                 // 404\n                                                                                                                     // 405\n  // Groups the object's values by a criterion. Pass either a string attribute                                       // 406\n  // to group by, or a function that returns the criterion.                                                          // 407\n  _.groupBy = group(function(result, value, key) {                                                                   // 408\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];                                     // 409\n  });                                                                                                                // 410\n                                                                                                                     // 411\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for                                       // 412\n  // when you know that your index values will be unique.                                                            // 413\n  _.indexBy = group(function(result, value, key) {                                                                   // 414\n    result[key] = value;                                                                                             // 415\n  });                                                                                                                // 416\n                                                                                                                     // 417\n  // Counts instances of an object that group by a certain criterion. Pass                                           // 418\n  // either a string attribute to count by, or a function that returns the                                           // 419\n  // criterion.                                                                                                      // 420\n  _.countBy = group(function(result, value, key) {                                                                   // 421\n    if (_.has(result, key)) result[key]++; else result[key] = 1;                                                     // 422\n  });                                                                                                                // 423\n                                                                                                                     // 424\n  // Safely create a real, live array from anything iterable.                                                        // 425\n  _.toArray = function(obj) {                                                                                        // 426\n    if (!obj) return [];                                                                                             // 427\n    if (_.isArray(obj)) return slice.call(obj);                                                                      // 428\n    if (isArrayLike(obj)) return _.map(obj, _.identity);                                                             // 429\n    return _.values(obj);                                                                                            // 430\n  };                                                                                                                 // 431\n                                                                                                                     // 432\n  // Return the number of elements in an object.                                                                     // 433\n  _.size = function(obj) {                                                                                           // 434\n    if (obj == null) return 0;                                                                                       // 435\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;                                                       // 436\n  };                                                                                                                 // 437\n                                                                                                                     // 438\n  // Split a collection into two arrays: one whose elements all satisfy the given                                    // 439\n  // predicate, and one whose elements all do not satisfy the predicate.                                             // 440\n  _.partition = function(obj, predicate, context) {                                                                  // 441\n    predicate = cb(predicate, context);                                                                              // 442\n    var pass = [], fail = [];                                                                                        // 443\n    _.each(obj, function(value, key, obj) {                                                                          // 444\n      (predicate(value, key, obj) ? pass : fail).push(value);                                                        // 445\n    });                                                                                                              // 446\n    return [pass, fail];                                                                                             // 447\n  };                                                                                                                 // 448\n                                                                                                                     // 449\n  // Array Functions                                                                                                 // 450\n  // ---------------                                                                                                 // 451\n                                                                                                                     // 452\n  // Get the first element of an array. Passing **n** will return the first N                                        // 453\n  // values in the array. Aliased as `head` and `take`. The **guard** check                                          // 454\n  // allows it to work with `_.map`.                                                                                 // 455\n  _.first = _.head = _.take = function(array, n, guard) {                                                            // 456\n    if (array == null) return void 0;                                                                                // 457\n    if (n == null || guard) return array[0];                                                                         // 458\n    return _.initial(array, array.length - n);                                                                       // 459\n  };                                                                                                                 // 460\n                                                                                                                     // 461\n  // Returns everything but the last entry of the array. Especially useful on                                        // 462\n  // the arguments object. Passing **n** will return all the values in                                               // 463\n  // the array, excluding the last N.                                                                                // 464\n  _.initial = function(array, n, guard) {                                                                            // 465\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));                           // 466\n  };                                                                                                                 // 467\n                                                                                                                     // 468\n  // Get the last element of an array. Passing **n** will return the last N                                          // 469\n  // values in the array.                                                                                            // 470\n  _.last = function(array, n, guard) {                                                                               // 471\n    if (array == null) return void 0;                                                                                // 472\n    if (n == null || guard) return array[array.length - 1];                                                          // 473\n    return _.rest(array, Math.max(0, array.length - n));                                                             // 474\n  };                                                                                                                 // 475\n                                                                                                                     // 476\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.                              // 477\n  // Especially useful on the arguments object. Passing an **n** will return                                         // 478\n  // the rest N values in the array.                                                                                 // 479\n  _.rest = _.tail = _.drop = function(array, n, guard) {                                                             // 480\n    return slice.call(array, n == null || guard ? 1 : n);                                                            // 481\n  };                                                                                                                 // 482\n                                                                                                                     // 483\n  // Trim out all falsy values from an array.                                                                        // 484\n  _.compact = function(array) {                                                                                      // 485\n    return _.filter(array, _.identity);                                                                              // 486\n  };                                                                                                                 // 487\n                                                                                                                     // 488\n  // Internal implementation of a recursive `flatten` function.                                                      // 489\n  var flatten = function(input, shallow, strict, startIndex) {                                                       // 490\n    var output = [], idx = 0;                                                                                        // 491\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {                                      // 492\n      var value = input[i];                                                                                          // 493\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {                                        // 494\n        //flatten current level of array or arguments object                                                         // 495\n        if (!shallow) value = flatten(value, shallow, strict);                                                       // 496\n        var j = 0, len = value.length;                                                                               // 497\n        output.length += len;                                                                                        // 498\n        while (j < len) {                                                                                            // 499\n          output[idx++] = value[j++];                                                                                // 500\n        }                                                                                                            // 501\n      } else if (!strict) {                                                                                          // 502\n        output[idx++] = value;                                                                                       // 503\n      }                                                                                                              // 504\n    }                                                                                                                // 505\n    return output;                                                                                                   // 506\n  };                                                                                                                 // 507\n                                                                                                                     // 508\n  // Flatten out an array, either recursively (by default), or just one level.                                       // 509\n  _.flatten = function(array, shallow) {                                                                             // 510\n    return flatten(array, shallow, false);                                                                           // 511\n  };                                                                                                                 // 512\n                                                                                                                     // 513\n  // Return a version of the array that does not contain the specified value(s).                                     // 514\n  _.without = function(array) {                                                                                      // 515\n    return _.difference(array, slice.call(arguments, 1));                                                            // 516\n  };                                                                                                                 // 517\n                                                                                                                     // 518\n  // Produce a duplicate-free version of the array. If the array has already                                         // 519\n  // been sorted, you have the option of using a faster algorithm.                                                   // 520\n  // Aliased as `unique`.                                                                                            // 521\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {                                                 // 522\n    if (!_.isBoolean(isSorted)) {                                                                                    // 523\n      context = iteratee;                                                                                            // 524\n      iteratee = isSorted;                                                                                           // 525\n      isSorted = false;                                                                                              // 526\n    }                                                                                                                // 527\n    if (iteratee != null) iteratee = cb(iteratee, context);                                                          // 528\n    var result = [];                                                                                                 // 529\n    var seen = [];                                                                                                   // 530\n    for (var i = 0, length = getLength(array); i < length; i++) {                                                    // 531\n      var value = array[i],                                                                                          // 532\n          computed = iteratee ? iteratee(value, i, array) : value;                                                   // 533\n      if (isSorted) {                                                                                                // 534\n        if (!i || seen !== computed) result.push(value);                                                             // 535\n        seen = computed;                                                                                             // 536\n      } else if (iteratee) {                                                                                         // 537\n        if (!_.contains(seen, computed)) {                                                                           // 538\n          seen.push(computed);                                                                                       // 539\n          result.push(value);                                                                                        // 540\n        }                                                                                                            // 541\n      } else if (!_.contains(result, value)) {                                                                       // 542\n        result.push(value);                                                                                          // 543\n      }                                                                                                              // 544\n    }                                                                                                                // 545\n    return result;                                                                                                   // 546\n  };                                                                                                                 // 547\n                                                                                                                     // 548\n  // Produce an array that contains the union: each distinct element from all of                                     // 549\n  // the passed-in arrays.                                                                                           // 550\n  _.union = function() {                                                                                             // 551\n    return _.uniq(flatten(arguments, true, true));                                                                   // 552\n  };                                                                                                                 // 553\n                                                                                                                     // 554\n  // Produce an array that contains every item shared between all the                                                // 555\n  // passed-in arrays.                                                                                               // 556\n  _.intersection = function(array) {                                                                                 // 557\n    var result = [];                                                                                                 // 558\n    var argsLength = arguments.length;                                                                               // 559\n    for (var i = 0, length = getLength(array); i < length; i++) {                                                    // 560\n      var item = array[i];                                                                                           // 561\n      if (_.contains(result, item)) continue;                                                                        // 562\n      for (var j = 1; j < argsLength; j++) {                                                                         // 563\n        if (!_.contains(arguments[j], item)) break;                                                                  // 564\n      }                                                                                                              // 565\n      if (j === argsLength) result.push(item);                                                                       // 566\n    }                                                                                                                // 567\n    return result;                                                                                                   // 568\n  };                                                                                                                 // 569\n                                                                                                                     // 570\n  // Take the difference between one array and a number of other arrays.                                             // 571\n  // Only the elements present in just the first array will remain.                                                  // 572\n  _.difference = function(array) {                                                                                   // 573\n    var rest = flatten(arguments, true, true, 1);                                                                    // 574\n    return _.filter(array, function(value){                                                                          // 575\n      return !_.contains(rest, value);                                                                               // 576\n    });                                                                                                              // 577\n  };                                                                                                                 // 578\n                                                                                                                     // 579\n  // Zip together multiple lists into a single array -- elements that share                                          // 580\n  // an index go together.                                                                                           // 581\n  _.zip = function() {                                                                                               // 582\n    return _.unzip(arguments);                                                                                       // 583\n  };                                                                                                                 // 584\n                                                                                                                     // 585\n  // Complement of _.zip. Unzip accepts an array of arrays and groups                                                // 586\n  // each array's elements on shared indices                                                                         // 587\n  _.unzip = function(array) {                                                                                        // 588\n    var length = array && _.max(array, getLength).length || 0;                                                       // 589\n    var result = Array(length);                                                                                      // 590\n                                                                                                                     // 591\n    for (var index = 0; index < length; index++) {                                                                   // 592\n      result[index] = _.pluck(array, index);                                                                         // 593\n    }                                                                                                                // 594\n    return result;                                                                                                   // 595\n  };                                                                                                                 // 596\n                                                                                                                     // 597\n  // Converts lists into objects. Pass either a single array of `[key, value]`                                       // 598\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of                                     // 599\n  // the corresponding values.                                                                                       // 600\n  _.object = function(list, values) {                                                                                // 601\n    var result = {};                                                                                                 // 602\n    for (var i = 0, length = getLength(list); i < length; i++) {                                                     // 603\n      if (values) {                                                                                                  // 604\n        result[list[i]] = values[i];                                                                                 // 605\n      } else {                                                                                                       // 606\n        result[list[i][0]] = list[i][1];                                                                             // 607\n      }                                                                                                              // 608\n    }                                                                                                                // 609\n    return result;                                                                                                   // 610\n  };                                                                                                                 // 611\n                                                                                                                     // 612\n  // Generator function to create the findIndex and findLastIndex functions                                          // 613\n  function createPredicateIndexFinder(dir) {                                                                         // 614\n    return function(array, predicate, context) {                                                                     // 615\n      predicate = cb(predicate, context);                                                                            // 616\n      var length = getLength(array);                                                                                 // 617\n      var index = dir > 0 ? 0 : length - 1;                                                                          // 618\n      for (; index >= 0 && index < length; index += dir) {                                                           // 619\n        if (predicate(array[index], index, array)) return index;                                                     // 620\n      }                                                                                                              // 621\n      return -1;                                                                                                     // 622\n    };                                                                                                               // 623\n  }                                                                                                                  // 624\n                                                                                                                     // 625\n  // Returns the first index on an array-like that passes a predicate test                                           // 626\n  _.findIndex = createPredicateIndexFinder(1);                                                                       // 627\n  _.findLastIndex = createPredicateIndexFinder(-1);                                                                  // 628\n                                                                                                                     // 629\n  // Use a comparator function to figure out the smallest index at which                                             // 630\n  // an object should be inserted so as to maintain order. Uses binary search.                                       // 631\n  _.sortedIndex = function(array, obj, iteratee, context) {                                                          // 632\n    iteratee = cb(iteratee, context, 1);                                                                             // 633\n    var value = iteratee(obj);                                                                                       // 634\n    var low = 0, high = getLength(array);                                                                            // 635\n    while (low < high) {                                                                                             // 636\n      var mid = Math.floor((low + high) / 2);                                                                        // 637\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;                                              // 638\n    }                                                                                                                // 639\n    return low;                                                                                                      // 640\n  };                                                                                                                 // 641\n                                                                                                                     // 642\n  // Generator function to create the indexOf and lastIndexOf functions                                              // 643\n  function createIndexFinder(dir, predicateFind, sortedIndex) {                                                      // 644\n    return function(array, item, idx) {                                                                              // 645\n      var i = 0, length = getLength(array);                                                                          // 646\n      if (typeof idx == 'number') {                                                                                  // 647\n        if (dir > 0) {                                                                                               // 648\n            i = idx >= 0 ? idx : Math.max(idx + length, i);                                                          // 649\n        } else {                                                                                                     // 650\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;                                        // 651\n        }                                                                                                            // 652\n      } else if (sortedIndex && idx && length) {                                                                     // 653\n        idx = sortedIndex(array, item);                                                                              // 654\n        return array[idx] === item ? idx : -1;                                                                       // 655\n      }                                                                                                              // 656\n      if (item !== item) {                                                                                           // 657\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);                                                  // 658\n        return idx >= 0 ? idx + i : -1;                                                                              // 659\n      }                                                                                                              // 660\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {                                   // 661\n        if (array[idx] === item) return idx;                                                                         // 662\n      }                                                                                                              // 663\n      return -1;                                                                                                     // 664\n    };                                                                                                               // 665\n  }                                                                                                                  // 666\n                                                                                                                     // 667\n  // Return the position of the first occurrence of an item in an array,                                             // 668\n  // or -1 if the item is not included in the array.                                                                 // 669\n  // If the array is large and already in sort order, pass `true`                                                    // 670\n  // for **isSorted** to use binary search.                                                                          // 671\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);                                                      // 672\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);                                                            // 673\n                                                                                                                     // 674\n  // Generate an integer Array containing an arithmetic progression. A port of                                       // 675\n  // the native Python `range()` function. See                                                                       // 676\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).                                // 677\n  _.range = function(start, stop, step) {                                                                            // 678\n    if (stop == null) {                                                                                              // 679\n      stop = start || 0;                                                                                             // 680\n      start = 0;                                                                                                     // 681\n    }                                                                                                                // 682\n    step = step || 1;                                                                                                // 683\n                                                                                                                     // 684\n    var length = Math.max(Math.ceil((stop - start) / step), 0);                                                      // 685\n    var range = Array(length);                                                                                       // 686\n                                                                                                                     // 687\n    for (var idx = 0; idx < length; idx++, start += step) {                                                          // 688\n      range[idx] = start;                                                                                            // 689\n    }                                                                                                                // 690\n                                                                                                                     // 691\n    return range;                                                                                                    // 692\n  };                                                                                                                 // 693\n                                                                                                                     // 694\n  // Function (ahem) Functions                                                                                       // 695\n  // ------------------                                                                                              // 696\n                                                                                                                     // 697\n  // Determines whether to execute a function as a constructor                                                       // 698\n  // or a normal function with the provided arguments                                                                // 699\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {                                // 700\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);                              // 701\n    var self = baseCreate(sourceFunc.prototype);                                                                     // 702\n    var result = sourceFunc.apply(self, args);                                                                       // 703\n    if (_.isObject(result)) return result;                                                                           // 704\n    return self;                                                                                                     // 705\n  };                                                                                                                 // 706\n                                                                                                                     // 707\n  // Create a function bound to a given object (assigning `this`, and arguments,                                     // 708\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if                                          // 709\n  // available.                                                                                                      // 710\n  _.bind = function(func, context) {                                                                                 // 711\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));             // 712\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');                               // 713\n    var args = slice.call(arguments, 2);                                                                             // 714\n    var bound = function() {                                                                                         // 715\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));                           // 716\n    };                                                                                                               // 717\n    return bound;                                                                                                    // 718\n  };                                                                                                                 // 719\n                                                                                                                     // 720\n  // Partially apply a function by creating a version that has had some of its                                       // 721\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts                                       // 722\n  // as a placeholder, allowing any combination of arguments to be pre-filled.                                       // 723\n  _.partial = function(func) {                                                                                       // 724\n    var boundArgs = slice.call(arguments, 1);                                                                        // 725\n    var bound = function() {                                                                                         // 726\n      var position = 0, length = boundArgs.length;                                                                   // 727\n      var args = Array(length);                                                                                      // 728\n      for (var i = 0; i < length; i++) {                                                                             // 729\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];                                         // 730\n      }                                                                                                              // 731\n      while (position < arguments.length) args.push(arguments[position++]);                                          // 732\n      return executeBound(func, bound, this, this, args);                                                            // 733\n    };                                                                                                               // 734\n    return bound;                                                                                                    // 735\n  };                                                                                                                 // 736\n                                                                                                                     // 737\n  // Bind a number of an object's methods to that object. Remaining arguments                                        // 738\n  // are the method names to be bound. Useful for ensuring that all callbacks                                        // 739\n  // defined on an object belong to it.                                                                              // 740\n  _.bindAll = function(obj) {                                                                                        // 741\n    var i, length = arguments.length, key;                                                                           // 742\n    if (length <= 1) throw new Error('bindAll must be passed function names');                                       // 743\n    for (i = 1; i < length; i++) {                                                                                   // 744\n      key = arguments[i];                                                                                            // 745\n      obj[key] = _.bind(obj[key], obj);                                                                              // 746\n    }                                                                                                                // 747\n    return obj;                                                                                                      // 748\n  };                                                                                                                 // 749\n                                                                                                                     // 750\n  // Memoize an expensive function by storing its results.                                                           // 751\n  _.memoize = function(func, hasher) {                                                                               // 752\n    var memoize = function(key) {                                                                                    // 753\n      var cache = memoize.cache;                                                                                     // 754\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);                                             // 755\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);                                      // 756\n      return cache[address];                                                                                         // 757\n    };                                                                                                               // 758\n    memoize.cache = {};                                                                                              // 759\n    return memoize;                                                                                                  // 760\n  };                                                                                                                 // 761\n                                                                                                                     // 762\n  // Delays a function for the given number of milliseconds, and then calls                                          // 763\n  // it with the arguments supplied.                                                                                 // 764\n  _.delay = function(func, wait) {                                                                                   // 765\n    var args = slice.call(arguments, 2);                                                                             // 766\n    return setTimeout(function(){                                                                                    // 767\n      return func.apply(null, args);                                                                                 // 768\n    }, wait);                                                                                                        // 769\n  };                                                                                                                 // 770\n                                                                                                                     // 771\n  // Defers a function, scheduling it to run after the current call stack has                                        // 772\n  // cleared.                                                                                                        // 773\n  _.defer = _.partial(_.delay, _, 1);                                                                                // 774\n                                                                                                                     // 775\n  // Returns a function, that, when invoked, will only be triggered at most once                                     // 776\n  // during a given window of time. Normally, the throttled function will run                                        // 777\n  // as much as it can, without ever going more than once per `wait` duration;                                       // 778\n  // but if you'd like to disable the execution on the leading edge, pass                                            // 779\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.                                           // 780\n  _.throttle = function(func, wait, options) {                                                                       // 781\n    var context, args, result;                                                                                       // 782\n    var timeout = null;                                                                                              // 783\n    var previous = 0;                                                                                                // 784\n    if (!options) options = {};                                                                                      // 785\n    var later = function() {                                                                                         // 786\n      previous = options.leading === false ? 0 : _.now();                                                            // 787\n      timeout = null;                                                                                                // 788\n      result = func.apply(context, args);                                                                            // 789\n      if (!timeout) context = args = null;                                                                           // 790\n    };                                                                                                               // 791\n    return function() {                                                                                              // 792\n      var now = _.now();                                                                                             // 793\n      if (!previous && options.leading === false) previous = now;                                                    // 794\n      var remaining = wait - (now - previous);                                                                       // 795\n      context = this;                                                                                                // 796\n      args = arguments;                                                                                              // 797\n      if (remaining <= 0 || remaining > wait) {                                                                      // 798\n        if (timeout) {                                                                                               // 799\n          clearTimeout(timeout);                                                                                     // 800\n          timeout = null;                                                                                            // 801\n        }                                                                                                            // 802\n        previous = now;                                                                                              // 803\n        result = func.apply(context, args);                                                                          // 804\n        if (!timeout) context = args = null;                                                                         // 805\n      } else if (!timeout && options.trailing !== false) {                                                           // 806\n        timeout = setTimeout(later, remaining);                                                                      // 807\n      }                                                                                                              // 808\n      return result;                                                                                                 // 809\n    };                                                                                                               // 810\n  };                                                                                                                 // 811\n                                                                                                                     // 812\n  // Returns a function, that, as long as it continues to be invoked, will not                                       // 813\n  // be triggered. The function will be called after it stops being called for                                       // 814\n  // N milliseconds. If `immediate` is passed, trigger the function on the                                           // 815\n  // leading edge, instead of the trailing.                                                                          // 816\n  _.debounce = function(func, wait, immediate) {                                                                     // 817\n    var timeout, args, context, timestamp, result;                                                                   // 818\n                                                                                                                     // 819\n    var later = function() {                                                                                         // 820\n      var last = _.now() - timestamp;                                                                                // 821\n                                                                                                                     // 822\n      if (last < wait && last >= 0) {                                                                                // 823\n        timeout = setTimeout(later, wait - last);                                                                    // 824\n      } else {                                                                                                       // 825\n        timeout = null;                                                                                              // 826\n        if (!immediate) {                                                                                            // 827\n          result = func.apply(context, args);                                                                        // 828\n          if (!timeout) context = args = null;                                                                       // 829\n        }                                                                                                            // 830\n      }                                                                                                              // 831\n    };                                                                                                               // 832\n                                                                                                                     // 833\n    return function() {                                                                                              // 834\n      context = this;                                                                                                // 835\n      args = arguments;                                                                                              // 836\n      timestamp = _.now();                                                                                           // 837\n      var callNow = immediate && !timeout;                                                                           // 838\n      if (!timeout) timeout = setTimeout(later, wait);                                                               // 839\n      if (callNow) {                                                                                                 // 840\n        result = func.apply(context, args);                                                                          // 841\n        context = args = null;                                                                                       // 842\n      }                                                                                                              // 843\n                                                                                                                     // 844\n      return result;                                                                                                 // 845\n    };                                                                                                               // 846\n  };                                                                                                                 // 847\n                                                                                                                     // 848\n  // Returns the first function passed as an argument to the second,                                                 // 849\n  // allowing you to adjust arguments, run code before and after, and                                                // 850\n  // conditionally execute the original function.                                                                    // 851\n  _.wrap = function(func, wrapper) {                                                                                 // 852\n    return _.partial(wrapper, func);                                                                                 // 853\n  };                                                                                                                 // 854\n                                                                                                                     // 855\n  // Returns a negated version of the passed-in predicate.                                                           // 856\n  _.negate = function(predicate) {                                                                                   // 857\n    return function() {                                                                                              // 858\n      return !predicate.apply(this, arguments);                                                                      // 859\n    };                                                                                                               // 860\n  };                                                                                                                 // 861\n                                                                                                                     // 862\n  // Returns a function that is the composition of a list of functions, each                                         // 863\n  // consuming the return value of the function that follows.                                                        // 864\n  _.compose = function() {                                                                                           // 865\n    var args = arguments;                                                                                            // 866\n    var start = args.length - 1;                                                                                     // 867\n    return function() {                                                                                              // 868\n      var i = start;                                                                                                 // 869\n      var result = args[start].apply(this, arguments);                                                               // 870\n      while (i--) result = args[i].call(this, result);                                                               // 871\n      return result;                                                                                                 // 872\n    };                                                                                                               // 873\n  };                                                                                                                 // 874\n                                                                                                                     // 875\n  // Returns a function that will only be executed on and after the Nth call.                                        // 876\n  _.after = function(times, func) {                                                                                  // 877\n    return function() {                                                                                              // 878\n      if (--times < 1) {                                                                                             // 879\n        return func.apply(this, arguments);                                                                          // 880\n      }                                                                                                              // 881\n    };                                                                                                               // 882\n  };                                                                                                                 // 883\n                                                                                                                     // 884\n  // Returns a function that will only be executed up to (but not including) the Nth call.                           // 885\n  _.before = function(times, func) {                                                                                 // 886\n    var memo;                                                                                                        // 887\n    return function() {                                                                                              // 888\n      if (--times > 0) {                                                                                             // 889\n        memo = func.apply(this, arguments);                                                                          // 890\n      }                                                                                                              // 891\n      if (times <= 1) func = null;                                                                                   // 892\n      return memo;                                                                                                   // 893\n    };                                                                                                               // 894\n  };                                                                                                                 // 895\n                                                                                                                     // 896\n  // Returns a function that will be executed at most one time, no matter how                                        // 897\n  // often you call it. Useful for lazy initialization.                                                              // 898\n  _.once = _.partial(_.before, 2);                                                                                   // 899\n                                                                                                                     // 900\n  // Object Functions                                                                                                // 901\n  // ----------------                                                                                                // 902\n                                                                                                                     // 903\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.                                      // 904\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');                                               // 905\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',                                                  // 906\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];                                   // 907\n                                                                                                                     // 908\n  function collectNonEnumProps(obj, keys) {                                                                          // 909\n    var nonEnumIdx = nonEnumerableProps.length;                                                                      // 910\n    var constructor = obj.constructor;                                                                               // 911\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;                                    // 912\n                                                                                                                     // 913\n    // Constructor is a special case.                                                                                // 914\n    var prop = 'constructor';                                                                                        // 915\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);                                                // 916\n                                                                                                                     // 917\n    while (nonEnumIdx--) {                                                                                           // 918\n      prop = nonEnumerableProps[nonEnumIdx];                                                                         // 919\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {                                     // 920\n        keys.push(prop);                                                                                             // 921\n      }                                                                                                              // 922\n    }                                                                                                                // 923\n  }                                                                                                                  // 924\n                                                                                                                     // 925\n  // Retrieve the names of an object's own properties.                                                               // 926\n  // Delegates to **ECMAScript 5**'s native `Object.keys`                                                            // 927\n  _.keys = function(obj) {                                                                                           // 928\n    if (!_.isObject(obj)) return [];                                                                                 // 929\n    if (nativeKeys) return nativeKeys(obj);                                                                          // 930\n    var keys = [];                                                                                                   // 931\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);                                                        // 932\n    // Ahem, IE < 9.                                                                                                 // 933\n    if (hasEnumBug) collectNonEnumProps(obj, keys);                                                                  // 934\n    return keys;                                                                                                     // 935\n  };                                                                                                                 // 936\n                                                                                                                     // 937\n  // Retrieve all the property names of an object.                                                                   // 938\n  _.allKeys = function(obj) {                                                                                        // 939\n    if (!_.isObject(obj)) return [];                                                                                 // 940\n    var keys = [];                                                                                                   // 941\n    for (var key in obj) keys.push(key);                                                                             // 942\n    // Ahem, IE < 9.                                                                                                 // 943\n    if (hasEnumBug) collectNonEnumProps(obj, keys);                                                                  // 944\n    return keys;                                                                                                     // 945\n  };                                                                                                                 // 946\n                                                                                                                     // 947\n  // Retrieve the values of an object's properties.                                                                  // 948\n  _.values = function(obj) {                                                                                         // 949\n    var keys = _.keys(obj);                                                                                          // 950\n    var length = keys.length;                                                                                        // 951\n    var values = Array(length);                                                                                      // 952\n    for (var i = 0; i < length; i++) {                                                                               // 953\n      values[i] = obj[keys[i]];                                                                                      // 954\n    }                                                                                                                // 955\n    return values;                                                                                                   // 956\n  };                                                                                                                 // 957\n                                                                                                                     // 958\n  // Returns the results of applying the iteratee to each element of the object                                      // 959\n  // In contrast to _.map it returns an object                                                                       // 960\n  _.mapObject = function(obj, iteratee, context) {                                                                   // 961\n    iteratee = cb(iteratee, context);                                                                                // 962\n    var keys =  _.keys(obj),                                                                                         // 963\n          length = keys.length,                                                                                      // 964\n          results = {},                                                                                              // 965\n          currentKey;                                                                                                // 966\n      for (var index = 0; index < length; index++) {                                                                 // 967\n        currentKey = keys[index];                                                                                    // 968\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);                                            // 969\n      }                                                                                                              // 970\n      return results;                                                                                                // 971\n  };                                                                                                                 // 972\n                                                                                                                     // 973\n  // Convert an object into a list of `[key, value]` pairs.                                                          // 974\n  _.pairs = function(obj) {                                                                                          // 975\n    var keys = _.keys(obj);                                                                                          // 976\n    var length = keys.length;                                                                                        // 977\n    var pairs = Array(length);                                                                                       // 978\n    for (var i = 0; i < length; i++) {                                                                               // 979\n      pairs[i] = [keys[i], obj[keys[i]]];                                                                            // 980\n    }                                                                                                                // 981\n    return pairs;                                                                                                    // 982\n  };                                                                                                                 // 983\n                                                                                                                     // 984\n  // Invert the keys and values of an object. The values must be serializable.                                       // 985\n  _.invert = function(obj) {                                                                                         // 986\n    var result = {};                                                                                                 // 987\n    var keys = _.keys(obj);                                                                                          // 988\n    for (var i = 0, length = keys.length; i < length; i++) {                                                         // 989\n      result[obj[keys[i]]] = keys[i];                                                                                // 990\n    }                                                                                                                // 991\n    return result;                                                                                                   // 992\n  };                                                                                                                 // 993\n                                                                                                                     // 994\n  // Return a sorted list of the function names available on the object.                                             // 995\n  // Aliased as `methods`                                                                                            // 996\n  _.functions = _.methods = function(obj) {                                                                          // 997\n    var names = [];                                                                                                  // 998\n    for (var key in obj) {                                                                                           // 999\n      if (_.isFunction(obj[key])) names.push(key);                                                                   // 1000\n    }                                                                                                                // 1001\n    return names.sort();                                                                                             // 1002\n  };                                                                                                                 // 1003\n                                                                                                                     // 1004\n  // Extend a given object with all the properties in passed-in object(s).                                           // 1005\n  _.extend = createAssigner(_.allKeys);                                                                              // 1006\n                                                                                                                     // 1007\n  // Assigns a given object with all the own properties in the passed-in object(s)                                   // 1008\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)                      // 1009\n  _.extendOwn = _.assign = createAssigner(_.keys);                                                                   // 1010\n                                                                                                                     // 1011\n  // Returns the first key on an object that passes a predicate test                                                 // 1012\n  _.findKey = function(obj, predicate, context) {                                                                    // 1013\n    predicate = cb(predicate, context);                                                                              // 1014\n    var keys = _.keys(obj), key;                                                                                     // 1015\n    for (var i = 0, length = keys.length; i < length; i++) {                                                         // 1016\n      key = keys[i];                                                                                                 // 1017\n      if (predicate(obj[key], key, obj)) return key;                                                                 // 1018\n    }                                                                                                                // 1019\n  };                                                                                                                 // 1020\n                                                                                                                     // 1021\n  // Return a copy of the object only containing the whitelisted properties.                                         // 1022\n  _.pick = function(object, oiteratee, context) {                                                                    // 1023\n    var result = {}, obj = object, iteratee, keys;                                                                   // 1024\n    if (obj == null) return result;                                                                                  // 1025\n    if (_.isFunction(oiteratee)) {                                                                                   // 1026\n      keys = _.allKeys(obj);                                                                                         // 1027\n      iteratee = optimizeCb(oiteratee, context);                                                                     // 1028\n    } else {                                                                                                         // 1029\n      keys = flatten(arguments, false, false, 1);                                                                    // 1030\n      iteratee = function(value, key, obj) { return key in obj; };                                                   // 1031\n      obj = Object(obj);                                                                                             // 1032\n    }                                                                                                                // 1033\n    for (var i = 0, length = keys.length; i < length; i++) {                                                         // 1034\n      var key = keys[i];                                                                                             // 1035\n      var value = obj[key];                                                                                          // 1036\n      if (iteratee(value, key, obj)) result[key] = value;                                                            // 1037\n    }                                                                                                                // 1038\n    return result;                                                                                                   // 1039\n  };                                                                                                                 // 1040\n                                                                                                                     // 1041\n   // Return a copy of the object without the blacklisted properties.                                                // 1042\n  _.omit = function(obj, iteratee, context) {                                                                        // 1043\n    if (_.isFunction(iteratee)) {                                                                                    // 1044\n      iteratee = _.negate(iteratee);                                                                                 // 1045\n    } else {                                                                                                         // 1046\n      var keys = _.map(flatten(arguments, false, false, 1), String);                                                 // 1047\n      iteratee = function(value, key) {                                                                              // 1048\n        return !_.contains(keys, key);                                                                               // 1049\n      };                                                                                                             // 1050\n    }                                                                                                                // 1051\n    return _.pick(obj, iteratee, context);                                                                           // 1052\n  };                                                                                                                 // 1053\n                                                                                                                     // 1054\n  // Fill in a given object with default properties.                                                                 // 1055\n  _.defaults = createAssigner(_.allKeys, true);                                                                      // 1056\n                                                                                                                     // 1057\n  // Creates an object that inherits from the given prototype object.                                                // 1058\n  // If additional properties are provided then they will be added to the                                            // 1059\n  // created object.                                                                                                 // 1060\n  _.create = function(prototype, props) {                                                                            // 1061\n    var result = baseCreate(prototype);                                                                              // 1062\n    if (props) _.extendOwn(result, props);                                                                           // 1063\n    return result;                                                                                                   // 1064\n  };                                                                                                                 // 1065\n                                                                                                                     // 1066\n  // Create a (shallow-cloned) duplicate of an object.                                                               // 1067\n  _.clone = function(obj) {                                                                                          // 1068\n    if (!_.isObject(obj)) return obj;                                                                                // 1069\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);                                                         // 1070\n  };                                                                                                                 // 1071\n                                                                                                                     // 1072\n  // Invokes interceptor with the obj, and then returns obj.                                                         // 1073\n  // The primary purpose of this method is to \"tap into\" a method chain, in                                          // 1074\n  // order to perform operations on intermediate results within the chain.                                           // 1075\n  _.tap = function(obj, interceptor) {                                                                               // 1076\n    interceptor(obj);                                                                                                // 1077\n    return obj;                                                                                                      // 1078\n  };                                                                                                                 // 1079\n                                                                                                                     // 1080\n  // Returns whether an object has a given set of `key:value` pairs.                                                 // 1081\n  _.isMatch = function(object, attrs) {                                                                              // 1082\n    var keys = _.keys(attrs), length = keys.length;                                                                  // 1083\n    if (object == null) return !length;                                                                              // 1084\n    var obj = Object(object);                                                                                        // 1085\n    for (var i = 0; i < length; i++) {                                                                               // 1086\n      var key = keys[i];                                                                                             // 1087\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;                                                    // 1088\n    }                                                                                                                // 1089\n    return true;                                                                                                     // 1090\n  };                                                                                                                 // 1091\n                                                                                                                     // 1092\n                                                                                                                     // 1093\n  // Internal recursive comparison function for `isEqual`.                                                           // 1094\n  var eq = function(a, b, aStack, bStack) {                                                                          // 1095\n    // Identical objects are equal. `0 === -0`, but they aren't identical.                                           // 1096\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).                       // 1097\n    if (a === b) return a !== 0 || 1 / a === 1 / b;                                                                  // 1098\n    // A strict comparison is necessary because `null == undefined`.                                                 // 1099\n    if (a == null || b == null) return a === b;                                                                      // 1100\n    // Unwrap any wrapped objects.                                                                                   // 1101\n    if (a instanceof _) a = a._wrapped;                                                                              // 1102\n    if (b instanceof _) b = b._wrapped;                                                                              // 1103\n    // Compare `[[Class]]` names.                                                                                    // 1104\n    var className = toString.call(a);                                                                                // 1105\n    if (className !== toString.call(b)) return false;                                                                // 1106\n    switch (className) {                                                                                             // 1107\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.                           // 1108\n      case '[object RegExp]':                                                                                        // 1109\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')                                  // 1110\n      case '[object String]':                                                                                        // 1111\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is                         // 1112\n        // equivalent to `new String(\"5\")`.                                                                          // 1113\n        return '' + a === '' + b;                                                                                    // 1114\n      case '[object Number]':                                                                                        // 1115\n        // `NaN`s are equivalent, but non-reflexive.                                                                 // 1116\n        // Object(NaN) is equivalent to NaN                                                                          // 1117\n        if (+a !== +a) return +b !== +b;                                                                             // 1118\n        // An `egal` comparison is performed for other numeric values.                                               // 1119\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;                                                              // 1120\n      case '[object Date]':                                                                                          // 1121\n      case '[object Boolean]':                                                                                       // 1122\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their                        // 1123\n        // millisecond representations. Note that invalid dates with millisecond representations                     // 1124\n        // of `NaN` are not equivalent.                                                                              // 1125\n        return +a === +b;                                                                                            // 1126\n    }                                                                                                                // 1127\n                                                                                                                     // 1128\n    var areArrays = className === '[object Array]';                                                                  // 1129\n    if (!areArrays) {                                                                                                // 1130\n      if (typeof a != 'object' || typeof b != 'object') return false;                                                // 1131\n                                                                                                                     // 1132\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s                           // 1133\n      // from different frames are.                                                                                  // 1134\n      var aCtor = a.constructor, bCtor = b.constructor;                                                              // 1135\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&                                      // 1136\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)                                        // 1137\n                          && ('constructor' in a && 'constructor' in b)) {                                           // 1138\n        return false;                                                                                                // 1139\n      }                                                                                                              // 1140\n    }                                                                                                                // 1141\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic                                     // 1142\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.                                   // 1143\n                                                                                                                     // 1144\n    // Initializing stack of traversed objects.                                                                      // 1145\n    // It's done here since we only need them for objects and arrays comparison.                                     // 1146\n    aStack = aStack || [];                                                                                           // 1147\n    bStack = bStack || [];                                                                                           // 1148\n    var length = aStack.length;                                                                                      // 1149\n    while (length--) {                                                                                               // 1150\n      // Linear search. Performance is inversely proportional to the number of                                       // 1151\n      // unique nested structures.                                                                                   // 1152\n      if (aStack[length] === a) return bStack[length] === b;                                                         // 1153\n    }                                                                                                                // 1154\n                                                                                                                     // 1155\n    // Add the first object to the stack of traversed objects.                                                       // 1156\n    aStack.push(a);                                                                                                  // 1157\n    bStack.push(b);                                                                                                  // 1158\n                                                                                                                     // 1159\n    // Recursively compare objects and arrays.                                                                       // 1160\n    if (areArrays) {                                                                                                 // 1161\n      // Compare array lengths to determine if a deep comparison is necessary.                                       // 1162\n      length = a.length;                                                                                             // 1163\n      if (length !== b.length) return false;                                                                         // 1164\n      // Deep compare the contents, ignoring non-numeric properties.                                                 // 1165\n      while (length--) {                                                                                             // 1166\n        if (!eq(a[length], b[length], aStack, bStack)) return false;                                                 // 1167\n      }                                                                                                              // 1168\n    } else {                                                                                                         // 1169\n      // Deep compare objects.                                                                                       // 1170\n      var keys = _.keys(a), key;                                                                                     // 1171\n      length = keys.length;                                                                                          // 1172\n      // Ensure that both objects contain the same number of properties before comparing deep equality.              // 1173\n      if (_.keys(b).length !== length) return false;                                                                 // 1174\n      while (length--) {                                                                                             // 1175\n        // Deep compare each member                                                                                  // 1176\n        key = keys[length];                                                                                          // 1177\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;                                    // 1178\n      }                                                                                                              // 1179\n    }                                                                                                                // 1180\n    // Remove the first object from the stack of traversed objects.                                                  // 1181\n    aStack.pop();                                                                                                    // 1182\n    bStack.pop();                                                                                                    // 1183\n    return true;                                                                                                     // 1184\n  };                                                                                                                 // 1185\n                                                                                                                     // 1186\n  // Perform a deep comparison to check if two objects are equal.                                                    // 1187\n  _.isEqual = function(a, b) {                                                                                       // 1188\n    return eq(a, b);                                                                                                 // 1189\n  };                                                                                                                 // 1190\n                                                                                                                     // 1191\n  // Is a given array, string, or object empty?                                                                      // 1192\n  // An \"empty\" object has no enumerable own-properties.                                                             // 1193\n  _.isEmpty = function(obj) {                                                                                        // 1194\n    if (obj == null) return true;                                                                                    // 1195\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;      // 1196\n    return _.keys(obj).length === 0;                                                                                 // 1197\n  };                                                                                                                 // 1198\n                                                                                                                     // 1199\n  // Is a given value a DOM element?                                                                                 // 1200\n  _.isElement = function(obj) {                                                                                      // 1201\n    return !!(obj && obj.nodeType === 1);                                                                            // 1202\n  };                                                                                                                 // 1203\n                                                                                                                     // 1204\n  // Is a given value an array?                                                                                      // 1205\n  // Delegates to ECMA5's native Array.isArray                                                                       // 1206\n  _.isArray = nativeIsArray || function(obj) {                                                                       // 1207\n    return toString.call(obj) === '[object Array]';                                                                  // 1208\n  };                                                                                                                 // 1209\n                                                                                                                     // 1210\n  // Is a given variable an object?                                                                                  // 1211\n  _.isObject = function(obj) {                                                                                       // 1212\n    var type = typeof obj;                                                                                           // 1213\n    return type === 'function' || type === 'object' && !!obj;                                                        // 1214\n  };                                                                                                                 // 1215\n                                                                                                                     // 1216\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.                // 1217\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {                  // 1218\n    _['is' + name] = function(obj) {                                                                                 // 1219\n      return toString.call(obj) === '[object ' + name + ']';                                                         // 1220\n    };                                                                                                               // 1221\n  });                                                                                                                // 1222\n                                                                                                                     // 1223\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where                                       // 1224\n  // there isn't any inspectable \"Arguments\" type.                                                                   // 1225\n  if (!_.isArguments(arguments)) {                                                                                   // 1226\n    _.isArguments = function(obj) {                                                                                  // 1227\n      return _.has(obj, 'callee');                                                                                   // 1228\n    };                                                                                                               // 1229\n  }                                                                                                                  // 1230\n                                                                                                                     // 1231\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,                                   // 1232\n  // IE 11 (#1621), and in Safari 8 (#1929).                                                                         // 1233\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {                                                    // 1234\n    _.isFunction = function(obj) {                                                                                   // 1235\n      return typeof obj == 'function' || false;                                                                      // 1236\n    };                                                                                                               // 1237\n  }                                                                                                                  // 1238\n                                                                                                                     // 1239\n  // Is a given object a finite number?                                                                              // 1240\n  _.isFinite = function(obj) {                                                                                       // 1241\n    return isFinite(obj) && !isNaN(parseFloat(obj));                                                                 // 1242\n  };                                                                                                                 // 1243\n                                                                                                                     // 1244\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).                                 // 1245\n  _.isNaN = function(obj) {                                                                                          // 1246\n    return _.isNumber(obj) && obj !== +obj;                                                                          // 1247\n  };                                                                                                                 // 1248\n                                                                                                                     // 1249\n  // Is a given value a boolean?                                                                                     // 1250\n  _.isBoolean = function(obj) {                                                                                      // 1251\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';                               // 1252\n  };                                                                                                                 // 1253\n                                                                                                                     // 1254\n  // Is a given value equal to null?                                                                                 // 1255\n  _.isNull = function(obj) {                                                                                         // 1256\n    return obj === null;                                                                                             // 1257\n  };                                                                                                                 // 1258\n                                                                                                                     // 1259\n  // Is a given variable undefined?                                                                                  // 1260\n  _.isUndefined = function(obj) {                                                                                    // 1261\n    return obj === void 0;                                                                                           // 1262\n  };                                                                                                                 // 1263\n                                                                                                                     // 1264\n  // Shortcut function for checking if an object has a given property directly                                       // 1265\n  // on itself (in other words, not on a prototype).                                                                 // 1266\n  _.has = function(obj, key) {                                                                                       // 1267\n    return obj != null && hasOwnProperty.call(obj, key);                                                             // 1268\n  };                                                                                                                 // 1269\n                                                                                                                     // 1270\n  // Utility Functions                                                                                               // 1271\n  // -----------------                                                                                               // 1272\n                                                                                                                     // 1273\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its                                       // 1274\n  // previous owner. Returns a reference to the Underscore object.                                                   // 1275\n  _.noConflict = function() {                                                                                        // 1276\n    root._ = previousUnderscore;                                                                                     // 1277\n    return this;                                                                                                     // 1278\n  };                                                                                                                 // 1279\n                                                                                                                     // 1280\n  // Keep the identity function around for default iteratees.                                                        // 1281\n  _.identity = function(value) {                                                                                     // 1282\n    return value;                                                                                                    // 1283\n  };                                                                                                                 // 1284\n                                                                                                                     // 1285\n  // Predicate-generating functions. Often useful outside of Underscore.                                             // 1286\n  _.constant = function(value) {                                                                                     // 1287\n    return function() {                                                                                              // 1288\n      return value;                                                                                                  // 1289\n    };                                                                                                               // 1290\n  };                                                                                                                 // 1291\n                                                                                                                     // 1292\n  _.noop = function(){};                                                                                             // 1293\n                                                                                                                     // 1294\n  _.property = property;                                                                                             // 1295\n                                                                                                                     // 1296\n  // Generates a function for a given object that returns a given property.                                          // 1297\n  _.propertyOf = function(obj) {                                                                                     // 1298\n    return obj == null ? function(){} : function(key) {                                                              // 1299\n      return obj[key];                                                                                               // 1300\n    };                                                                                                               // 1301\n  };                                                                                                                 // 1302\n                                                                                                                     // 1303\n  // Returns a predicate for checking whether an object has a given set of                                           // 1304\n  // `key:value` pairs.                                                                                              // 1305\n  _.matcher = _.matches = function(attrs) {                                                                          // 1306\n    attrs = _.extendOwn({}, attrs);                                                                                  // 1307\n    return function(obj) {                                                                                           // 1308\n      return _.isMatch(obj, attrs);                                                                                  // 1309\n    };                                                                                                               // 1310\n  };                                                                                                                 // 1311\n                                                                                                                     // 1312\n  // Run a function **n** times.                                                                                     // 1313\n  _.times = function(n, iteratee, context) {                                                                         // 1314\n    var accum = Array(Math.max(0, n));                                                                               // 1315\n    iteratee = optimizeCb(iteratee, context, 1);                                                                     // 1316\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);                                                              // 1317\n    return accum;                                                                                                    // 1318\n  };                                                                                                                 // 1319\n                                                                                                                     // 1320\n  // Return a random integer between min and max (inclusive).                                                        // 1321\n  _.random = function(min, max) {                                                                                    // 1322\n    if (max == null) {                                                                                               // 1323\n      max = min;                                                                                                     // 1324\n      min = 0;                                                                                                       // 1325\n    }                                                                                                                // 1326\n    return min + Math.floor(Math.random() * (max - min + 1));                                                        // 1327\n  };                                                                                                                 // 1328\n                                                                                                                     // 1329\n  // A (possibly faster) way to get the current timestamp as an integer.                                             // 1330\n  _.now = Date.now || function() {                                                                                   // 1331\n    return new Date().getTime();                                                                                     // 1332\n  };                                                                                                                 // 1333\n                                                                                                                     // 1334\n   // List of HTML entities for escaping.                                                                            // 1335\n  var escapeMap = {                                                                                                  // 1336\n    '&': '&amp;',                                                                                                    // 1337\n    '<': '&lt;',                                                                                                     // 1338\n    '>': '&gt;',                                                                                                     // 1339\n    '\"': '&quot;',                                                                                                   // 1340\n    \"'\": '&#x27;',                                                                                                   // 1341\n    '`': '&#x60;'                                                                                                    // 1342\n  };                                                                                                                 // 1343\n  var unescapeMap = _.invert(escapeMap);                                                                             // 1344\n                                                                                                                     // 1345\n  // Functions for escaping and unescaping strings to/from HTML interpolation.                                       // 1346\n  var createEscaper = function(map) {                                                                                // 1347\n    var escaper = function(match) {                                                                                  // 1348\n      return map[match];                                                                                             // 1349\n    };                                                                                                               // 1350\n    // Regexes for identifying a key that needs to be escaped                                                        // 1351\n    var source = '(?:' + _.keys(map).join('|') + ')';                                                                // 1352\n    var testRegexp = RegExp(source);                                                                                 // 1353\n    var replaceRegexp = RegExp(source, 'g');                                                                         // 1354\n    return function(string) {                                                                                        // 1355\n      string = string == null ? '' : '' + string;                                                                    // 1356\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;                              // 1357\n    };                                                                                                               // 1358\n  };                                                                                                                 // 1359\n  _.escape = createEscaper(escapeMap);                                                                               // 1360\n  _.unescape = createEscaper(unescapeMap);                                                                           // 1361\n                                                                                                                     // 1362\n  // If the value of the named `property` is a function then invoke it with the                                      // 1363\n  // `object` as context; otherwise, return it.                                                                      // 1364\n  _.result = function(object, property, fallback) {                                                                  // 1365\n    var value = object == null ? void 0 : object[property];                                                          // 1366\n    if (value === void 0) {                                                                                          // 1367\n      value = fallback;                                                                                              // 1368\n    }                                                                                                                // 1369\n    return _.isFunction(value) ? value.call(object) : value;                                                         // 1370\n  };                                                                                                                 // 1371\n                                                                                                                     // 1372\n  // Generate a unique integer id (unique within the entire client session).                                         // 1373\n  // Useful for temporary DOM ids.                                                                                   // 1374\n  var idCounter = 0;                                                                                                 // 1375\n  _.uniqueId = function(prefix) {                                                                                    // 1376\n    var id = ++idCounter + '';                                                                                       // 1377\n    return prefix ? prefix + id : id;                                                                                // 1378\n  };                                                                                                                 // 1379\n                                                                                                                     // 1380\n  // By default, Underscore uses ERB-style template delimiters, change the                                           // 1381\n  // following template settings to use alternative delimiters.                                                      // 1382\n  _.templateSettings = {                                                                                             // 1383\n    evaluate    : /<%([\\s\\S]+?)%>/g,                                                                                 // 1384\n    interpolate : /<%=([\\s\\S]+?)%>/g,                                                                                // 1385\n    escape      : /<%-([\\s\\S]+?)%>/g                                                                                 // 1386\n  };                                                                                                                 // 1387\n                                                                                                                     // 1388\n  // When customizing `templateSettings`, if you don't want to define an                                             // 1389\n  // interpolation, evaluation or escaping regex, we need one that is                                                // 1390\n  // guaranteed not to match.                                                                                        // 1391\n  var noMatch = /(.)^/;                                                                                              // 1392\n                                                                                                                     // 1393\n  // Certain characters need to be escaped so that they can be put into a                                            // 1394\n  // string literal.                                                                                                 // 1395\n  var escapes = {                                                                                                    // 1396\n    \"'\":      \"'\",                                                                                                   // 1397\n    '\\\\':     '\\\\',                                                                                                  // 1398\n    '\\r':     'r',                                                                                                   // 1399\n    '\\n':     'n',                                                                                                   // 1400\n    '\\u2028': 'u2028',                                                                                               // 1401\n    '\\u2029': 'u2029'                                                                                                // 1402\n  };                                                                                                                 // 1403\n                                                                                                                     // 1404\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;                                                                         // 1405\n                                                                                                                     // 1406\n  var escapeChar = function(match) {                                                                                 // 1407\n    return '\\\\' + escapes[match];                                                                                    // 1408\n  };                                                                                                                 // 1409\n                                                                                                                     // 1410\n  // JavaScript micro-templating, similar to John Resig's implementation.                                            // 1411\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,                                       // 1412\n  // and correctly escapes quotes within interpolated code.                                                          // 1413\n  // NB: `oldSettings` only exists for backwards compatibility.                                                      // 1414\n  _.template = function(text, settings, oldSettings) {                                                               // 1415\n    if (!settings && oldSettings) settings = oldSettings;                                                            // 1416\n    settings = _.defaults({}, settings, _.templateSettings);                                                         // 1417\n                                                                                                                     // 1418\n    // Combine delimiters into one regular expression via alternation.                                               // 1419\n    var matcher = RegExp([                                                                                           // 1420\n      (settings.escape || noMatch).source,                                                                           // 1421\n      (settings.interpolate || noMatch).source,                                                                      // 1422\n      (settings.evaluate || noMatch).source                                                                          // 1423\n    ].join('|') + '|$', 'g');                                                                                        // 1424\n                                                                                                                     // 1425\n    // Compile the template source, escaping string literals appropriately.                                          // 1426\n    var index = 0;                                                                                                   // 1427\n    var source = \"__p+='\";                                                                                           // 1428\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {                                   // 1429\n      source += text.slice(index, offset).replace(escaper, escapeChar);                                              // 1430\n      index = offset + match.length;                                                                                 // 1431\n                                                                                                                     // 1432\n      if (escape) {                                                                                                  // 1433\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";                                         // 1434\n      } else if (interpolate) {                                                                                      // 1435\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";                                              // 1436\n      } else if (evaluate) {                                                                                         // 1437\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";                                                                    // 1438\n      }                                                                                                              // 1439\n                                                                                                                     // 1440\n      // Adobe VMs need the match returned to produce the correct offest.                                            // 1441\n      return match;                                                                                                  // 1442\n    });                                                                                                              // 1443\n    source += \"';\\n\";                                                                                                // 1444\n                                                                                                                     // 1445\n    // If a variable is not specified, place data values in local scope.                                             // 1446\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';                                            // 1447\n                                                                                                                     // 1448\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +                                                            // 1449\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +                                                          // 1450\n      source + 'return __p;\\n';                                                                                      // 1451\n                                                                                                                     // 1452\n    try {                                                                                                            // 1453\n      var render = new Function(settings.variable || 'obj', '_', source);                                            // 1454\n    } catch (e) {                                                                                                    // 1455\n      e.source = source;                                                                                             // 1456\n      throw e;                                                                                                       // 1457\n    }                                                                                                                // 1458\n                                                                                                                     // 1459\n    var template = function(data) {                                                                                  // 1460\n      return render.call(this, data, _);                                                                             // 1461\n    };                                                                                                               // 1462\n                                                                                                                     // 1463\n    // Provide the compiled source as a convenience for precompilation.                                              // 1464\n    var argument = settings.variable || 'obj';                                                                       // 1465\n    template.source = 'function(' + argument + '){\\n' + source + '}';                                                // 1466\n                                                                                                                     // 1467\n    return template;                                                                                                 // 1468\n  };                                                                                                                 // 1469\n                                                                                                                     // 1470\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.                                             // 1471\n  _.chain = function(obj) {                                                                                          // 1472\n    var instance = _(obj);                                                                                           // 1473\n    instance._chain = true;                                                                                          // 1474\n    return instance;                                                                                                 // 1475\n  };                                                                                                                 // 1476\n                                                                                                                     // 1477\n  // OOP                                                                                                             // 1478\n  // ---------------                                                                                                 // 1479\n  // If Underscore is called as a function, it returns a wrapped object that                                         // 1480\n  // can be used OO-style. This wrapper holds altered versions of all the                                            // 1481\n  // underscore functions. Wrapped objects may be chained.                                                           // 1482\n                                                                                                                     // 1483\n  // Helper function to continue chaining intermediate results.                                                      // 1484\n  var result = function(instance, obj) {                                                                             // 1485\n    return instance._chain ? _(obj).chain() : obj;                                                                   // 1486\n  };                                                                                                                 // 1487\n                                                                                                                     // 1488\n  // Add your own custom functions to the Underscore object.                                                         // 1489\n  _.mixin = function(obj) {                                                                                          // 1490\n    _.each(_.functions(obj), function(name) {                                                                        // 1491\n      var func = _[name] = obj[name];                                                                                // 1492\n      _.prototype[name] = function() {                                                                               // 1493\n        var args = [this._wrapped];                                                                                  // 1494\n        push.apply(args, arguments);                                                                                 // 1495\n        return result(this, func.apply(_, args));                                                                    // 1496\n      };                                                                                                             // 1497\n    });                                                                                                              // 1498\n  };                                                                                                                 // 1499\n                                                                                                                     // 1500\n  // Add all of the Underscore functions to the wrapper object.                                                      // 1501\n  _.mixin(_);                                                                                                        // 1502\n                                                                                                                     // 1503\n  // Add all mutator Array functions to the wrapper.                                                                 // 1504\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {                          // 1505\n    var method = ArrayProto[name];                                                                                   // 1506\n    _.prototype[name] = function() {                                                                                 // 1507\n      var obj = this._wrapped;                                                                                       // 1508\n      method.apply(obj, arguments);                                                                                  // 1509\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];                                // 1510\n      return result(this, obj);                                                                                      // 1511\n    };                                                                                                               // 1512\n  });                                                                                                                // 1513\n                                                                                                                     // 1514\n  // Add all accessor Array functions to the wrapper.                                                                // 1515\n  _.each(['concat', 'join', 'slice'], function(name) {                                                               // 1516\n    var method = ArrayProto[name];                                                                                   // 1517\n    _.prototype[name] = function() {                                                                                 // 1518\n      return result(this, method.apply(this._wrapped, arguments));                                                   // 1519\n    };                                                                                                               // 1520\n  });                                                                                                                // 1521\n                                                                                                                     // 1522\n  // Extracts the result from a wrapped and chained object.                                                          // 1523\n  _.prototype.value = function() {                                                                                   // 1524\n    return this._wrapped;                                                                                            // 1525\n  };                                                                                                                 // 1526\n                                                                                                                     // 1527\n  // Provide unwrapping proxy for some methods used in engine operations                                             // 1528\n  // such as arithmetic and JSON stringification.                                                                    // 1529\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;                                                      // 1530\n                                                                                                                     // 1531\n  _.prototype.toString = function() {                                                                                // 1532\n    return '' + this._wrapped;                                                                                       // 1533\n  };                                                                                                                 // 1534\n                                                                                                                     // 1535\n  // AMD registration happens at the end for compatibility with AMD loaders                                          // 1536\n  // that may not enforce next-turn semantics on modules. Even though general                                        // 1537\n  // practice for AMD registration is to be anonymous, underscore registers                                          // 1538\n  // as a named module because, like jQuery, it is a base library that is                                            // 1539\n  // popular enough to be bundled in a third party lib, but not be part of                                           // 1540\n  // an AMD load request. Those cases could generate an error when an                                                // 1541\n  // anonymous define() is called outside of a loader request.                                                       // 1542\n  if (typeof define === 'function' && define.amd) {                                                                  // 1543\n    define('underscore', [], function() {                                                                            // 1544\n      return _;                                                                                                      // 1545\n    });                                                                                                              // 1546\n  }                                                                                                                  // 1547\n}.call(this));                                                                                                       // 1548\n                                                                                                                     // 1549\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"readable-stream\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/package.json                                                                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"readable-stream\";                                                                                    // 1\nexports.version = \"1.0.34\";                                                                                          // 2\nexports.main = \"readable.js\";                                                                                        // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"readable.js\":[\"stream\",\"./lib/_stream_readable.js\",\"./lib/_stream_writable.js\",\"./lib/_stream_duplex.js\",\"./lib/_stream_transform.js\",\"./lib/_stream_passthrough.js\",\"meteor-node-stubs/deps/stream\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/readable.js                                                                          //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify                 // 1\nexports = module.exports = require('./lib/_stream_readable.js');                                                     // 2\nexports.Stream = Stream;                                                                                             // 3\nexports.Readable = exports;                                                                                          // 4\nexports.Writable = require('./lib/_stream_writable.js');                                                             // 5\nexports.Duplex = require('./lib/_stream_duplex.js');                                                                 // 6\nexports.Transform = require('./lib/_stream_transform.js');                                                           // 7\nexports.PassThrough = require('./lib/_stream_passthrough.js');                                                       // 8\nif (!process.browser && process.env.READABLE_STREAM === 'disable') {                                                 // 9\n  module.exports = require('stream');                                                                                // 10\n}                                                                                                                    // 11\n                                                                                                                     // 12\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"lib\":{\"_stream_readable.js\":[\"isarray\",\"buffer\",\"events\",\"stream\",\"core-util-is\",\"inherits\",\"string_decoder/\",\"meteor-node-stubs/deps/buffer\",\"meteor-node-stubs/deps/events\",\"meteor-node-stubs/deps/stream\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/lib/_stream_readable.js                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\nmodule.exports = Readable;                                                                                           // 22\n                                                                                                                     // 23\n/*<replacement>*/                                                                                                    // 24\nvar isArray = require('isarray');                                                                                    // 25\n/*</replacement>*/                                                                                                   // 26\n                                                                                                                     // 27\n                                                                                                                     // 28\n/*<replacement>*/                                                                                                    // 29\nvar Buffer = require('buffer').Buffer;                                                                               // 30\n/*</replacement>*/                                                                                                   // 31\n                                                                                                                     // 32\nReadable.ReadableState = ReadableState;                                                                              // 33\n                                                                                                                     // 34\nvar EE = require('events').EventEmitter;                                                                             // 35\n                                                                                                                     // 36\n/*<replacement>*/                                                                                                    // 37\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {                                                  // 38\n  return emitter.listeners(type).length;                                                                             // 39\n};                                                                                                                   // 40\n/*</replacement>*/                                                                                                   // 41\n                                                                                                                     // 42\nvar Stream = require('stream');                                                                                      // 43\n                                                                                                                     // 44\n/*<replacement>*/                                                                                                    // 45\nvar util = require('core-util-is');                                                                                  // 46\nutil.inherits = require('inherits');                                                                                 // 47\n/*</replacement>*/                                                                                                   // 48\n                                                                                                                     // 49\nvar StringDecoder;                                                                                                   // 50\n                                                                                                                     // 51\nutil.inherits(Readable, Stream);                                                                                     // 52\n                                                                                                                     // 53\nfunction ReadableState(options, stream) {                                                                            // 54\n  options = options || {};                                                                                           // 55\n                                                                                                                     // 56\n  // the point at which it stops calling _read() to fill the buffer                                                  // 57\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"                                            // 58\n  var hwm = options.highWaterMark;                                                                                   // 59\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;                                                         // 60\n                                                                                                                     // 61\n  // cast to ints.                                                                                                   // 62\n  this.highWaterMark = ~~this.highWaterMark;                                                                         // 63\n                                                                                                                     // 64\n  this.buffer = [];                                                                                                  // 65\n  this.length = 0;                                                                                                   // 66\n  this.pipes = null;                                                                                                 // 67\n  this.pipesCount = 0;                                                                                               // 68\n  this.flowing = false;                                                                                              // 69\n  this.ended = false;                                                                                                // 70\n  this.endEmitted = false;                                                                                           // 71\n  this.reading = false;                                                                                              // 72\n                                                                                                                     // 73\n  // In streams that never have any data, and do push(null) right away,                                              // 74\n  // the consumer can miss the 'end' event if they do some I/O before                                                // 75\n  // consuming the stream.  So, we don't emit('end') until some reading                                              // 76\n  // happens.                                                                                                        // 77\n  this.calledRead = false;                                                                                           // 78\n                                                                                                                     // 79\n  // a flag to be able to tell if the onwrite cb is called immediately,                                              // 80\n  // or on a later tick.  We set this to true at first, becuase any                                                  // 81\n  // actions that shouldn't happen until \"later\" should generally also                                               // 82\n  // not happen before the first write call.                                                                         // 83\n  this.sync = true;                                                                                                  // 84\n                                                                                                                     // 85\n  // whenever we return null, then we set a flag to say                                                              // 86\n  // that we're awaiting a 'readable' event emission.                                                                // 87\n  this.needReadable = false;                                                                                         // 88\n  this.emittedReadable = false;                                                                                      // 89\n  this.readableListening = false;                                                                                    // 90\n                                                                                                                     // 91\n                                                                                                                     // 92\n  // object stream flag. Used to make read(n) ignore n and to                                                        // 93\n  // make all the buffer merging and length checks go away                                                           // 94\n  this.objectMode = !!options.objectMode;                                                                            // 95\n                                                                                                                     // 96\n  // Crypto is kind of old and crusty.  Historically, its default string                                             // 97\n  // encoding is 'binary' so we have to make this configurable.                                                      // 98\n  // Everything else in the universe uses 'utf8', though.                                                            // 99\n  this.defaultEncoding = options.defaultEncoding || 'utf8';                                                          // 100\n                                                                                                                     // 101\n  // when piping, we only care about 'readable' events that happen                                                   // 102\n  // after read()ing all the bytes and not getting any pushback.                                                     // 103\n  this.ranOut = false;                                                                                               // 104\n                                                                                                                     // 105\n  // the number of writers that are awaiting a drain event in .pipe()s                                               // 106\n  this.awaitDrain = 0;                                                                                               // 107\n                                                                                                                     // 108\n  // if true, a maybeReadMore has been scheduled                                                                     // 109\n  this.readingMore = false;                                                                                          // 110\n                                                                                                                     // 111\n  this.decoder = null;                                                                                               // 112\n  this.encoding = null;                                                                                              // 113\n  if (options.encoding) {                                                                                            // 114\n    if (!StringDecoder)                                                                                              // 115\n      StringDecoder = require('string_decoder/').StringDecoder;                                                      // 116\n    this.decoder = new StringDecoder(options.encoding);                                                              // 117\n    this.encoding = options.encoding;                                                                                // 118\n  }                                                                                                                  // 119\n}                                                                                                                    // 120\n                                                                                                                     // 121\nfunction Readable(options) {                                                                                         // 122\n  if (!(this instanceof Readable))                                                                                   // 123\n    return new Readable(options);                                                                                    // 124\n                                                                                                                     // 125\n  this._readableState = new ReadableState(options, this);                                                            // 126\n                                                                                                                     // 127\n  // legacy                                                                                                          // 128\n  this.readable = true;                                                                                              // 129\n                                                                                                                     // 130\n  Stream.call(this);                                                                                                 // 131\n}                                                                                                                    // 132\n                                                                                                                     // 133\n// Manually shove something into the read() buffer.                                                                  // 134\n// This returns true if the highWaterMark has not been hit yet,                                                      // 135\n// similar to how Writable.write() returns true if you should                                                        // 136\n// write() some more.                                                                                                // 137\nReadable.prototype.push = function(chunk, encoding) {                                                                // 138\n  var state = this._readableState;                                                                                   // 139\n                                                                                                                     // 140\n  if (typeof chunk === 'string' && !state.objectMode) {                                                              // 141\n    encoding = encoding || state.defaultEncoding;                                                                    // 142\n    if (encoding !== state.encoding) {                                                                               // 143\n      chunk = new Buffer(chunk, encoding);                                                                           // 144\n      encoding = '';                                                                                                 // 145\n    }                                                                                                                // 146\n  }                                                                                                                  // 147\n                                                                                                                     // 148\n  return readableAddChunk(this, state, chunk, encoding, false);                                                      // 149\n};                                                                                                                   // 150\n                                                                                                                     // 151\n// Unshift should *always* be something directly out of read()                                                       // 152\nReadable.prototype.unshift = function(chunk) {                                                                       // 153\n  var state = this._readableState;                                                                                   // 154\n  return readableAddChunk(this, state, chunk, '', true);                                                             // 155\n};                                                                                                                   // 156\n                                                                                                                     // 157\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {                                              // 158\n  var er = chunkInvalid(state, chunk);                                                                               // 159\n  if (er) {                                                                                                          // 160\n    stream.emit('error', er);                                                                                        // 161\n  } else if (chunk === null || chunk === undefined) {                                                                // 162\n    state.reading = false;                                                                                           // 163\n    if (!state.ended)                                                                                                // 164\n      onEofChunk(stream, state);                                                                                     // 165\n  } else if (state.objectMode || chunk && chunk.length > 0) {                                                        // 166\n    if (state.ended && !addToFront) {                                                                                // 167\n      var e = new Error('stream.push() after EOF');                                                                  // 168\n      stream.emit('error', e);                                                                                       // 169\n    } else if (state.endEmitted && addToFront) {                                                                     // 170\n      var e = new Error('stream.unshift() after end event');                                                         // 171\n      stream.emit('error', e);                                                                                       // 172\n    } else {                                                                                                         // 173\n      if (state.decoder && !addToFront && !encoding)                                                                 // 174\n        chunk = state.decoder.write(chunk);                                                                          // 175\n                                                                                                                     // 176\n      // update the buffer info.                                                                                     // 177\n      state.length += state.objectMode ? 1 : chunk.length;                                                           // 178\n      if (addToFront) {                                                                                              // 179\n        state.buffer.unshift(chunk);                                                                                 // 180\n      } else {                                                                                                       // 181\n        state.reading = false;                                                                                       // 182\n        state.buffer.push(chunk);                                                                                    // 183\n      }                                                                                                              // 184\n                                                                                                                     // 185\n      if (state.needReadable)                                                                                        // 186\n        emitReadable(stream);                                                                                        // 187\n                                                                                                                     // 188\n      maybeReadMore(stream, state);                                                                                  // 189\n    }                                                                                                                // 190\n  } else if (!addToFront) {                                                                                          // 191\n    state.reading = false;                                                                                           // 192\n  }                                                                                                                  // 193\n                                                                                                                     // 194\n  return needMoreData(state);                                                                                        // 195\n}                                                                                                                    // 196\n                                                                                                                     // 197\n                                                                                                                     // 198\n                                                                                                                     // 199\n// if it's past the high water mark, we can push in some more.                                                       // 200\n// Also, if we have no data yet, we can stand some                                                                   // 201\n// more bytes.  This is to work around cases where hwm=0,                                                            // 202\n// such as the repl.  Also, if the push() triggered a                                                                // 203\n// readable event, and the user called read(largeNumber) such that                                                   // 204\n// needReadable was set, then we ought to push more, so that another                                                 // 205\n// 'readable' event will be triggered.                                                                               // 206\nfunction needMoreData(state) {                                                                                       // 207\n  return !state.ended &&                                                                                             // 208\n         (state.needReadable ||                                                                                      // 209\n          state.length < state.highWaterMark ||                                                                      // 210\n          state.length === 0);                                                                                       // 211\n}                                                                                                                    // 212\n                                                                                                                     // 213\n// backwards compatibility.                                                                                          // 214\nReadable.prototype.setEncoding = function(enc) {                                                                     // 215\n  if (!StringDecoder)                                                                                                // 216\n    StringDecoder = require('string_decoder/').StringDecoder;                                                        // 217\n  this._readableState.decoder = new StringDecoder(enc);                                                              // 218\n  this._readableState.encoding = enc;                                                                                // 219\n};                                                                                                                   // 220\n                                                                                                                     // 221\n// Don't raise the hwm > 128MB                                                                                       // 222\nvar MAX_HWM = 0x800000;                                                                                              // 223\nfunction roundUpToNextPowerOf2(n) {                                                                                  // 224\n  if (n >= MAX_HWM) {                                                                                                // 225\n    n = MAX_HWM;                                                                                                     // 226\n  } else {                                                                                                           // 227\n    // Get the next highest power of 2                                                                               // 228\n    n--;                                                                                                             // 229\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;                                                                    // 230\n    n++;                                                                                                             // 231\n  }                                                                                                                  // 232\n  return n;                                                                                                          // 233\n}                                                                                                                    // 234\n                                                                                                                     // 235\nfunction howMuchToRead(n, state) {                                                                                   // 236\n  if (state.length === 0 && state.ended)                                                                             // 237\n    return 0;                                                                                                        // 238\n                                                                                                                     // 239\n  if (state.objectMode)                                                                                              // 240\n    return n === 0 ? 0 : 1;                                                                                          // 241\n                                                                                                                     // 242\n  if (n === null || isNaN(n)) {                                                                                      // 243\n    // only flow one buffer at a time                                                                                // 244\n    if (state.flowing && state.buffer.length)                                                                        // 245\n      return state.buffer[0].length;                                                                                 // 246\n    else                                                                                                             // 247\n      return state.length;                                                                                           // 248\n  }                                                                                                                  // 249\n                                                                                                                     // 250\n  if (n <= 0)                                                                                                        // 251\n    return 0;                                                                                                        // 252\n                                                                                                                     // 253\n  // If we're asking for more than the target buffer level,                                                          // 254\n  // then raise the water mark.  Bump up to the next highest                                                         // 255\n  // power of 2, to prevent increasing it excessively in tiny                                                        // 256\n  // amounts.                                                                                                        // 257\n  if (n > state.highWaterMark)                                                                                       // 258\n    state.highWaterMark = roundUpToNextPowerOf2(n);                                                                  // 259\n                                                                                                                     // 260\n  // don't have that much.  return null, unless we've ended.                                                         // 261\n  if (n > state.length) {                                                                                            // 262\n    if (!state.ended) {                                                                                              // 263\n      state.needReadable = true;                                                                                     // 264\n      return 0;                                                                                                      // 265\n    } else                                                                                                           // 266\n      return state.length;                                                                                           // 267\n  }                                                                                                                  // 268\n                                                                                                                     // 269\n  return n;                                                                                                          // 270\n}                                                                                                                    // 271\n                                                                                                                     // 272\n// you can override either this method, or the async _read(n) below.                                                 // 273\nReadable.prototype.read = function(n) {                                                                              // 274\n  var state = this._readableState;                                                                                   // 275\n  state.calledRead = true;                                                                                           // 276\n  var nOrig = n;                                                                                                     // 277\n  var ret;                                                                                                           // 278\n                                                                                                                     // 279\n  if (typeof n !== 'number' || n > 0)                                                                                // 280\n    state.emittedReadable = false;                                                                                   // 281\n                                                                                                                     // 282\n  // if we're doing read(0) to trigger a readable event, but we                                                      // 283\n  // already have a bunch of data in the buffer, then just trigger                                                   // 284\n  // the 'readable' event and move on.                                                                               // 285\n  if (n === 0 &&                                                                                                     // 286\n      state.needReadable &&                                                                                          // 287\n      (state.length >= state.highWaterMark || state.ended)) {                                                        // 288\n    emitReadable(this);                                                                                              // 289\n    return null;                                                                                                     // 290\n  }                                                                                                                  // 291\n                                                                                                                     // 292\n  n = howMuchToRead(n, state);                                                                                       // 293\n                                                                                                                     // 294\n  // if we've ended, and we're now clear, then finish it up.                                                         // 295\n  if (n === 0 && state.ended) {                                                                                      // 296\n    ret = null;                                                                                                      // 297\n                                                                                                                     // 298\n    // In cases where the decoder did not receive enough data                                                        // 299\n    // to produce a full chunk, then immediately received an                                                         // 300\n    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].                                                  // 301\n    // howMuchToRead will see this and coerce the amount to                                                          // 302\n    // read to zero (because it's looking at the length of the                                                       // 303\n    // first <Buffer > in state.buffer), and we'll end up here.                                                      // 304\n    //                                                                                                               // 305\n    // This can only happen via state.decoder -- no other venue                                                      // 306\n    // exists for pushing a zero-length chunk into state.buffer                                                      // 307\n    // and triggering this behavior. In this case, we return our                                                     // 308\n    // remaining data and end the stream, if appropriate.                                                            // 309\n    if (state.length > 0 && state.decoder) {                                                                         // 310\n      ret = fromList(n, state);                                                                                      // 311\n      state.length -= ret.length;                                                                                    // 312\n    }                                                                                                                // 313\n                                                                                                                     // 314\n    if (state.length === 0)                                                                                          // 315\n      endReadable(this);                                                                                             // 316\n                                                                                                                     // 317\n    return ret;                                                                                                      // 318\n  }                                                                                                                  // 319\n                                                                                                                     // 320\n  // All the actual chunk generation logic needs to be                                                               // 321\n  // *below* the call to _read.  The reason is that in certain                                                       // 322\n  // synthetic stream cases, such as passthrough streams, _read                                                      // 323\n  // may be a completely synchronous operation which may change                                                      // 324\n  // the state of the read buffer, providing enough data when                                                        // 325\n  // before there was *not* enough.                                                                                  // 326\n  //                                                                                                                 // 327\n  // So, the steps are:                                                                                              // 328\n  // 1. Figure out what the state of things will be after we do                                                      // 329\n  // a read from the buffer.                                                                                         // 330\n  //                                                                                                                 // 331\n  // 2. If that resulting state will trigger a _read, then call _read.                                               // 332\n  // Note that this may be asynchronous, or synchronous.  Yes, it is                                                 // 333\n  // deeply ugly to write APIs this way, but that still doesn't mean                                                 // 334\n  // that the Readable class should behave improperly, as streams are                                                // 335\n  // designed to be sync/async agnostic.                                                                             // 336\n  // Take note if the _read call is sync or async (ie, if the read call                                              // 337\n  // has returned yet), so that we know whether or not it's safe to emit                                             // 338\n  // 'readable' etc.                                                                                                 // 339\n  //                                                                                                                 // 340\n  // 3. Actually pull the requested chunks out of the buffer and return.                                             // 341\n                                                                                                                     // 342\n  // if we need a readable event, then we need to do some reading.                                                   // 343\n  var doRead = state.needReadable;                                                                                   // 344\n                                                                                                                     // 345\n  // if we currently have less than the highWaterMark, then also read some                                           // 346\n  if (state.length - n <= state.highWaterMark)                                                                       // 347\n    doRead = true;                                                                                                   // 348\n                                                                                                                     // 349\n  // however, if we've ended, then there's no point, and if we're already                                            // 350\n  // reading, then it's unnecessary.                                                                                 // 351\n  if (state.ended || state.reading)                                                                                  // 352\n    doRead = false;                                                                                                  // 353\n                                                                                                                     // 354\n  if (doRead) {                                                                                                      // 355\n    state.reading = true;                                                                                            // 356\n    state.sync = true;                                                                                               // 357\n    // if the length is currently zero, then we *need* a readable event.                                             // 358\n    if (state.length === 0)                                                                                          // 359\n      state.needReadable = true;                                                                                     // 360\n    // call internal read method                                                                                     // 361\n    this._read(state.highWaterMark);                                                                                 // 362\n    state.sync = false;                                                                                              // 363\n  }                                                                                                                  // 364\n                                                                                                                     // 365\n  // If _read called its callback synchronously, then `reading`                                                      // 366\n  // will be false, and we need to re-evaluate how much data we                                                      // 367\n  // can return to the user.                                                                                         // 368\n  if (doRead && !state.reading)                                                                                      // 369\n    n = howMuchToRead(nOrig, state);                                                                                 // 370\n                                                                                                                     // 371\n  if (n > 0)                                                                                                         // 372\n    ret = fromList(n, state);                                                                                        // 373\n  else                                                                                                               // 374\n    ret = null;                                                                                                      // 375\n                                                                                                                     // 376\n  if (ret === null) {                                                                                                // 377\n    state.needReadable = true;                                                                                       // 378\n    n = 0;                                                                                                           // 379\n  }                                                                                                                  // 380\n                                                                                                                     // 381\n  state.length -= n;                                                                                                 // 382\n                                                                                                                     // 383\n  // If we have nothing in the buffer, then we want to know                                                          // 384\n  // as soon as we *do* get something into the buffer.                                                               // 385\n  if (state.length === 0 && !state.ended)                                                                            // 386\n    state.needReadable = true;                                                                                       // 387\n                                                                                                                     // 388\n  // If we happened to read() exactly the remaining amount in the                                                    // 389\n  // buffer, and the EOF has been seen at this point, then make sure                                                 // 390\n  // that we emit 'end' on the very next tick.                                                                       // 391\n  if (state.ended && !state.endEmitted && state.length === 0)                                                        // 392\n    endReadable(this);                                                                                               // 393\n                                                                                                                     // 394\n  return ret;                                                                                                        // 395\n};                                                                                                                   // 396\n                                                                                                                     // 397\nfunction chunkInvalid(state, chunk) {                                                                                // 398\n  var er = null;                                                                                                     // 399\n  if (!Buffer.isBuffer(chunk) &&                                                                                     // 400\n      'string' !== typeof chunk &&                                                                                   // 401\n      chunk !== null &&                                                                                              // 402\n      chunk !== undefined &&                                                                                         // 403\n      !state.objectMode) {                                                                                           // 404\n    er = new TypeError('Invalid non-string/buffer chunk');                                                           // 405\n  }                                                                                                                  // 406\n  return er;                                                                                                         // 407\n}                                                                                                                    // 408\n                                                                                                                     // 409\n                                                                                                                     // 410\nfunction onEofChunk(stream, state) {                                                                                 // 411\n  if (state.decoder && !state.ended) {                                                                               // 412\n    var chunk = state.decoder.end();                                                                                 // 413\n    if (chunk && chunk.length) {                                                                                     // 414\n      state.buffer.push(chunk);                                                                                      // 415\n      state.length += state.objectMode ? 1 : chunk.length;                                                           // 416\n    }                                                                                                                // 417\n  }                                                                                                                  // 418\n  state.ended = true;                                                                                                // 419\n                                                                                                                     // 420\n  // if we've ended and we have some data left, then emit                                                            // 421\n  // 'readable' now to make sure it gets picked up.                                                                  // 422\n  if (state.length > 0)                                                                                              // 423\n    emitReadable(stream);                                                                                            // 424\n  else                                                                                                               // 425\n    endReadable(stream);                                                                                             // 426\n}                                                                                                                    // 427\n                                                                                                                     // 428\n// Don't emit readable right away in sync mode, because this can trigger                                             // 429\n// another read() call => stack overflow.  This way, it might trigger                                                // 430\n// a nextTick recursion warning, but that's not so bad.                                                              // 431\nfunction emitReadable(stream) {                                                                                      // 432\n  var state = stream._readableState;                                                                                 // 433\n  state.needReadable = false;                                                                                        // 434\n  if (state.emittedReadable)                                                                                         // 435\n    return;                                                                                                          // 436\n                                                                                                                     // 437\n  state.emittedReadable = true;                                                                                      // 438\n  if (state.sync)                                                                                                    // 439\n    process.nextTick(function() {                                                                                    // 440\n      emitReadable_(stream);                                                                                         // 441\n    });                                                                                                              // 442\n  else                                                                                                               // 443\n    emitReadable_(stream);                                                                                           // 444\n}                                                                                                                    // 445\n                                                                                                                     // 446\nfunction emitReadable_(stream) {                                                                                     // 447\n  stream.emit('readable');                                                                                           // 448\n}                                                                                                                    // 449\n                                                                                                                     // 450\n                                                                                                                     // 451\n// at this point, the user has presumably seen the 'readable' event,                                                 // 452\n// and called read() to consume some data.  that may have triggered                                                  // 453\n// in turn another _read(n) call, in which case reading = true if                                                    // 454\n// it's in progress.                                                                                                 // 455\n// However, if we're not ended, or reading, and the length < hwm,                                                    // 456\n// then go ahead and try to read some more preemptively.                                                             // 457\nfunction maybeReadMore(stream, state) {                                                                              // 458\n  if (!state.readingMore) {                                                                                          // 459\n    state.readingMore = true;                                                                                        // 460\n    process.nextTick(function() {                                                                                    // 461\n      maybeReadMore_(stream, state);                                                                                 // 462\n    });                                                                                                              // 463\n  }                                                                                                                  // 464\n}                                                                                                                    // 465\n                                                                                                                     // 466\nfunction maybeReadMore_(stream, state) {                                                                             // 467\n  var len = state.length;                                                                                            // 468\n  while (!state.reading && !state.flowing && !state.ended &&                                                         // 469\n         state.length < state.highWaterMark) {                                                                       // 470\n    stream.read(0);                                                                                                  // 471\n    if (len === state.length)                                                                                        // 472\n      // didn't get any data, stop spinning.                                                                         // 473\n      break;                                                                                                         // 474\n    else                                                                                                             // 475\n      len = state.length;                                                                                            // 476\n  }                                                                                                                  // 477\n  state.readingMore = false;                                                                                         // 478\n}                                                                                                                    // 479\n                                                                                                                     // 480\n// abstract method.  to be overridden in specific implementation classes.                                            // 481\n// call cb(er, data) where data is <= n in length.                                                                   // 482\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat                                                // 483\n// arbitrary, and perhaps not very meaningful.                                                                       // 484\nReadable.prototype._read = function(n) {                                                                             // 485\n  this.emit('error', new Error('not implemented'));                                                                  // 486\n};                                                                                                                   // 487\n                                                                                                                     // 488\nReadable.prototype.pipe = function(dest, pipeOpts) {                                                                 // 489\n  var src = this;                                                                                                    // 490\n  var state = this._readableState;                                                                                   // 491\n                                                                                                                     // 492\n  switch (state.pipesCount) {                                                                                        // 493\n    case 0:                                                                                                          // 494\n      state.pipes = dest;                                                                                            // 495\n      break;                                                                                                         // 496\n    case 1:                                                                                                          // 497\n      state.pipes = [state.pipes, dest];                                                                             // 498\n      break;                                                                                                         // 499\n    default:                                                                                                         // 500\n      state.pipes.push(dest);                                                                                        // 501\n      break;                                                                                                         // 502\n  }                                                                                                                  // 503\n  state.pipesCount += 1;                                                                                             // 504\n                                                                                                                     // 505\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&                                                               // 506\n              dest !== process.stdout &&                                                                             // 507\n              dest !== process.stderr;                                                                               // 508\n                                                                                                                     // 509\n  var endFn = doEnd ? onend : cleanup;                                                                               // 510\n  if (state.endEmitted)                                                                                              // 511\n    process.nextTick(endFn);                                                                                         // 512\n  else                                                                                                               // 513\n    src.once('end', endFn);                                                                                          // 514\n                                                                                                                     // 515\n  dest.on('unpipe', onunpipe);                                                                                       // 516\n  function onunpipe(readable) {                                                                                      // 517\n    if (readable !== src) return;                                                                                    // 518\n    cleanup();                                                                                                       // 519\n  }                                                                                                                  // 520\n                                                                                                                     // 521\n  function onend() {                                                                                                 // 522\n    dest.end();                                                                                                      // 523\n  }                                                                                                                  // 524\n                                                                                                                     // 525\n  // when the dest drains, it reduces the awaitDrain counter                                                         // 526\n  // on the source.  This would be more elegant with a .once()                                                       // 527\n  // handler in flow(), but adding and removing repeatedly is                                                        // 528\n  // too slow.                                                                                                       // 529\n  var ondrain = pipeOnDrain(src);                                                                                    // 530\n  dest.on('drain', ondrain);                                                                                         // 531\n                                                                                                                     // 532\n  function cleanup() {                                                                                               // 533\n    // cleanup event handlers once the pipe is broken                                                                // 534\n    dest.removeListener('close', onclose);                                                                           // 535\n    dest.removeListener('finish', onfinish);                                                                         // 536\n    dest.removeListener('drain', ondrain);                                                                           // 537\n    dest.removeListener('error', onerror);                                                                           // 538\n    dest.removeListener('unpipe', onunpipe);                                                                         // 539\n    src.removeListener('end', onend);                                                                                // 540\n    src.removeListener('end', cleanup);                                                                              // 541\n                                                                                                                     // 542\n    // if the reader is waiting for a drain event from this                                                          // 543\n    // specific writer, then it would cause it to never start                                                        // 544\n    // flowing again.                                                                                                // 545\n    // So, if this is awaiting a drain, then we just call it now.                                                    // 546\n    // If we don't know, then assume that we are waiting for one.                                                    // 547\n    if (!dest._writableState || dest._writableState.needDrain)                                                       // 548\n      ondrain();                                                                                                     // 549\n  }                                                                                                                  // 550\n                                                                                                                     // 551\n  // if the dest has an error, then stop piping into it.                                                             // 552\n  // however, don't suppress the throwing behavior for this.                                                         // 553\n  function onerror(er) {                                                                                             // 554\n    unpipe();                                                                                                        // 555\n    dest.removeListener('error', onerror);                                                                           // 556\n    if (EE.listenerCount(dest, 'error') === 0)                                                                       // 557\n      dest.emit('error', er);                                                                                        // 558\n  }                                                                                                                  // 559\n  // This is a brutally ugly hack to make sure that our error handler                                                // 560\n  // is attached before any userland ones.  NEVER DO THIS.                                                           // 561\n  if (!dest._events || !dest._events.error)                                                                          // 562\n    dest.on('error', onerror);                                                                                       // 563\n  else if (isArray(dest._events.error))                                                                              // 564\n    dest._events.error.unshift(onerror);                                                                             // 565\n  else                                                                                                               // 566\n    dest._events.error = [onerror, dest._events.error];                                                              // 567\n                                                                                                                     // 568\n                                                                                                                     // 569\n                                                                                                                     // 570\n  // Both close and finish should trigger unpipe, but only once.                                                     // 571\n  function onclose() {                                                                                               // 572\n    dest.removeListener('finish', onfinish);                                                                         // 573\n    unpipe();                                                                                                        // 574\n  }                                                                                                                  // 575\n  dest.once('close', onclose);                                                                                       // 576\n  function onfinish() {                                                                                              // 577\n    dest.removeListener('close', onclose);                                                                           // 578\n    unpipe();                                                                                                        // 579\n  }                                                                                                                  // 580\n  dest.once('finish', onfinish);                                                                                     // 581\n                                                                                                                     // 582\n  function unpipe() {                                                                                                // 583\n    src.unpipe(dest);                                                                                                // 584\n  }                                                                                                                  // 585\n                                                                                                                     // 586\n  // tell the dest that it's being piped to                                                                          // 587\n  dest.emit('pipe', src);                                                                                            // 588\n                                                                                                                     // 589\n  // start the flow if it hasn't been started already.                                                               // 590\n  if (!state.flowing) {                                                                                              // 591\n    // the handler that waits for readable events after all                                                          // 592\n    // the data gets sucked out in flow.                                                                             // 593\n    // This would be easier to follow with a .once() handler                                                         // 594\n    // in flow(), but that is too slow.                                                                              // 595\n    this.on('readable', pipeOnReadable);                                                                             // 596\n                                                                                                                     // 597\n    state.flowing = true;                                                                                            // 598\n    process.nextTick(function() {                                                                                    // 599\n      flow(src);                                                                                                     // 600\n    });                                                                                                              // 601\n  }                                                                                                                  // 602\n                                                                                                                     // 603\n  return dest;                                                                                                       // 604\n};                                                                                                                   // 605\n                                                                                                                     // 606\nfunction pipeOnDrain(src) {                                                                                          // 607\n  return function() {                                                                                                // 608\n    var dest = this;                                                                                                 // 609\n    var state = src._readableState;                                                                                  // 610\n    state.awaitDrain--;                                                                                              // 611\n    if (state.awaitDrain === 0)                                                                                      // 612\n      flow(src);                                                                                                     // 613\n  };                                                                                                                 // 614\n}                                                                                                                    // 615\n                                                                                                                     // 616\nfunction flow(src) {                                                                                                 // 617\n  var state = src._readableState;                                                                                    // 618\n  var chunk;                                                                                                         // 619\n  state.awaitDrain = 0;                                                                                              // 620\n                                                                                                                     // 621\n  function write(dest, i, list) {                                                                                    // 622\n    var written = dest.write(chunk);                                                                                 // 623\n    if (false === written) {                                                                                         // 624\n      state.awaitDrain++;                                                                                            // 625\n    }                                                                                                                // 626\n  }                                                                                                                  // 627\n                                                                                                                     // 628\n  while (state.pipesCount && null !== (chunk = src.read())) {                                                        // 629\n                                                                                                                     // 630\n    if (state.pipesCount === 1)                                                                                      // 631\n      write(state.pipes, 0, null);                                                                                   // 632\n    else                                                                                                             // 633\n      forEach(state.pipes, write);                                                                                   // 634\n                                                                                                                     // 635\n    src.emit('data', chunk);                                                                                         // 636\n                                                                                                                     // 637\n    // if anyone needs a drain, then we have to wait for that.                                                       // 638\n    if (state.awaitDrain > 0)                                                                                        // 639\n      return;                                                                                                        // 640\n  }                                                                                                                  // 641\n                                                                                                                     // 642\n  // if every destination was unpiped, either before entering this                                                   // 643\n  // function, or in the while loop, then stop flowing.                                                              // 644\n  //                                                                                                                 // 645\n  // NB: This is a pretty rare edge case.                                                                            // 646\n  if (state.pipesCount === 0) {                                                                                      // 647\n    state.flowing = false;                                                                                           // 648\n                                                                                                                     // 649\n    // if there were data event listeners added, then switch to old mode.                                            // 650\n    if (EE.listenerCount(src, 'data') > 0)                                                                           // 651\n      emitDataEvents(src);                                                                                           // 652\n    return;                                                                                                          // 653\n  }                                                                                                                  // 654\n                                                                                                                     // 655\n  // at this point, no one needed a drain, so we just ran out of data                                                // 656\n  // on the next readable event, start it over again.                                                                // 657\n  state.ranOut = true;                                                                                               // 658\n}                                                                                                                    // 659\n                                                                                                                     // 660\nfunction pipeOnReadable() {                                                                                          // 661\n  if (this._readableState.ranOut) {                                                                                  // 662\n    this._readableState.ranOut = false;                                                                              // 663\n    flow(this);                                                                                                      // 664\n  }                                                                                                                  // 665\n}                                                                                                                    // 666\n                                                                                                                     // 667\n                                                                                                                     // 668\nReadable.prototype.unpipe = function(dest) {                                                                         // 669\n  var state = this._readableState;                                                                                   // 670\n                                                                                                                     // 671\n  // if we're not piping anywhere, then do nothing.                                                                  // 672\n  if (state.pipesCount === 0)                                                                                        // 673\n    return this;                                                                                                     // 674\n                                                                                                                     // 675\n  // just one destination.  most common case.                                                                        // 676\n  if (state.pipesCount === 1) {                                                                                      // 677\n    // passed in one, but it's not the right one.                                                                    // 678\n    if (dest && dest !== state.pipes)                                                                                // 679\n      return this;                                                                                                   // 680\n                                                                                                                     // 681\n    if (!dest)                                                                                                       // 682\n      dest = state.pipes;                                                                                            // 683\n                                                                                                                     // 684\n    // got a match.                                                                                                  // 685\n    state.pipes = null;                                                                                              // 686\n    state.pipesCount = 0;                                                                                            // 687\n    this.removeListener('readable', pipeOnReadable);                                                                 // 688\n    state.flowing = false;                                                                                           // 689\n    if (dest)                                                                                                        // 690\n      dest.emit('unpipe', this);                                                                                     // 691\n    return this;                                                                                                     // 692\n  }                                                                                                                  // 693\n                                                                                                                     // 694\n  // slow case. multiple pipe destinations.                                                                          // 695\n                                                                                                                     // 696\n  if (!dest) {                                                                                                       // 697\n    // remove all.                                                                                                   // 698\n    var dests = state.pipes;                                                                                         // 699\n    var len = state.pipesCount;                                                                                      // 700\n    state.pipes = null;                                                                                              // 701\n    state.pipesCount = 0;                                                                                            // 702\n    this.removeListener('readable', pipeOnReadable);                                                                 // 703\n    state.flowing = false;                                                                                           // 704\n                                                                                                                     // 705\n    for (var i = 0; i < len; i++)                                                                                    // 706\n      dests[i].emit('unpipe', this);                                                                                 // 707\n    return this;                                                                                                     // 708\n  }                                                                                                                  // 709\n                                                                                                                     // 710\n  // try to find the right one.                                                                                      // 711\n  var i = indexOf(state.pipes, dest);                                                                                // 712\n  if (i === -1)                                                                                                      // 713\n    return this;                                                                                                     // 714\n                                                                                                                     // 715\n  state.pipes.splice(i, 1);                                                                                          // 716\n  state.pipesCount -= 1;                                                                                             // 717\n  if (state.pipesCount === 1)                                                                                        // 718\n    state.pipes = state.pipes[0];                                                                                    // 719\n                                                                                                                     // 720\n  dest.emit('unpipe', this);                                                                                         // 721\n                                                                                                                     // 722\n  return this;                                                                                                       // 723\n};                                                                                                                   // 724\n                                                                                                                     // 725\n// set up data events if they are asked for                                                                          // 726\n// Ensure readable listeners eventually get something                                                                // 727\nReadable.prototype.on = function(ev, fn) {                                                                           // 728\n  var res = Stream.prototype.on.call(this, ev, fn);                                                                  // 729\n                                                                                                                     // 730\n  if (ev === 'data' && !this._readableState.flowing)                                                                 // 731\n    emitDataEvents(this);                                                                                            // 732\n                                                                                                                     // 733\n  if (ev === 'readable' && this.readable) {                                                                          // 734\n    var state = this._readableState;                                                                                 // 735\n    if (!state.readableListening) {                                                                                  // 736\n      state.readableListening = true;                                                                                // 737\n      state.emittedReadable = false;                                                                                 // 738\n      state.needReadable = true;                                                                                     // 739\n      if (!state.reading) {                                                                                          // 740\n        this.read(0);                                                                                                // 741\n      } else if (state.length) {                                                                                     // 742\n        emitReadable(this, state);                                                                                   // 743\n      }                                                                                                              // 744\n    }                                                                                                                // 745\n  }                                                                                                                  // 746\n                                                                                                                     // 747\n  return res;                                                                                                        // 748\n};                                                                                                                   // 749\nReadable.prototype.addListener = Readable.prototype.on;                                                              // 750\n                                                                                                                     // 751\n// pause() and resume() are remnants of the legacy readable stream API                                               // 752\n// If the user uses them, then switch into old mode.                                                                 // 753\nReadable.prototype.resume = function() {                                                                             // 754\n  emitDataEvents(this);                                                                                              // 755\n  this.read(0);                                                                                                      // 756\n  this.emit('resume');                                                                                               // 757\n};                                                                                                                   // 758\n                                                                                                                     // 759\nReadable.prototype.pause = function() {                                                                              // 760\n  emitDataEvents(this, true);                                                                                        // 761\n  this.emit('pause');                                                                                                // 762\n};                                                                                                                   // 763\n                                                                                                                     // 764\nfunction emitDataEvents(stream, startPaused) {                                                                       // 765\n  var state = stream._readableState;                                                                                 // 766\n                                                                                                                     // 767\n  if (state.flowing) {                                                                                               // 768\n    // https://github.com/isaacs/readable-stream/issues/16                                                           // 769\n    throw new Error('Cannot switch to old mode now.');                                                               // 770\n  }                                                                                                                  // 771\n                                                                                                                     // 772\n  var paused = startPaused || false;                                                                                 // 773\n  var readable = false;                                                                                              // 774\n                                                                                                                     // 775\n  // convert to an old-style stream.                                                                                 // 776\n  stream.readable = true;                                                                                            // 777\n  stream.pipe = Stream.prototype.pipe;                                                                               // 778\n  stream.on = stream.addListener = Stream.prototype.on;                                                              // 779\n                                                                                                                     // 780\n  stream.on('readable', function() {                                                                                 // 781\n    readable = true;                                                                                                 // 782\n                                                                                                                     // 783\n    var c;                                                                                                           // 784\n    while (!paused && (null !== (c = stream.read())))                                                                // 785\n      stream.emit('data', c);                                                                                        // 786\n                                                                                                                     // 787\n    if (c === null) {                                                                                                // 788\n      readable = false;                                                                                              // 789\n      stream._readableState.needReadable = true;                                                                     // 790\n    }                                                                                                                // 791\n  });                                                                                                                // 792\n                                                                                                                     // 793\n  stream.pause = function() {                                                                                        // 794\n    paused = true;                                                                                                   // 795\n    this.emit('pause');                                                                                              // 796\n  };                                                                                                                 // 797\n                                                                                                                     // 798\n  stream.resume = function() {                                                                                       // 799\n    paused = false;                                                                                                  // 800\n    if (readable)                                                                                                    // 801\n      process.nextTick(function() {                                                                                  // 802\n        stream.emit('readable');                                                                                     // 803\n      });                                                                                                            // 804\n    else                                                                                                             // 805\n      this.read(0);                                                                                                  // 806\n    this.emit('resume');                                                                                             // 807\n  };                                                                                                                 // 808\n                                                                                                                     // 809\n  // now make it start, just in case it hadn't already.                                                              // 810\n  stream.emit('readable');                                                                                           // 811\n}                                                                                                                    // 812\n                                                                                                                     // 813\n// wrap an old-style stream as the async data source.                                                                // 814\n// This is *not* part of the readable stream interface.                                                              // 815\n// It is an ugly unfortunate mess of history.                                                                        // 816\nReadable.prototype.wrap = function(stream) {                                                                         // 817\n  var state = this._readableState;                                                                                   // 818\n  var paused = false;                                                                                                // 819\n                                                                                                                     // 820\n  var self = this;                                                                                                   // 821\n  stream.on('end', function() {                                                                                      // 822\n    if (state.decoder && !state.ended) {                                                                             // 823\n      var chunk = state.decoder.end();                                                                               // 824\n      if (chunk && chunk.length)                                                                                     // 825\n        self.push(chunk);                                                                                            // 826\n    }                                                                                                                // 827\n                                                                                                                     // 828\n    self.push(null);                                                                                                 // 829\n  });                                                                                                                // 830\n                                                                                                                     // 831\n  stream.on('data', function(chunk) {                                                                                // 832\n    if (state.decoder)                                                                                               // 833\n      chunk = state.decoder.write(chunk);                                                                            // 834\n                                                                                                                     // 835\n    // don't skip over falsy values in objectMode                                                                    // 836\n    //if (state.objectMode && util.isNullOrUndefined(chunk))                                                         // 837\n    if (state.objectMode && (chunk === null || chunk === undefined))                                                 // 838\n      return;                                                                                                        // 839\n    else if (!state.objectMode && (!chunk || !chunk.length))                                                         // 840\n      return;                                                                                                        // 841\n                                                                                                                     // 842\n    var ret = self.push(chunk);                                                                                      // 843\n    if (!ret) {                                                                                                      // 844\n      paused = true;                                                                                                 // 845\n      stream.pause();                                                                                                // 846\n    }                                                                                                                // 847\n  });                                                                                                                // 848\n                                                                                                                     // 849\n  // proxy all the other methods.                                                                                    // 850\n  // important when wrapping filters and duplexes.                                                                   // 851\n  for (var i in stream) {                                                                                            // 852\n    if (typeof stream[i] === 'function' &&                                                                           // 853\n        typeof this[i] === 'undefined') {                                                                            // 854\n      this[i] = function(method) { return function() {                                                               // 855\n        return stream[method].apply(stream, arguments);                                                              // 856\n      }}(i);                                                                                                         // 857\n    }                                                                                                                // 858\n  }                                                                                                                  // 859\n                                                                                                                     // 860\n  // proxy certain important events.                                                                                 // 861\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];                                                     // 862\n  forEach(events, function(ev) {                                                                                     // 863\n    stream.on(ev, self.emit.bind(self, ev));                                                                         // 864\n  });                                                                                                                // 865\n                                                                                                                     // 866\n  // when we try to consume some more bytes, simply unpause the                                                      // 867\n  // underlying stream.                                                                                              // 868\n  self._read = function(n) {                                                                                         // 869\n    if (paused) {                                                                                                    // 870\n      paused = false;                                                                                                // 871\n      stream.resume();                                                                                               // 872\n    }                                                                                                                // 873\n  };                                                                                                                 // 874\n                                                                                                                     // 875\n  return self;                                                                                                       // 876\n};                                                                                                                   // 877\n                                                                                                                     // 878\n                                                                                                                     // 879\n                                                                                                                     // 880\n// exposed for testing purposes only.                                                                                // 881\nReadable._fromList = fromList;                                                                                       // 882\n                                                                                                                     // 883\n// Pluck off n bytes from an array of buffers.                                                                       // 884\n// Length is the combined lengths of all the buffers in the list.                                                    // 885\nfunction fromList(n, state) {                                                                                        // 886\n  var list = state.buffer;                                                                                           // 887\n  var length = state.length;                                                                                         // 888\n  var stringMode = !!state.decoder;                                                                                  // 889\n  var objectMode = !!state.objectMode;                                                                               // 890\n  var ret;                                                                                                           // 891\n                                                                                                                     // 892\n  // nothing in the list, definitely empty.                                                                          // 893\n  if (list.length === 0)                                                                                             // 894\n    return null;                                                                                                     // 895\n                                                                                                                     // 896\n  if (length === 0)                                                                                                  // 897\n    ret = null;                                                                                                      // 898\n  else if (objectMode)                                                                                               // 899\n    ret = list.shift();                                                                                              // 900\n  else if (!n || n >= length) {                                                                                      // 901\n    // read it all, truncate the array.                                                                              // 902\n    if (stringMode)                                                                                                  // 903\n      ret = list.join('');                                                                                           // 904\n    else                                                                                                             // 905\n      ret = Buffer.concat(list, length);                                                                             // 906\n    list.length = 0;                                                                                                 // 907\n  } else {                                                                                                           // 908\n    // read just some of it.                                                                                         // 909\n    if (n < list[0].length) {                                                                                        // 910\n      // just take a part of the first list item.                                                                    // 911\n      // slice is the same for buffers and strings.                                                                  // 912\n      var buf = list[0];                                                                                             // 913\n      ret = buf.slice(0, n);                                                                                         // 914\n      list[0] = buf.slice(n);                                                                                        // 915\n    } else if (n === list[0].length) {                                                                               // 916\n      // first list is a perfect match                                                                               // 917\n      ret = list.shift();                                                                                            // 918\n    } else {                                                                                                         // 919\n      // complex case.                                                                                               // 920\n      // we have enough to cover it, but it spans past the first buffer.                                             // 921\n      if (stringMode)                                                                                                // 922\n        ret = '';                                                                                                    // 923\n      else                                                                                                           // 924\n        ret = new Buffer(n);                                                                                         // 925\n                                                                                                                     // 926\n      var c = 0;                                                                                                     // 927\n      for (var i = 0, l = list.length; i < l && c < n; i++) {                                                        // 928\n        var buf = list[0];                                                                                           // 929\n        var cpy = Math.min(n - c, buf.length);                                                                       // 930\n                                                                                                                     // 931\n        if (stringMode)                                                                                              // 932\n          ret += buf.slice(0, cpy);                                                                                  // 933\n        else                                                                                                         // 934\n          buf.copy(ret, c, 0, cpy);                                                                                  // 935\n                                                                                                                     // 936\n        if (cpy < buf.length)                                                                                        // 937\n          list[0] = buf.slice(cpy);                                                                                  // 938\n        else                                                                                                         // 939\n          list.shift();                                                                                              // 940\n                                                                                                                     // 941\n        c += cpy;                                                                                                    // 942\n      }                                                                                                              // 943\n    }                                                                                                                // 944\n  }                                                                                                                  // 945\n                                                                                                                     // 946\n  return ret;                                                                                                        // 947\n}                                                                                                                    // 948\n                                                                                                                     // 949\nfunction endReadable(stream) {                                                                                       // 950\n  var state = stream._readableState;                                                                                 // 951\n                                                                                                                     // 952\n  // If we get here before consuming all the bytes, then that is a                                                   // 953\n  // bug in node.  Should never happen.                                                                              // 954\n  if (state.length > 0)                                                                                              // 955\n    throw new Error('endReadable called on non-empty stream');                                                       // 956\n                                                                                                                     // 957\n  if (!state.endEmitted && state.calledRead) {                                                                       // 958\n    state.ended = true;                                                                                              // 959\n    process.nextTick(function() {                                                                                    // 960\n      // Check that we didn't get one last unshift.                                                                  // 961\n      if (!state.endEmitted && state.length === 0) {                                                                 // 962\n        state.endEmitted = true;                                                                                     // 963\n        stream.readable = false;                                                                                     // 964\n        stream.emit('end');                                                                                          // 965\n      }                                                                                                              // 966\n    });                                                                                                              // 967\n  }                                                                                                                  // 968\n}                                                                                                                    // 969\n                                                                                                                     // 970\nfunction forEach (xs, f) {                                                                                           // 971\n  for (var i = 0, l = xs.length; i < l; i++) {                                                                       // 972\n    f(xs[i], i);                                                                                                     // 973\n  }                                                                                                                  // 974\n}                                                                                                                    // 975\n                                                                                                                     // 976\nfunction indexOf (xs, x) {                                                                                           // 977\n  for (var i = 0, l = xs.length; i < l; i++) {                                                                       // 978\n    if (xs[i] === x) return i;                                                                                       // 979\n  }                                                                                                                  // 980\n  return -1;                                                                                                         // 981\n}                                                                                                                    // 982\n                                                                                                                     // 983\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_writable.js\":[\"buffer\",\"core-util-is\",\"inherits\",\"stream\",\"./_stream_duplex\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/lib/_stream_writable.js                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n// A bit simpler than readable streams.                                                                              // 22\n// Implement an async ._write(chunk, cb), and it'll handle all                                                       // 23\n// the drain event emission and buffering.                                                                           // 24\n                                                                                                                     // 25\nmodule.exports = Writable;                                                                                           // 26\n                                                                                                                     // 27\n/*<replacement>*/                                                                                                    // 28\nvar Buffer = require('buffer').Buffer;                                                                               // 29\n/*</replacement>*/                                                                                                   // 30\n                                                                                                                     // 31\nWritable.WritableState = WritableState;                                                                              // 32\n                                                                                                                     // 33\n                                                                                                                     // 34\n/*<replacement>*/                                                                                                    // 35\nvar util = require('core-util-is');                                                                                  // 36\nutil.inherits = require('inherits');                                                                                 // 37\n/*</replacement>*/                                                                                                   // 38\n                                                                                                                     // 39\nvar Stream = require('stream');                                                                                      // 40\n                                                                                                                     // 41\nutil.inherits(Writable, Stream);                                                                                     // 42\n                                                                                                                     // 43\nfunction WriteReq(chunk, encoding, cb) {                                                                             // 44\n  this.chunk = chunk;                                                                                                // 45\n  this.encoding = encoding;                                                                                          // 46\n  this.callback = cb;                                                                                                // 47\n}                                                                                                                    // 48\n                                                                                                                     // 49\nfunction WritableState(options, stream) {                                                                            // 50\n  options = options || {};                                                                                           // 51\n                                                                                                                     // 52\n  // the point at which write() starts returning false                                                               // 53\n  // Note: 0 is a valid value, means that we always return false if                                                  // 54\n  // the entire buffer is not flushed immediately on write()                                                         // 55\n  var hwm = options.highWaterMark;                                                                                   // 56\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;                                                         // 57\n                                                                                                                     // 58\n  // object stream flag to indicate whether or not this stream                                                       // 59\n  // contains buffers or objects.                                                                                    // 60\n  this.objectMode = !!options.objectMode;                                                                            // 61\n                                                                                                                     // 62\n  // cast to ints.                                                                                                   // 63\n  this.highWaterMark = ~~this.highWaterMark;                                                                         // 64\n                                                                                                                     // 65\n  this.needDrain = false;                                                                                            // 66\n  // at the start of calling end()                                                                                   // 67\n  this.ending = false;                                                                                               // 68\n  // when end() has been called, and returned                                                                        // 69\n  this.ended = false;                                                                                                // 70\n  // when 'finish' is emitted                                                                                        // 71\n  this.finished = false;                                                                                             // 72\n                                                                                                                     // 73\n  // should we decode strings into buffers before passing to _write?                                                 // 74\n  // this is here so that some node-core streams can optimize string                                                 // 75\n  // handling at a lower level.                                                                                      // 76\n  var noDecode = options.decodeStrings === false;                                                                    // 77\n  this.decodeStrings = !noDecode;                                                                                    // 78\n                                                                                                                     // 79\n  // Crypto is kind of old and crusty.  Historically, its default string                                             // 80\n  // encoding is 'binary' so we have to make this configurable.                                                      // 81\n  // Everything else in the universe uses 'utf8', though.                                                            // 82\n  this.defaultEncoding = options.defaultEncoding || 'utf8';                                                          // 83\n                                                                                                                     // 84\n  // not an actual buffer we keep track of, but a measurement                                                        // 85\n  // of how much we're waiting to get pushed to some underlying                                                      // 86\n  // socket or file.                                                                                                 // 87\n  this.length = 0;                                                                                                   // 88\n                                                                                                                     // 89\n  // a flag to see when we're in the middle of a write.                                                              // 90\n  this.writing = false;                                                                                              // 91\n                                                                                                                     // 92\n  // a flag to be able to tell if the onwrite cb is called immediately,                                              // 93\n  // or on a later tick.  We set this to true at first, becuase any                                                  // 94\n  // actions that shouldn't happen until \"later\" should generally also                                               // 95\n  // not happen before the first write call.                                                                         // 96\n  this.sync = true;                                                                                                  // 97\n                                                                                                                     // 98\n  // a flag to know if we're processing previously buffered items, which                                             // 99\n  // may call the _write() callback in the same tick, so that we don't                                               // 100\n  // end up in an overlapped onwrite situation.                                                                      // 101\n  this.bufferProcessing = false;                                                                                     // 102\n                                                                                                                     // 103\n  // the callback that's passed to _write(chunk,cb)                                                                  // 104\n  this.onwrite = function(er) {                                                                                      // 105\n    onwrite(stream, er);                                                                                             // 106\n  };                                                                                                                 // 107\n                                                                                                                     // 108\n  // the callback that the user supplies to write(chunk,encoding,cb)                                                 // 109\n  this.writecb = null;                                                                                               // 110\n                                                                                                                     // 111\n  // the amount that is being written when _write is called.                                                         // 112\n  this.writelen = 0;                                                                                                 // 113\n                                                                                                                     // 114\n  this.buffer = [];                                                                                                  // 115\n                                                                                                                     // 116\n  // True if the error was already emitted and should not be thrown again                                            // 117\n  this.errorEmitted = false;                                                                                         // 118\n}                                                                                                                    // 119\n                                                                                                                     // 120\nfunction Writable(options) {                                                                                         // 121\n  var Duplex = require('./_stream_duplex');                                                                          // 122\n                                                                                                                     // 123\n  // Writable ctor is applied to Duplexes, though they're not                                                        // 124\n  // instanceof Writable, they're instanceof Readable.                                                               // 125\n  if (!(this instanceof Writable) && !(this instanceof Duplex))                                                      // 126\n    return new Writable(options);                                                                                    // 127\n                                                                                                                     // 128\n  this._writableState = new WritableState(options, this);                                                            // 129\n                                                                                                                     // 130\n  // legacy.                                                                                                         // 131\n  this.writable = true;                                                                                              // 132\n                                                                                                                     // 133\n  Stream.call(this);                                                                                                 // 134\n}                                                                                                                    // 135\n                                                                                                                     // 136\n// Otherwise people can pipe Writable streams, which is just wrong.                                                  // 137\nWritable.prototype.pipe = function() {                                                                               // 138\n  this.emit('error', new Error('Cannot pipe. Not readable.'));                                                       // 139\n};                                                                                                                   // 140\n                                                                                                                     // 141\n                                                                                                                     // 142\nfunction writeAfterEnd(stream, state, cb) {                                                                          // 143\n  var er = new Error('write after end');                                                                             // 144\n  // TODO: defer error events consistently everywhere, not just the cb                                               // 145\n  stream.emit('error', er);                                                                                          // 146\n  process.nextTick(function() {                                                                                      // 147\n    cb(er);                                                                                                          // 148\n  });                                                                                                                // 149\n}                                                                                                                    // 150\n                                                                                                                     // 151\n// If we get something that is not a buffer, string, null, or undefined,                                             // 152\n// and we're not in objectMode, then that's an error.                                                                // 153\n// Otherwise stream chunks are all considered to be of length=1, and the                                             // 154\n// watermarks determine how many objects to keep in the buffer, rather than                                          // 155\n// how many bytes or characters.                                                                                     // 156\nfunction validChunk(stream, state, chunk, cb) {                                                                      // 157\n  var valid = true;                                                                                                  // 158\n  if (!Buffer.isBuffer(chunk) &&                                                                                     // 159\n      'string' !== typeof chunk &&                                                                                   // 160\n      chunk !== null &&                                                                                              // 161\n      chunk !== undefined &&                                                                                         // 162\n      !state.objectMode) {                                                                                           // 163\n    var er = new TypeError('Invalid non-string/buffer chunk');                                                       // 164\n    stream.emit('error', er);                                                                                        // 165\n    process.nextTick(function() {                                                                                    // 166\n      cb(er);                                                                                                        // 167\n    });                                                                                                              // 168\n    valid = false;                                                                                                   // 169\n  }                                                                                                                  // 170\n  return valid;                                                                                                      // 171\n}                                                                                                                    // 172\n                                                                                                                     // 173\nWritable.prototype.write = function(chunk, encoding, cb) {                                                           // 174\n  var state = this._writableState;                                                                                   // 175\n  var ret = false;                                                                                                   // 176\n                                                                                                                     // 177\n  if (typeof encoding === 'function') {                                                                              // 178\n    cb = encoding;                                                                                                   // 179\n    encoding = null;                                                                                                 // 180\n  }                                                                                                                  // 181\n                                                                                                                     // 182\n  if (Buffer.isBuffer(chunk))                                                                                        // 183\n    encoding = 'buffer';                                                                                             // 184\n  else if (!encoding)                                                                                                // 185\n    encoding = state.defaultEncoding;                                                                                // 186\n                                                                                                                     // 187\n  if (typeof cb !== 'function')                                                                                      // 188\n    cb = function() {};                                                                                              // 189\n                                                                                                                     // 190\n  if (state.ended)                                                                                                   // 191\n    writeAfterEnd(this, state, cb);                                                                                  // 192\n  else if (validChunk(this, state, chunk, cb))                                                                       // 193\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);                                                           // 194\n                                                                                                                     // 195\n  return ret;                                                                                                        // 196\n};                                                                                                                   // 197\n                                                                                                                     // 198\nfunction decodeChunk(state, chunk, encoding) {                                                                       // 199\n  if (!state.objectMode &&                                                                                           // 200\n      state.decodeStrings !== false &&                                                                               // 201\n      typeof chunk === 'string') {                                                                                   // 202\n    chunk = new Buffer(chunk, encoding);                                                                             // 203\n  }                                                                                                                  // 204\n  return chunk;                                                                                                      // 205\n}                                                                                                                    // 206\n                                                                                                                     // 207\n// if we're already writing something, then just put this                                                            // 208\n// in the queue, and wait our turn.  Otherwise, call _write                                                          // 209\n// If we return false, then we need a drain event, so set that flag.                                                 // 210\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {                                                         // 211\n  chunk = decodeChunk(state, chunk, encoding);                                                                       // 212\n  if (Buffer.isBuffer(chunk))                                                                                        // 213\n    encoding = 'buffer';                                                                                             // 214\n  var len = state.objectMode ? 1 : chunk.length;                                                                     // 215\n                                                                                                                     // 216\n  state.length += len;                                                                                               // 217\n                                                                                                                     // 218\n  var ret = state.length < state.highWaterMark;                                                                      // 219\n  // we must ensure that previous needDrain will not be reset to false.                                              // 220\n  if (!ret)                                                                                                          // 221\n    state.needDrain = true;                                                                                          // 222\n                                                                                                                     // 223\n  if (state.writing)                                                                                                 // 224\n    state.buffer.push(new WriteReq(chunk, encoding, cb));                                                            // 225\n  else                                                                                                               // 226\n    doWrite(stream, state, len, chunk, encoding, cb);                                                                // 227\n                                                                                                                     // 228\n  return ret;                                                                                                        // 229\n}                                                                                                                    // 230\n                                                                                                                     // 231\nfunction doWrite(stream, state, len, chunk, encoding, cb) {                                                          // 232\n  state.writelen = len;                                                                                              // 233\n  state.writecb = cb;                                                                                                // 234\n  state.writing = true;                                                                                              // 235\n  state.sync = true;                                                                                                 // 236\n  stream._write(chunk, encoding, state.onwrite);                                                                     // 237\n  state.sync = false;                                                                                                // 238\n}                                                                                                                    // 239\n                                                                                                                     // 240\nfunction onwriteError(stream, state, sync, er, cb) {                                                                 // 241\n  if (sync)                                                                                                          // 242\n    process.nextTick(function() {                                                                                    // 243\n      cb(er);                                                                                                        // 244\n    });                                                                                                              // 245\n  else                                                                                                               // 246\n    cb(er);                                                                                                          // 247\n                                                                                                                     // 248\n  stream._writableState.errorEmitted = true;                                                                         // 249\n  stream.emit('error', er);                                                                                          // 250\n}                                                                                                                    // 251\n                                                                                                                     // 252\nfunction onwriteStateUpdate(state) {                                                                                 // 253\n  state.writing = false;                                                                                             // 254\n  state.writecb = null;                                                                                              // 255\n  state.length -= state.writelen;                                                                                    // 256\n  state.writelen = 0;                                                                                                // 257\n}                                                                                                                    // 258\n                                                                                                                     // 259\nfunction onwrite(stream, er) {                                                                                       // 260\n  var state = stream._writableState;                                                                                 // 261\n  var sync = state.sync;                                                                                             // 262\n  var cb = state.writecb;                                                                                            // 263\n                                                                                                                     // 264\n  onwriteStateUpdate(state);                                                                                         // 265\n                                                                                                                     // 266\n  if (er)                                                                                                            // 267\n    onwriteError(stream, state, sync, er, cb);                                                                       // 268\n  else {                                                                                                             // 269\n    // Check if we're actually ready to finish, but don't emit yet                                                   // 270\n    var finished = needFinish(stream, state);                                                                        // 271\n                                                                                                                     // 272\n    if (!finished && !state.bufferProcessing && state.buffer.length)                                                 // 273\n      clearBuffer(stream, state);                                                                                    // 274\n                                                                                                                     // 275\n    if (sync) {                                                                                                      // 276\n      process.nextTick(function() {                                                                                  // 277\n        afterWrite(stream, state, finished, cb);                                                                     // 278\n      });                                                                                                            // 279\n    } else {                                                                                                         // 280\n      afterWrite(stream, state, finished, cb);                                                                       // 281\n    }                                                                                                                // 282\n  }                                                                                                                  // 283\n}                                                                                                                    // 284\n                                                                                                                     // 285\nfunction afterWrite(stream, state, finished, cb) {                                                                   // 286\n  if (!finished)                                                                                                     // 287\n    onwriteDrain(stream, state);                                                                                     // 288\n  cb();                                                                                                              // 289\n  if (finished)                                                                                                      // 290\n    finishMaybe(stream, state);                                                                                      // 291\n}                                                                                                                    // 292\n                                                                                                                     // 293\n// Must force callback to be called on nextTick, so that we don't                                                    // 294\n// emit 'drain' before the write() consumer gets the 'false' return                                                  // 295\n// value, and has a chance to attach a 'drain' listener.                                                             // 296\nfunction onwriteDrain(stream, state) {                                                                               // 297\n  if (state.length === 0 && state.needDrain) {                                                                       // 298\n    state.needDrain = false;                                                                                         // 299\n    stream.emit('drain');                                                                                            // 300\n  }                                                                                                                  // 301\n}                                                                                                                    // 302\n                                                                                                                     // 303\n                                                                                                                     // 304\n// if there's something in the buffer waiting, then process it                                                       // 305\nfunction clearBuffer(stream, state) {                                                                                // 306\n  state.bufferProcessing = true;                                                                                     // 307\n                                                                                                                     // 308\n  for (var c = 0; c < state.buffer.length; c++) {                                                                    // 309\n    var entry = state.buffer[c];                                                                                     // 310\n    var chunk = entry.chunk;                                                                                         // 311\n    var encoding = entry.encoding;                                                                                   // 312\n    var cb = entry.callback;                                                                                         // 313\n    var len = state.objectMode ? 1 : chunk.length;                                                                   // 314\n                                                                                                                     // 315\n    doWrite(stream, state, len, chunk, encoding, cb);                                                                // 316\n                                                                                                                     // 317\n    // if we didn't call the onwrite immediately, then                                                               // 318\n    // it means that we need to wait until it does.                                                                  // 319\n    // also, that means that the chunk and cb are currently                                                          // 320\n    // being processed, so move the buffer counter past them.                                                        // 321\n    if (state.writing) {                                                                                             // 322\n      c++;                                                                                                           // 323\n      break;                                                                                                         // 324\n    }                                                                                                                // 325\n  }                                                                                                                  // 326\n                                                                                                                     // 327\n  state.bufferProcessing = false;                                                                                    // 328\n  if (c < state.buffer.length)                                                                                       // 329\n    state.buffer = state.buffer.slice(c);                                                                            // 330\n  else                                                                                                               // 331\n    state.buffer.length = 0;                                                                                         // 332\n}                                                                                                                    // 333\n                                                                                                                     // 334\nWritable.prototype._write = function(chunk, encoding, cb) {                                                          // 335\n  cb(new Error('not implemented'));                                                                                  // 336\n};                                                                                                                   // 337\n                                                                                                                     // 338\nWritable.prototype.end = function(chunk, encoding, cb) {                                                             // 339\n  var state = this._writableState;                                                                                   // 340\n                                                                                                                     // 341\n  if (typeof chunk === 'function') {                                                                                 // 342\n    cb = chunk;                                                                                                      // 343\n    chunk = null;                                                                                                    // 344\n    encoding = null;                                                                                                 // 345\n  } else if (typeof encoding === 'function') {                                                                       // 346\n    cb = encoding;                                                                                                   // 347\n    encoding = null;                                                                                                 // 348\n  }                                                                                                                  // 349\n                                                                                                                     // 350\n  if (typeof chunk !== 'undefined' && chunk !== null)                                                                // 351\n    this.write(chunk, encoding);                                                                                     // 352\n                                                                                                                     // 353\n  // ignore unnecessary end() calls.                                                                                 // 354\n  if (!state.ending && !state.finished)                                                                              // 355\n    endWritable(this, state, cb);                                                                                    // 356\n};                                                                                                                   // 357\n                                                                                                                     // 358\n                                                                                                                     // 359\nfunction needFinish(stream, state) {                                                                                 // 360\n  return (state.ending &&                                                                                            // 361\n          state.length === 0 &&                                                                                      // 362\n          !state.finished &&                                                                                         // 363\n          !state.writing);                                                                                           // 364\n}                                                                                                                    // 365\n                                                                                                                     // 366\nfunction finishMaybe(stream, state) {                                                                                // 367\n  var need = needFinish(stream, state);                                                                              // 368\n  if (need) {                                                                                                        // 369\n    state.finished = true;                                                                                           // 370\n    stream.emit('finish');                                                                                           // 371\n  }                                                                                                                  // 372\n  return need;                                                                                                       // 373\n}                                                                                                                    // 374\n                                                                                                                     // 375\nfunction endWritable(stream, state, cb) {                                                                            // 376\n  state.ending = true;                                                                                               // 377\n  finishMaybe(stream, state);                                                                                        // 378\n  if (cb) {                                                                                                          // 379\n    if (state.finished)                                                                                              // 380\n      process.nextTick(cb);                                                                                          // 381\n    else                                                                                                             // 382\n      stream.once('finish', cb);                                                                                     // 383\n  }                                                                                                                  // 384\n  state.ended = true;                                                                                                // 385\n}                                                                                                                    // 386\n                                                                                                                     // 387\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_duplex.js\":[\"core-util-is\",\"inherits\",\"./_stream_readable\",\"./_stream_writable\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/lib/_stream_duplex.js                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n// a duplex stream is just a stream that is both readable and writable.                                              // 22\n// Since JS doesn't have multiple prototypal inheritance, this class                                                 // 23\n// prototypally inherits from Readable, and then parasitically from                                                  // 24\n// Writable.                                                                                                         // 25\n                                                                                                                     // 26\nmodule.exports = Duplex;                                                                                             // 27\n                                                                                                                     // 28\n/*<replacement>*/                                                                                                    // 29\nvar objectKeys = Object.keys || function (obj) {                                                                     // 30\n  var keys = [];                                                                                                     // 31\n  for (var key in obj) keys.push(key);                                                                               // 32\n  return keys;                                                                                                       // 33\n}                                                                                                                    // 34\n/*</replacement>*/                                                                                                   // 35\n                                                                                                                     // 36\n                                                                                                                     // 37\n/*<replacement>*/                                                                                                    // 38\nvar util = require('core-util-is');                                                                                  // 39\nutil.inherits = require('inherits');                                                                                 // 40\n/*</replacement>*/                                                                                                   // 41\n                                                                                                                     // 42\nvar Readable = require('./_stream_readable');                                                                        // 43\nvar Writable = require('./_stream_writable');                                                                        // 44\n                                                                                                                     // 45\nutil.inherits(Duplex, Readable);                                                                                     // 46\n                                                                                                                     // 47\nforEach(objectKeys(Writable.prototype), function(method) {                                                           // 48\n  if (!Duplex.prototype[method])                                                                                     // 49\n    Duplex.prototype[method] = Writable.prototype[method];                                                           // 50\n});                                                                                                                  // 51\n                                                                                                                     // 52\nfunction Duplex(options) {                                                                                           // 53\n  if (!(this instanceof Duplex))                                                                                     // 54\n    return new Duplex(options);                                                                                      // 55\n                                                                                                                     // 56\n  Readable.call(this, options);                                                                                      // 57\n  Writable.call(this, options);                                                                                      // 58\n                                                                                                                     // 59\n  if (options && options.readable === false)                                                                         // 60\n    this.readable = false;                                                                                           // 61\n                                                                                                                     // 62\n  if (options && options.writable === false)                                                                         // 63\n    this.writable = false;                                                                                           // 64\n                                                                                                                     // 65\n  this.allowHalfOpen = true;                                                                                         // 66\n  if (options && options.allowHalfOpen === false)                                                                    // 67\n    this.allowHalfOpen = false;                                                                                      // 68\n                                                                                                                     // 69\n  this.once('end', onend);                                                                                           // 70\n}                                                                                                                    // 71\n                                                                                                                     // 72\n// the no-half-open enforcer                                                                                         // 73\nfunction onend() {                                                                                                   // 74\n  // if we allow half-open state, or if the writable side ended,                                                     // 75\n  // then we're ok.                                                                                                  // 76\n  if (this.allowHalfOpen || this._writableState.ended)                                                               // 77\n    return;                                                                                                          // 78\n                                                                                                                     // 79\n  // no more data can be written.                                                                                    // 80\n  // But allow more writes to happen in this tick.                                                                   // 81\n  process.nextTick(this.end.bind(this));                                                                             // 82\n}                                                                                                                    // 83\n                                                                                                                     // 84\nfunction forEach (xs, f) {                                                                                           // 85\n  for (var i = 0, l = xs.length; i < l; i++) {                                                                       // 86\n    f(xs[i], i);                                                                                                     // 87\n  }                                                                                                                  // 88\n}                                                                                                                    // 89\n                                                                                                                     // 90\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_transform.js\":[\"./_stream_duplex\",\"core-util-is\",\"inherits\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/lib/_stream_transform.js                                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n                                                                                                                     // 22\n// a transform stream is a readable/writable stream where you do                                                     // 23\n// something with the data.  Sometimes it's called a \"filter\",                                                       // 24\n// but that's not a great name for it, since that implies a thing where                                              // 25\n// some bits pass through, and others are simply ignored.  (That would                                               // 26\n// be a valid example of a transform, of course.)                                                                    // 27\n//                                                                                                                   // 28\n// While the output is causally related to the input, it's not a                                                     // 29\n// necessarily symmetric or synchronous transformation.  For example,                                                // 30\n// a zlib stream might take multiple plain-text writes(), and then                                                   // 31\n// emit a single compressed chunk some time in the future.                                                           // 32\n//                                                                                                                   // 33\n// Here's how this works:                                                                                            // 34\n//                                                                                                                   // 35\n// The Transform stream has all the aspects of the readable and writable                                             // 36\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)                                               // 37\n// internally, and returns false if there's a lot of pending writes                                                  // 38\n// buffered up.  When you call read(), that calls _read(n) until                                                     // 39\n// there's enough pending readable data buffered up.                                                                 // 40\n//                                                                                                                   // 41\n// In a transform stream, the written data is placed in a buffer.  When                                              // 42\n// _read(n) is called, it transforms the queued up data, calling the                                                 // 43\n// buffered _write cb's as it consumes chunks.  If consuming a single                                                // 44\n// written chunk would result in multiple output chunks, then the first                                              // 45\n// outputted bit calls the readcb, and subsequent chunks just go into                                                // 46\n// the read buffer, and will cause it to emit 'readable' if necessary.                                               // 47\n//                                                                                                                   // 48\n// This way, back-pressure is actually determined by the reading side,                                               // 49\n// since _read has to be called to start processing a new chunk.  However,                                           // 50\n// a pathological inflate type of transform can cause excessive buffering                                            // 51\n// here.  For example, imagine a stream where every byte of input is                                                 // 52\n// interpreted as an integer from 0-255, and then results in that many                                               // 53\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in                                               // 54\n// 1kb of data being output.  In this case, you could write a very small                                             // 55\n// amount of input, and end up with a very large amount of output.  In                                               // 56\n// such a pathological inflating mechanism, there'd be no way to tell                                                // 57\n// the system to stop doing the transform.  A single 4MB write could                                                 // 58\n// cause the system to run out of memory.                                                                            // 59\n//                                                                                                                   // 60\n// However, even in such a pathological case, only a single written chunk                                            // 61\n// would be consumed, and then the rest would wait (un-transformed) until                                            // 62\n// the results of the previous transformed chunk were consumed.                                                      // 63\n                                                                                                                     // 64\nmodule.exports = Transform;                                                                                          // 65\n                                                                                                                     // 66\nvar Duplex = require('./_stream_duplex');                                                                            // 67\n                                                                                                                     // 68\n/*<replacement>*/                                                                                                    // 69\nvar util = require('core-util-is');                                                                                  // 70\nutil.inherits = require('inherits');                                                                                 // 71\n/*</replacement>*/                                                                                                   // 72\n                                                                                                                     // 73\nutil.inherits(Transform, Duplex);                                                                                    // 74\n                                                                                                                     // 75\n                                                                                                                     // 76\nfunction TransformState(options, stream) {                                                                           // 77\n  this.afterTransform = function(er, data) {                                                                         // 78\n    return afterTransform(stream, er, data);                                                                         // 79\n  };                                                                                                                 // 80\n                                                                                                                     // 81\n  this.needTransform = false;                                                                                        // 82\n  this.transforming = false;                                                                                         // 83\n  this.writecb = null;                                                                                               // 84\n  this.writechunk = null;                                                                                            // 85\n}                                                                                                                    // 86\n                                                                                                                     // 87\nfunction afterTransform(stream, er, data) {                                                                          // 88\n  var ts = stream._transformState;                                                                                   // 89\n  ts.transforming = false;                                                                                           // 90\n                                                                                                                     // 91\n  var cb = ts.writecb;                                                                                               // 92\n                                                                                                                     // 93\n  if (!cb)                                                                                                           // 94\n    return stream.emit('error', new Error('no writecb in Transform class'));                                         // 95\n                                                                                                                     // 96\n  ts.writechunk = null;                                                                                              // 97\n  ts.writecb = null;                                                                                                 // 98\n                                                                                                                     // 99\n  if (data !== null && data !== undefined)                                                                           // 100\n    stream.push(data);                                                                                               // 101\n                                                                                                                     // 102\n  if (cb)                                                                                                            // 103\n    cb(er);                                                                                                          // 104\n                                                                                                                     // 105\n  var rs = stream._readableState;                                                                                    // 106\n  rs.reading = false;                                                                                                // 107\n  if (rs.needReadable || rs.length < rs.highWaterMark) {                                                             // 108\n    stream._read(rs.highWaterMark);                                                                                  // 109\n  }                                                                                                                  // 110\n}                                                                                                                    // 111\n                                                                                                                     // 112\n                                                                                                                     // 113\nfunction Transform(options) {                                                                                        // 114\n  if (!(this instanceof Transform))                                                                                  // 115\n    return new Transform(options);                                                                                   // 116\n                                                                                                                     // 117\n  Duplex.call(this, options);                                                                                        // 118\n                                                                                                                     // 119\n  var ts = this._transformState = new TransformState(options, this);                                                 // 120\n                                                                                                                     // 121\n  // when the writable side finishes, then flush out anything remaining.                                             // 122\n  var stream = this;                                                                                                 // 123\n                                                                                                                     // 124\n  // start out asking for a readable event once data is transformed.                                                 // 125\n  this._readableState.needReadable = true;                                                                           // 126\n                                                                                                                     // 127\n  // we have implemented the _read method, and done the other things                                                 // 128\n  // that Readable wants before the first _read call, so unset the                                                   // 129\n  // sync guard flag.                                                                                                // 130\n  this._readableState.sync = false;                                                                                  // 131\n                                                                                                                     // 132\n  this.once('finish', function() {                                                                                   // 133\n    if ('function' === typeof this._flush)                                                                           // 134\n      this._flush(function(er) {                                                                                     // 135\n        done(stream, er);                                                                                            // 136\n      });                                                                                                            // 137\n    else                                                                                                             // 138\n      done(stream);                                                                                                  // 139\n  });                                                                                                                // 140\n}                                                                                                                    // 141\n                                                                                                                     // 142\nTransform.prototype.push = function(chunk, encoding) {                                                               // 143\n  this._transformState.needTransform = false;                                                                        // 144\n  return Duplex.prototype.push.call(this, chunk, encoding);                                                          // 145\n};                                                                                                                   // 146\n                                                                                                                     // 147\n// This is the part where you do stuff!                                                                              // 148\n// override this function in implementation classes.                                                                 // 149\n// 'chunk' is an input chunk.                                                                                        // 150\n//                                                                                                                   // 151\n// Call `push(newChunk)` to pass along transformed output                                                            // 152\n// to the readable side.  You may call 'push' zero or more times.                                                    // 153\n//                                                                                                                   // 154\n// Call `cb(err)` when you are done with this chunk.  If you pass                                                    // 155\n// an error, then that'll put the hurt on the whole operation.  If you                                               // 156\n// never call cb(), then you'll never get another chunk.                                                             // 157\nTransform.prototype._transform = function(chunk, encoding, cb) {                                                     // 158\n  throw new Error('not implemented');                                                                                // 159\n};                                                                                                                   // 160\n                                                                                                                     // 161\nTransform.prototype._write = function(chunk, encoding, cb) {                                                         // 162\n  var ts = this._transformState;                                                                                     // 163\n  ts.writecb = cb;                                                                                                   // 164\n  ts.writechunk = chunk;                                                                                             // 165\n  ts.writeencoding = encoding;                                                                                       // 166\n  if (!ts.transforming) {                                                                                            // 167\n    var rs = this._readableState;                                                                                    // 168\n    if (ts.needTransform ||                                                                                          // 169\n        rs.needReadable ||                                                                                           // 170\n        rs.length < rs.highWaterMark)                                                                                // 171\n      this._read(rs.highWaterMark);                                                                                  // 172\n  }                                                                                                                  // 173\n};                                                                                                                   // 174\n                                                                                                                     // 175\n// Doesn't matter what the args are here.                                                                            // 176\n// _transform does all the work.                                                                                     // 177\n// That we got here means that the readable side wants more data.                                                    // 178\nTransform.prototype._read = function(n) {                                                                            // 179\n  var ts = this._transformState;                                                                                     // 180\n                                                                                                                     // 181\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {                                                    // 182\n    ts.transforming = true;                                                                                          // 183\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);                                             // 184\n  } else {                                                                                                           // 185\n    // mark that we need a transform, so that any data that comes in                                                 // 186\n    // will get processed, now that we've asked for it.                                                              // 187\n    ts.needTransform = true;                                                                                         // 188\n  }                                                                                                                  // 189\n};                                                                                                                   // 190\n                                                                                                                     // 191\n                                                                                                                     // 192\nfunction done(stream, er) {                                                                                          // 193\n  if (er)                                                                                                            // 194\n    return stream.emit('error', er);                                                                                 // 195\n                                                                                                                     // 196\n  // if there's nothing in the write buffer, then that means                                                         // 197\n  // that nothing more will ever be provided                                                                         // 198\n  var ws = stream._writableState;                                                                                    // 199\n  var rs = stream._readableState;                                                                                    // 200\n  var ts = stream._transformState;                                                                                   // 201\n                                                                                                                     // 202\n  if (ws.length)                                                                                                     // 203\n    throw new Error('calling transform done when ws.length != 0');                                                   // 204\n                                                                                                                     // 205\n  if (ts.transforming)                                                                                               // 206\n    throw new Error('calling transform done when still transforming');                                               // 207\n                                                                                                                     // 208\n  return stream.push(null);                                                                                          // 209\n}                                                                                                                    // 210\n                                                                                                                     // 211\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_passthrough.js\":[\"./_stream_transform\",\"core-util-is\",\"inherits\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/lib/_stream_passthrough.js                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n// a passthrough stream.                                                                                             // 22\n// basically just the most minimal sort of Transform stream.                                                         // 23\n// Every written chunk gets output as-is.                                                                            // 24\n                                                                                                                     // 25\nmodule.exports = PassThrough;                                                                                        // 26\n                                                                                                                     // 27\nvar Transform = require('./_stream_transform');                                                                      // 28\n                                                                                                                     // 29\n/*<replacement>*/                                                                                                    // 30\nvar util = require('core-util-is');                                                                                  // 31\nutil.inherits = require('inherits');                                                                                 // 32\n/*</replacement>*/                                                                                                   // 33\n                                                                                                                     // 34\nutil.inherits(PassThrough, Transform);                                                                               // 35\n                                                                                                                     // 36\nfunction PassThrough(options) {                                                                                      // 37\n  if (!(this instanceof PassThrough))                                                                                // 38\n    return new PassThrough(options);                                                                                 // 39\n                                                                                                                     // 40\n  Transform.call(this, options);                                                                                     // 41\n}                                                                                                                    // 42\n                                                                                                                     // 43\nPassThrough.prototype._transform = function(chunk, encoding, cb) {                                                   // 44\n  cb(null, chunk);                                                                                                   // 45\n};                                                                                                                   // 46\n                                                                                                                     // 47\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}},\"isarray\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/isarray/package.json                                                                                 //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"isarray\";                                                                                            // 1\nexports.version = \"0.0.1\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/isarray/index.js                                                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.exports = Array.isArray || function (arr) {                                                                   // 1\n  return Object.prototype.toString.call(arr) == '[object Array]';                                                    // 2\n};                                                                                                                   // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"core-util-is\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/core-util-is/package.json                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"core-util-is\";                                                                                       // 1\nexports.version = \"1.0.2\";                                                                                           // 2\nexports.main = \"lib/util.js\";                                                                                        // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lib\":{\"util.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/core-util-is/lib/util.js                                                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n// NOTE: These type checking functions intentionally don't use `instanceof`                                          // 22\n// because it is fragile and can be easily faked with `Object.create()`.                                             // 23\n                                                                                                                     // 24\nfunction isArray(arg) {                                                                                              // 25\n  if (Array.isArray) {                                                                                               // 26\n    return Array.isArray(arg);                                                                                       // 27\n  }                                                                                                                  // 28\n  return objectToString(arg) === '[object Array]';                                                                   // 29\n}                                                                                                                    // 30\nexports.isArray = isArray;                                                                                           // 31\n                                                                                                                     // 32\nfunction isBoolean(arg) {                                                                                            // 33\n  return typeof arg === 'boolean';                                                                                   // 34\n}                                                                                                                    // 35\nexports.isBoolean = isBoolean;                                                                                       // 36\n                                                                                                                     // 37\nfunction isNull(arg) {                                                                                               // 38\n  return arg === null;                                                                                               // 39\n}                                                                                                                    // 40\nexports.isNull = isNull;                                                                                             // 41\n                                                                                                                     // 42\nfunction isNullOrUndefined(arg) {                                                                                    // 43\n  return arg == null;                                                                                                // 44\n}                                                                                                                    // 45\nexports.isNullOrUndefined = isNullOrUndefined;                                                                       // 46\n                                                                                                                     // 47\nfunction isNumber(arg) {                                                                                             // 48\n  return typeof arg === 'number';                                                                                    // 49\n}                                                                                                                    // 50\nexports.isNumber = isNumber;                                                                                         // 51\n                                                                                                                     // 52\nfunction isString(arg) {                                                                                             // 53\n  return typeof arg === 'string';                                                                                    // 54\n}                                                                                                                    // 55\nexports.isString = isString;                                                                                         // 56\n                                                                                                                     // 57\nfunction isSymbol(arg) {                                                                                             // 58\n  return typeof arg === 'symbol';                                                                                    // 59\n}                                                                                                                    // 60\nexports.isSymbol = isSymbol;                                                                                         // 61\n                                                                                                                     // 62\nfunction isUndefined(arg) {                                                                                          // 63\n  return arg === void 0;                                                                                             // 64\n}                                                                                                                    // 65\nexports.isUndefined = isUndefined;                                                                                   // 66\n                                                                                                                     // 67\nfunction isRegExp(re) {                                                                                              // 68\n  return objectToString(re) === '[object RegExp]';                                                                   // 69\n}                                                                                                                    // 70\nexports.isRegExp = isRegExp;                                                                                         // 71\n                                                                                                                     // 72\nfunction isObject(arg) {                                                                                             // 73\n  return typeof arg === 'object' && arg !== null;                                                                    // 74\n}                                                                                                                    // 75\nexports.isObject = isObject;                                                                                         // 76\n                                                                                                                     // 77\nfunction isDate(d) {                                                                                                 // 78\n  return objectToString(d) === '[object Date]';                                                                      // 79\n}                                                                                                                    // 80\nexports.isDate = isDate;                                                                                             // 81\n                                                                                                                     // 82\nfunction isError(e) {                                                                                                // 83\n  return (objectToString(e) === '[object Error]' || e instanceof Error);                                             // 84\n}                                                                                                                    // 85\nexports.isError = isError;                                                                                           // 86\n                                                                                                                     // 87\nfunction isFunction(arg) {                                                                                           // 88\n  return typeof arg === 'function';                                                                                  // 89\n}                                                                                                                    // 90\nexports.isFunction = isFunction;                                                                                     // 91\n                                                                                                                     // 92\nfunction isPrimitive(arg) {                                                                                          // 93\n  return arg === null ||                                                                                             // 94\n         typeof arg === 'boolean' ||                                                                                 // 95\n         typeof arg === 'number' ||                                                                                  // 96\n         typeof arg === 'string' ||                                                                                  // 97\n         typeof arg === 'symbol' ||  // ES6 symbol                                                                   // 98\n         typeof arg === 'undefined';                                                                                 // 99\n}                                                                                                                    // 100\nexports.isPrimitive = isPrimitive;                                                                                   // 101\n                                                                                                                     // 102\nexports.isBuffer = Buffer.isBuffer;                                                                                  // 103\n                                                                                                                     // 104\nfunction objectToString(o) {                                                                                         // 105\n  return Object.prototype.toString.call(o);                                                                          // 106\n}                                                                                                                    // 107\n                                                                                                                     // 108\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"inherits\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/inherits/package.json                                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"inherits\";                                                                                           // 1\nexports.version = \"2.0.1\";                                                                                           // 2\nexports.main = \"./inherits_browser.js\";                                                                              // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"inherits_browser.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/inherits/inherits_browser.js                                                                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nif (typeof Object.create === 'function') {                                                                           // 1\n  // implementation from standard node.js 'util' module                                                              // 2\n  module.exports = function inherits(ctor, superCtor) {                                                              // 3\n    ctor.super_ = superCtor                                                                                          // 4\n    ctor.prototype = Object.create(superCtor.prototype, {                                                            // 5\n      constructor: {                                                                                                 // 6\n        value: ctor,                                                                                                 // 7\n        enumerable: false,                                                                                           // 8\n        writable: true,                                                                                              // 9\n        configurable: true                                                                                           // 10\n      }                                                                                                              // 11\n    });                                                                                                              // 12\n  };                                                                                                                 // 13\n} else {                                                                                                             // 14\n  // old school shim for old browsers                                                                                // 15\n  module.exports = function inherits(ctor, superCtor) {                                                              // 16\n    ctor.super_ = superCtor                                                                                          // 17\n    var TempCtor = function () {}                                                                                    // 18\n    TempCtor.prototype = superCtor.prototype                                                                         // 19\n    ctor.prototype = new TempCtor()                                                                                  // 20\n    ctor.prototype.constructor = ctor                                                                                // 21\n  }                                                                                                                  // 22\n}                                                                                                                    // 23\n                                                                                                                     // 24\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"string_decoder\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/string_decoder/package.json                                                                          //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"string_decoder\";                                                                                     // 1\nexports.version = \"0.10.31\";                                                                                         // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"buffer\",\"meteor-node-stubs/deps/buffer\",function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/string_decoder/index.js                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\nvar Buffer = require('buffer').Buffer;                                                                               // 22\n                                                                                                                     // 23\nvar isBufferEncoding = Buffer.isEncoding                                                                             // 24\n  || function(encoding) {                                                                                            // 25\n       switch (encoding && encoding.toLowerCase()) {                                                                 // 26\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;                                                                                      // 28\n       }                                                                                                             // 29\n     }                                                                                                               // 30\n                                                                                                                     // 31\n                                                                                                                     // 32\nfunction assertEncoding(encoding) {                                                                                  // 33\n  if (encoding && !isBufferEncoding(encoding)) {                                                                     // 34\n    throw new Error('Unknown encoding: ' + encoding);                                                                // 35\n  }                                                                                                                  // 36\n}                                                                                                                    // 37\n                                                                                                                     // 38\n// StringDecoder provides an interface for efficiently splitting a series of                                         // 39\n// buffers into a series of JS strings without breaking apart multi-byte                                             // 40\n// characters. CESU-8 is handled as part of the UTF-8 encoding.                                                      // 41\n//                                                                                                                   // 42\n// @TODO Handling all encodings inside a single object makes it very difficult                                       // 43\n// to reason about this code, so it should be split up in the future.                                                // 44\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code                                      // 45\n// points as used by CESU-8.                                                                                         // 46\nvar StringDecoder = exports.StringDecoder = function(encoding) {                                                     // 47\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');                                            // 48\n  assertEncoding(encoding);                                                                                          // 49\n  switch (this.encoding) {                                                                                           // 50\n    case 'utf8':                                                                                                     // 51\n      // CESU-8 represents each of Surrogate Pair by 3-bytes                                                         // 52\n      this.surrogateSize = 3;                                                                                        // 53\n      break;                                                                                                         // 54\n    case 'ucs2':                                                                                                     // 55\n    case 'utf16le':                                                                                                  // 56\n      // UTF-16 represents each of Surrogate Pair by 2-bytes                                                         // 57\n      this.surrogateSize = 2;                                                                                        // 58\n      this.detectIncompleteChar = utf16DetectIncompleteChar;                                                         // 59\n      break;                                                                                                         // 60\n    case 'base64':                                                                                                   // 61\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.                                                  // 62\n      this.surrogateSize = 3;                                                                                        // 63\n      this.detectIncompleteChar = base64DetectIncompleteChar;                                                        // 64\n      break;                                                                                                         // 65\n    default:                                                                                                         // 66\n      this.write = passThroughWrite;                                                                                 // 67\n      return;                                                                                                        // 68\n  }                                                                                                                  // 69\n                                                                                                                     // 70\n  // Enough space to store all bytes of a single character. UTF-8 needs 4                                            // 71\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).                                                  // 72\n  this.charBuffer = new Buffer(6);                                                                                   // 73\n  // Number of bytes received for the current incomplete multi-byte character.                                       // 74\n  this.charReceived = 0;                                                                                             // 75\n  // Number of bytes expected for the current incomplete multi-byte character.                                       // 76\n  this.charLength = 0;                                                                                               // 77\n};                                                                                                                   // 78\n                                                                                                                     // 79\n                                                                                                                     // 80\n// write decodes the given buffer and returns it as JS string that is                                                // 81\n// guaranteed to not contain any partial multi-byte characters. Any partial                                          // 82\n// character found at the end of the buffer is buffered up, and will be                                              // 83\n// returned when calling write again with the remaining bytes.                                                       // 84\n//                                                                                                                   // 85\n// Note: Converting a Buffer containing an orphan surrogate to a String                                              // 86\n// currently works, but converting a String to a Buffer (via `new Buffer`, or                                        // 87\n// Buffer#write) will replace incomplete surrogates with the unicode                                                 // 88\n// replacement character. See https://codereview.chromium.org/121173009/ .                                           // 89\nStringDecoder.prototype.write = function(buffer) {                                                                   // 90\n  var charStr = '';                                                                                                  // 91\n  // if our last write ended with an incomplete multibyte character                                                  // 92\n  while (this.charLength) {                                                                                          // 93\n    // determine how many remaining bytes this buffer has to offer for this char                                     // 94\n    var available = (buffer.length >= this.charLength - this.charReceived) ?                                         // 95\n        this.charLength - this.charReceived :                                                                        // 96\n        buffer.length;                                                                                               // 97\n                                                                                                                     // 98\n    // add the new bytes to the char buffer                                                                          // 99\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);                                                   // 100\n    this.charReceived += available;                                                                                  // 101\n                                                                                                                     // 102\n    if (this.charReceived < this.charLength) {                                                                       // 103\n      // still not enough chars in this buffer? wait for more ...                                                    // 104\n      return '';                                                                                                     // 105\n    }                                                                                                                // 106\n                                                                                                                     // 107\n    // remove bytes belonging to the current character from the buffer                                               // 108\n    buffer = buffer.slice(available, buffer.length);                                                                 // 109\n                                                                                                                     // 110\n    // get the character that was split                                                                              // 111\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);                                     // 112\n                                                                                                                     // 113\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character                                           // 114\n    var charCode = charStr.charCodeAt(charStr.length - 1);                                                           // 115\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {                                                                  // 116\n      this.charLength += this.surrogateSize;                                                                         // 117\n      charStr = '';                                                                                                  // 118\n      continue;                                                                                                      // 119\n    }                                                                                                                // 120\n    this.charReceived = this.charLength = 0;                                                                         // 121\n                                                                                                                     // 122\n    // if there are no more bytes in this buffer, just emit our char                                                 // 123\n    if (buffer.length === 0) {                                                                                       // 124\n      return charStr;                                                                                                // 125\n    }                                                                                                                // 126\n    break;                                                                                                           // 127\n  }                                                                                                                  // 128\n                                                                                                                     // 129\n  // determine and set charLength / charReceived                                                                     // 130\n  this.detectIncompleteChar(buffer);                                                                                 // 131\n                                                                                                                     // 132\n  var end = buffer.length;                                                                                           // 133\n  if (this.charLength) {                                                                                             // 134\n    // buffer the incomplete character bytes we got                                                                  // 135\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);                                         // 136\n    end -= this.charReceived;                                                                                        // 137\n  }                                                                                                                  // 138\n                                                                                                                     // 139\n  charStr += buffer.toString(this.encoding, 0, end);                                                                 // 140\n                                                                                                                     // 141\n  var end = charStr.length - 1;                                                                                      // 142\n  var charCode = charStr.charCodeAt(end);                                                                            // 143\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character                                             // 144\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {                                                                    // 145\n    var size = this.surrogateSize;                                                                                   // 146\n    this.charLength += size;                                                                                         // 147\n    this.charReceived += size;                                                                                       // 148\n    this.charBuffer.copy(this.charBuffer, size, 0, size);                                                            // 149\n    buffer.copy(this.charBuffer, 0, 0, size);                                                                        // 150\n    return charStr.substring(0, end);                                                                                // 151\n  }                                                                                                                  // 152\n                                                                                                                     // 153\n  // or just emit the charStr                                                                                        // 154\n  return charStr;                                                                                                    // 155\n};                                                                                                                   // 156\n                                                                                                                     // 157\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at                                      // 158\n// the end of the given buffer. If so, it sets this.charLength to the byte                                           // 159\n// length that character, and sets this.charReceived to the number of bytes                                          // 160\n// that are available for this character.                                                                            // 161\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {                                                    // 162\n  // determine how many bytes we have to check at the end of this buffer                                             // 163\n  var i = (buffer.length >= 3) ? 3 : buffer.length;                                                                  // 164\n                                                                                                                     // 165\n  // Figure out if one of the last i bytes of our buffer announces an                                                // 166\n  // incomplete char.                                                                                                // 167\n  for (; i > 0; i--) {                                                                                               // 168\n    var c = buffer[buffer.length - i];                                                                               // 169\n                                                                                                                     // 170\n    // See http://en.wikipedia.org/wiki/UTF-8#Description                                                            // 171\n                                                                                                                     // 172\n    // 110XXXXX                                                                                                      // 173\n    if (i == 1 && c >> 5 == 0x06) {                                                                                  // 174\n      this.charLength = 2;                                                                                           // 175\n      break;                                                                                                         // 176\n    }                                                                                                                // 177\n                                                                                                                     // 178\n    // 1110XXXX                                                                                                      // 179\n    if (i <= 2 && c >> 4 == 0x0E) {                                                                                  // 180\n      this.charLength = 3;                                                                                           // 181\n      break;                                                                                                         // 182\n    }                                                                                                                // 183\n                                                                                                                     // 184\n    // 11110XXX                                                                                                      // 185\n    if (i <= 3 && c >> 3 == 0x1E) {                                                                                  // 186\n      this.charLength = 4;                                                                                           // 187\n      break;                                                                                                         // 188\n    }                                                                                                                // 189\n  }                                                                                                                  // 190\n  this.charReceived = i;                                                                                             // 191\n};                                                                                                                   // 192\n                                                                                                                     // 193\nStringDecoder.prototype.end = function(buffer) {                                                                     // 194\n  var res = '';                                                                                                      // 195\n  if (buffer && buffer.length)                                                                                       // 196\n    res = this.write(buffer);                                                                                        // 197\n                                                                                                                     // 198\n  if (this.charReceived) {                                                                                           // 199\n    var cr = this.charReceived;                                                                                      // 200\n    var buf = this.charBuffer;                                                                                       // 201\n    var enc = this.encoding;                                                                                         // 202\n    res += buf.slice(0, cr).toString(enc);                                                                           // 203\n  }                                                                                                                  // 204\n                                                                                                                     // 205\n  return res;                                                                                                        // 206\n};                                                                                                                   // 207\n                                                                                                                     // 208\nfunction passThroughWrite(buffer) {                                                                                  // 209\n  return buffer.toString(this.encoding);                                                                             // 210\n}                                                                                                                    // 211\n                                                                                                                     // 212\nfunction utf16DetectIncompleteChar(buffer) {                                                                         // 213\n  this.charReceived = buffer.length % 2;                                                                             // 214\n  this.charLength = this.charReceived ? 2 : 0;                                                                       // 215\n}                                                                                                                    // 216\n                                                                                                                     // 217\nfunction base64DetectIncompleteChar(buffer) {                                                                        // 218\n  this.charReceived = buffer.length % 3;                                                                             // 219\n  this.charLength = this.charReceived ? 3 : 0;                                                                       // 220\n}                                                                                                                    // 221\n                                                                                                                     // 222\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"debug\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/debug/package.json                                                                                   //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"debug\";                                                                                              // 1\nexports.version = \"0.7.4\";                                                                                           // 2\nexports.main = \"./debug.js\";                                                                                         // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"debug.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/debug/debug.js                                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n                                                                                                                     // 1\n/**                                                                                                                  // 2\n * Expose `debug()` as the module.                                                                                   // 3\n */                                                                                                                  // 4\n                                                                                                                     // 5\nmodule.exports = debug;                                                                                              // 6\n                                                                                                                     // 7\n/**                                                                                                                  // 8\n * Create a debugger with the given `name`.                                                                          // 9\n *                                                                                                                   // 10\n * @param {String} name                                                                                              // 11\n * @return {Type}                                                                                                    // 12\n * @api public                                                                                                       // 13\n */                                                                                                                  // 14\n                                                                                                                     // 15\nfunction debug(name) {                                                                                               // 16\n  if (!debug.enabled(name)) return function(){};                                                                     // 17\n                                                                                                                     // 18\n  return function(fmt){                                                                                              // 19\n    fmt = coerce(fmt);                                                                                               // 20\n                                                                                                                     // 21\n    var curr = new Date;                                                                                             // 22\n    var ms = curr - (debug[name] || curr);                                                                           // 23\n    debug[name] = curr;                                                                                              // 24\n                                                                                                                     // 25\n    fmt = name                                                                                                       // 26\n      + ' '                                                                                                          // 27\n      + fmt                                                                                                          // 28\n      + ' +' + debug.humanize(ms);                                                                                   // 29\n                                                                                                                     // 30\n    // This hackery is required for IE8                                                                              // 31\n    // where `console.log` doesn't have 'apply'                                                                      // 32\n    window.console                                                                                                   // 33\n      && console.log                                                                                                 // 34\n      && Function.prototype.apply.call(console.log, console, arguments);                                             // 35\n  }                                                                                                                  // 36\n}                                                                                                                    // 37\n                                                                                                                     // 38\n/**                                                                                                                  // 39\n * The currently active debug mode names.                                                                            // 40\n */                                                                                                                  // 41\n                                                                                                                     // 42\ndebug.names = [];                                                                                                    // 43\ndebug.skips = [];                                                                                                    // 44\n                                                                                                                     // 45\n/**                                                                                                                  // 46\n * Enables a debug mode by name. This can include modes                                                              // 47\n * separated by a colon and wildcards.                                                                               // 48\n *                                                                                                                   // 49\n * @param {String} name                                                                                              // 50\n * @api public                                                                                                       // 51\n */                                                                                                                  // 52\n                                                                                                                     // 53\ndebug.enable = function(name) {                                                                                      // 54\n  try {                                                                                                              // 55\n    localStorage.debug = name;                                                                                       // 56\n  } catch(e){}                                                                                                       // 57\n                                                                                                                     // 58\n  var split = (name || '').split(/[\\s,]+/)                                                                           // 59\n    , len = split.length;                                                                                            // 60\n                                                                                                                     // 61\n  for (var i = 0; i < len; i++) {                                                                                    // 62\n    name = split[i].replace('*', '.*?');                                                                             // 63\n    if (name[0] === '-') {                                                                                           // 64\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));                                                      // 65\n    }                                                                                                                // 66\n    else {                                                                                                           // 67\n      debug.names.push(new RegExp('^' + name + '$'));                                                                // 68\n    }                                                                                                                // 69\n  }                                                                                                                  // 70\n};                                                                                                                   // 71\n                                                                                                                     // 72\n/**                                                                                                                  // 73\n * Disable debug output.                                                                                             // 74\n *                                                                                                                   // 75\n * @api public                                                                                                       // 76\n */                                                                                                                  // 77\n                                                                                                                     // 78\ndebug.disable = function(){                                                                                          // 79\n  debug.enable('');                                                                                                  // 80\n};                                                                                                                   // 81\n                                                                                                                     // 82\n/**                                                                                                                  // 83\n * Humanize the given `ms`.                                                                                          // 84\n *                                                                                                                   // 85\n * @param {Number} m                                                                                                 // 86\n * @return {String}                                                                                                  // 87\n * @api private                                                                                                      // 88\n */                                                                                                                  // 89\n                                                                                                                     // 90\ndebug.humanize = function(ms) {                                                                                      // 91\n  var sec = 1000                                                                                                     // 92\n    , min = 60 * 1000                                                                                                // 93\n    , hour = 60 * min;                                                                                               // 94\n                                                                                                                     // 95\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';                                                               // 96\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';                                                                 // 97\n  if (ms >= sec) return (ms / sec | 0) + 's';                                                                        // 98\n  return ms + 'ms';                                                                                                  // 99\n};                                                                                                                   // 100\n                                                                                                                     // 101\n/**                                                                                                                  // 102\n * Returns true if the given mode name is enabled, false otherwise.                                                  // 103\n *                                                                                                                   // 104\n * @param {String} name                                                                                              // 105\n * @return {Boolean}                                                                                                 // 106\n * @api public                                                                                                       // 107\n */                                                                                                                  // 108\n                                                                                                                     // 109\ndebug.enabled = function(name) {                                                                                     // 110\n  for (var i = 0, len = debug.skips.length; i < len; i++) {                                                          // 111\n    if (debug.skips[i].test(name)) {                                                                                 // 112\n      return false;                                                                                                  // 113\n    }                                                                                                                // 114\n  }                                                                                                                  // 115\n  for (var i = 0, len = debug.names.length; i < len; i++) {                                                          // 116\n    if (debug.names[i].test(name)) {                                                                                 // 117\n      return true;                                                                                                   // 118\n    }                                                                                                                // 119\n  }                                                                                                                  // 120\n  return false;                                                                                                      // 121\n};                                                                                                                   // 122\n                                                                                                                     // 123\n/**                                                                                                                  // 124\n * Coerce `val`.                                                                                                     // 125\n */                                                                                                                  // 126\n                                                                                                                     // 127\nfunction coerce(val) {                                                                                               // 128\n  if (val instanceof Error) return val.stack || val.message;                                                         // 129\n  return val;                                                                                                        // 130\n}                                                                                                                    // 131\n                                                                                                                     // 132\n// persist                                                                                                           // 133\n                                                                                                                     // 134\ntry {                                                                                                                // 135\n  if (window.localStorage) debug.enable(localStorage.debug);                                                         // 136\n} catch(e){}                                                                                                         // 137\n                                                                                                                     // 138\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"split-ca\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/split-ca/package.json                                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"split-ca\";                                                                                           // 1\nexports.version = \"1.0.1\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"fs\",\"meteor-node-stubs/deps/fs\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/split-ca/index.js                                                                                    //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar fs = require('fs');                                                                                              // 1\n                                                                                                                     // 2\nmodule.exports = function (filepath, split, encoding) {                                                              // 3\n  split = typeof split !== 'undefined' ? split : \"\\n\";                                                               // 4\n  encoding = typeof encoding !== 'undefined' ? encoding : \"utf8\";                                                    // 5\n                                                                                                                     // 6\n  var ca = [];                                                                                                       // 7\n  var chain = fs.readFileSync(filepath, encoding);                                                                   // 8\n  if(chain.indexOf(\"-END CERTIFICATE-\") < 0 || chain.indexOf(\"-BEGIN CERTIFICATE-\") < 0){                            // 9\n    throw Error(\"File does not contain 'BEGIN CERTIFICATE' or 'END CERTIFICATE'\");                                   // 10\n  }                                                                                                                  // 11\n  chain = chain.split(split);                                                                                        // 12\n  var cert = [];                                                                                                     // 13\n  var _i, _len;                                                                                                      // 14\n  for (_i = 0, _len = chain.length; _i < _len; _i++) {                                                               // 15\n    var line = chain[_i];                                                                                            // 16\n    if (!(line.length !== 0)) {                                                                                      // 17\n      continue;                                                                                                      // 18\n    }                                                                                                                // 19\n    cert.push(line);                                                                                                 // 20\n    if (line.match(/-END CERTIFICATE-/)) {                                                                           // 21\n      ca.push(cert.join(split));                                                                                     // 22\n      cert = [];                                                                                                     // 23\n    }                                                                                                                // 24\n  }                                                                                                                  // 25\n  return ca;                                                                                                         // 26\n}                                                                                                                    // 27\n                                                                                                                     // 28\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"JSONStream\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/JSONStream/package.json                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"JSONStream\";                                                                                         // 1\nexports.version = \"0.10.0\";                                                                                          // 2\n                                                                                                                     // 3\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"jsonparse\",\"through\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/JSONStream/index.js                                                                                  //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n                                                                                                                     // 1\n                                                                                                                     // 2\nvar Parser = require('jsonparse')                                                                                    // 3\n  , through = require('through')                                                                                     // 4\n                                                                                                                     // 5\n/*                                                                                                                   // 6\n                                                                                                                     // 7\n  the value of this.stack that creationix's jsonparse has is weird.                                                  // 8\n                                                                                                                     // 9\n  it makes this code ugly, but his problem is way harder that mine,                                                  // 10\n  so i'll forgive him.                                                                                               // 11\n                                                                                                                     // 12\n*/                                                                                                                   // 13\n                                                                                                                     // 14\nexports.parse = function (path, map) {                                                                               // 15\n                                                                                                                     // 16\n  var parser = new Parser()                                                                                          // 17\n  var stream = through(function (chunk) {                                                                            // 18\n    if('string' === typeof chunk)                                                                                    // 19\n      chunk = new Buffer(chunk)                                                                                      // 20\n    parser.write(chunk)                                                                                              // 21\n  },                                                                                                                 // 22\n  function (data) {                                                                                                  // 23\n    if(data)                                                                                                         // 24\n      stream.write(data)                                                                                             // 25\n    stream.queue(null)                                                                                               // 26\n  })                                                                                                                 // 27\n                                                                                                                     // 28\n  if('string' === typeof path)                                                                                       // 29\n    path = path.split('.').map(function (e) {                                                                        // 30\n      if (e === '*')                                                                                                 // 31\n        return true                                                                                                  // 32\n      else if (e === '') // '..'.split('.') returns an empty string                                                  // 33\n        return {recurse: true}                                                                                       // 34\n      else                                                                                                           // 35\n        return e                                                                                                     // 36\n    })                                                                                                               // 37\n                                                                                                                     // 38\n                                                                                                                     // 39\n  var count = 0, _key                                                                                                // 40\n  if(!path || !path.length)                                                                                          // 41\n    path = null                                                                                                      // 42\n                                                                                                                     // 43\n  parser.onValue = function (value) {                                                                                // 44\n    if (!this.root)                                                                                                  // 45\n      stream.root = value                                                                                            // 46\n                                                                                                                     // 47\n    if(! path) return                                                                                                // 48\n                                                                                                                     // 49\n    var i = 0 // iterates on path                                                                                    // 50\n    var j  = 0 // iterates on stack                                                                                  // 51\n    while (i < path.length) {                                                                                        // 52\n      var key = path[i]                                                                                              // 53\n      var c                                                                                                          // 54\n      j++                                                                                                            // 55\n                                                                                                                     // 56\n      if (key && !key.recurse) {                                                                                     // 57\n        c = (j === this.stack.length) ? this : this.stack[j]                                                         // 58\n        if (!c) return                                                                                               // 59\n        if (! check(key, c.key)) return                                                                              // 60\n        i++                                                                                                          // 61\n      } else {                                                                                                       // 62\n        i++                                                                                                          // 63\n        var nextKey = path[i]                                                                                        // 64\n        if (! nextKey) return                                                                                        // 65\n        while (true) {                                                                                               // 66\n          c = (j === this.stack.length) ? this : this.stack[j]                                                       // 67\n          if (!c) return                                                                                             // 68\n          if (check(nextKey, c.key)) { i++; break}                                                                   // 69\n          j++                                                                                                        // 70\n        }                                                                                                            // 71\n      }                                                                                                              // 72\n    }                                                                                                                // 73\n    if (j !== this.stack.length) return                                                                              // 74\n                                                                                                                     // 75\n    count ++                                                                                                         // 76\n    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])            // 77\n    var data = this.value[this.key]                                                                                  // 78\n    if(null != data)                                                                                                 // 79\n      if(null != (data = map ? map(data, actualPath) : data))                                                        // 80\n        stream.queue(data)                                                                                           // 81\n    delete this.value[this.key]                                                                                      // 82\n  }                                                                                                                  // 83\n  parser._onToken = parser.onToken;                                                                                  // 84\n                                                                                                                     // 85\n  parser.onToken = function (token, value) {                                                                         // 86\n    parser._onToken(token, value);                                                                                   // 87\n    if (this.stack.length === 0) {                                                                                   // 88\n      if (stream.root) {                                                                                             // 89\n        if(!path)                                                                                                    // 90\n          stream.queue(stream.root)                                                                                  // 91\n        stream.emit('root', stream.root, count)                                                                      // 92\n        count = 0;                                                                                                   // 93\n        stream.root = null;                                                                                          // 94\n      }                                                                                                              // 95\n    }                                                                                                                // 96\n  }                                                                                                                  // 97\n                                                                                                                     // 98\n  parser.onError = function (err) {                                                                                  // 99\n    stream.emit('error', err)                                                                                        // 100\n  }                                                                                                                  // 101\n                                                                                                                     // 102\n                                                                                                                     // 103\n  return stream                                                                                                      // 104\n}                                                                                                                    // 105\n                                                                                                                     // 106\nfunction check (x, y) {                                                                                              // 107\n  if ('string' === typeof x)                                                                                         // 108\n    return y == x                                                                                                    // 109\n  else if (x && 'function' === typeof x.exec)                                                                        // 110\n    return x.exec(y)                                                                                                 // 111\n  else if ('boolean' === typeof x)                                                                                   // 112\n    return x                                                                                                         // 113\n  else if ('function' === typeof x)                                                                                  // 114\n    return x(y)                                                                                                      // 115\n  return false                                                                                                       // 116\n}                                                                                                                    // 117\n                                                                                                                     // 118\nexports.stringify = function (op, sep, cl, indent) {                                                                 // 119\n  indent = indent || 0                                                                                               // 120\n  if (op === false){                                                                                                 // 121\n    op = ''                                                                                                          // 122\n    sep = '\\n'                                                                                                       // 123\n    cl = ''                                                                                                          // 124\n  } else if (op == null) {                                                                                           // 125\n                                                                                                                     // 126\n    op = '[\\n'                                                                                                       // 127\n    sep = '\\n,\\n'                                                                                                    // 128\n    cl = '\\n]\\n'                                                                                                     // 129\n                                                                                                                     // 130\n  }                                                                                                                  // 131\n                                                                                                                     // 132\n  //else, what ever you like                                                                                         // 133\n                                                                                                                     // 134\n  var stream                                                                                                         // 135\n    , first = true                                                                                                   // 136\n    , anyData = false                                                                                                // 137\n  stream = through(function (data) {                                                                                 // 138\n    anyData = true                                                                                                   // 139\n    var json = JSON.stringify(data, null, indent)                                                                    // 140\n    if(first) { first = false ; stream.queue(op + json)}                                                             // 141\n    else stream.queue(sep + json)                                                                                    // 142\n  },                                                                                                                 // 143\n  function (data) {                                                                                                  // 144\n    if(!anyData)                                                                                                     // 145\n      stream.queue(op)                                                                                               // 146\n    stream.queue(cl)                                                                                                 // 147\n    stream.queue(null)                                                                                               // 148\n  })                                                                                                                 // 149\n                                                                                                                     // 150\n  return stream                                                                                                      // 151\n}                                                                                                                    // 152\n                                                                                                                     // 153\nexports.stringifyObject = function (op, sep, cl, indent) {                                                           // 154\n  indent = indent || 0                                                                                               // 155\n  if (op === false){                                                                                                 // 156\n    op = ''                                                                                                          // 157\n    sep = '\\n'                                                                                                       // 158\n    cl = ''                                                                                                          // 159\n  } else if (op == null) {                                                                                           // 160\n                                                                                                                     // 161\n    op = '{\\n'                                                                                                       // 162\n    sep = '\\n,\\n'                                                                                                    // 163\n    cl = '\\n}\\n'                                                                                                     // 164\n                                                                                                                     // 165\n  }                                                                                                                  // 166\n                                                                                                                     // 167\n  //else, what ever you like                                                                                         // 168\n                                                                                                                     // 169\n  var first = true                                                                                                   // 170\n    , anyData = false                                                                                                // 171\n  stream = through(function (data) {                                                                                 // 172\n    anyData = true                                                                                                   // 173\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)                                 // 174\n    if(first) { first = false ; this.queue(op + json)}                                                               // 175\n    else this.queue(sep + json)                                                                                      // 176\n  },                                                                                                                 // 177\n  function (data) {                                                                                                  // 178\n    if(!anyData) this.queue(op)                                                                                      // 179\n    this.queue(cl)                                                                                                   // 180\n                                                                                                                     // 181\n    this.queue(null)                                                                                                 // 182\n  })                                                                                                                 // 183\n                                                                                                                     // 184\n  return stream                                                                                                      // 185\n}                                                                                                                    // 186\n                                                                                                                     // 187\nif(!module.parent && process.title !== 'browser') {                                                                  // 188\n  process.stdin                                                                                                      // 189\n    .pipe(exports.parse(process.argv[2]))                                                                            // 190\n    .pipe(exports.stringify('[', ',\\n', ']\\n', 2))                                                                   // 191\n    .pipe(process.stdout)                                                                                            // 192\n}                                                                                                                    // 193\n                                                                                                                     // 194\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"jsonparse\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/jsonparse/package.json                                                                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"jsonparse\";                                                                                          // 1\nexports.version = \"0.0.5\";                                                                                           // 2\nexports.main = \"jsonparse.js\";                                                                                       // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"jsonparse.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/jsonparse/jsonparse.js                                                                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/*global Buffer*/                                                                                                    // 1\n// Named constants with unique integer values                                                                        // 2\nvar C = {};                                                                                                          // 3\n// Tokens                                                                                                            // 4\nvar LEFT_BRACE    = C.LEFT_BRACE    = 0x1;                                                                           // 5\nvar RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;                                                                           // 6\nvar LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;                                                                           // 7\nvar RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;                                                                           // 8\nvar COLON         = C.COLON         = 0x5;                                                                           // 9\nvar COMMA         = C.COMMA         = 0x6;                                                                           // 10\nvar TRUE          = C.TRUE          = 0x7;                                                                           // 11\nvar FALSE         = C.FALSE         = 0x8;                                                                           // 12\nvar NULL          = C.NULL          = 0x9;                                                                           // 13\nvar STRING        = C.STRING        = 0xa;                                                                           // 14\nvar NUMBER        = C.NUMBER        = 0xb;                                                                           // 15\n// Tokenizer States                                                                                                  // 16\nvar START   = C.START   = 0x11;                                                                                      // 17\nvar TRUE1   = C.TRUE1   = 0x21;                                                                                      // 18\nvar TRUE2   = C.TRUE2   = 0x22;                                                                                      // 19\nvar TRUE3   = C.TRUE3   = 0x23;                                                                                      // 20\nvar FALSE1  = C.FALSE1  = 0x31;                                                                                      // 21\nvar FALSE2  = C.FALSE2  = 0x32;                                                                                      // 22\nvar FALSE3  = C.FALSE3  = 0x33;                                                                                      // 23\nvar FALSE4  = C.FALSE4  = 0x34;                                                                                      // 24\nvar NULL1   = C.NULL1   = 0x41;                                                                                      // 25\nvar NULL2   = C.NULL3   = 0x42;                                                                                      // 26\nvar NULL3   = C.NULL2   = 0x43;                                                                                      // 27\nvar NUMBER1 = C.NUMBER1 = 0x51;                                                                                      // 28\nvar NUMBER2 = C.NUMBER2 = 0x52;                                                                                      // 29\nvar NUMBER3 = C.NUMBER3 = 0x53;                                                                                      // 30\nvar NUMBER4 = C.NUMBER4 = 0x54;                                                                                      // 31\nvar NUMBER5 = C.NUMBER5 = 0x55;                                                                                      // 32\nvar NUMBER6 = C.NUMBER6 = 0x56;                                                                                      // 33\nvar NUMBER7 = C.NUMBER7 = 0x57;                                                                                      // 34\nvar NUMBER8 = C.NUMBER8 = 0x58;                                                                                      // 35\nvar STRING1 = C.STRING1 = 0x61;                                                                                      // 36\nvar STRING2 = C.STRING2 = 0x62;                                                                                      // 37\nvar STRING3 = C.STRING3 = 0x63;                                                                                      // 38\nvar STRING4 = C.STRING4 = 0x64;                                                                                      // 39\nvar STRING5 = C.STRING5 = 0x65;                                                                                      // 40\nvar STRING6 = C.STRING6 = 0x66;                                                                                      // 41\n// Parser States                                                                                                     // 42\nvar VALUE   = C.VALUE   = 0x71;                                                                                      // 43\nvar KEY     = C.KEY     = 0x72;                                                                                      // 44\n// Parser Modes                                                                                                      // 45\nvar OBJECT  = C.OBJECT  = 0x81;                                                                                      // 46\nvar ARRAY   = C.ARRAY   = 0x82;                                                                                      // 47\n                                                                                                                     // 48\n// Slow code to string converter (only used when throwing syntax errors)                                             // 49\nfunction toknam(code) {                                                                                              // 50\n  var keys = Object.keys(C);                                                                                         // 51\n  for (var i = 0, l = keys.length; i < l; i++) {                                                                     // 52\n    var key = keys[i];                                                                                               // 53\n    if (C[key] === code) { return key; }                                                                             // 54\n  }                                                                                                                  // 55\n  return code && (\"0x\" + code.toString(16));                                                                         // 56\n}                                                                                                                    // 57\n                                                                                                                     // 58\n                                                                                                                     // 59\nfunction Parser() {                                                                                                  // 60\n  this.tState = START;                                                                                               // 61\n  this.value = undefined;                                                                                            // 62\n                                                                                                                     // 63\n  this.string = undefined; // string data                                                                            // 64\n  this.unicode = undefined; // unicode escapes                                                                       // 65\n                                                                                                                     // 66\n  // For number parsing                                                                                              // 67\n  this.negative = undefined;                                                                                         // 68\n  this.magnatude = undefined;                                                                                        // 69\n  this.position = undefined;                                                                                         // 70\n  this.exponent = undefined;                                                                                         // 71\n  this.negativeExponent = undefined;                                                                                 // 72\n                                                                                                                     // 73\n  this.key = undefined;                                                                                              // 74\n  this.mode = undefined;                                                                                             // 75\n  this.stack = [];                                                                                                   // 76\n  this.state = VALUE;                                                                                                // 77\n  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary        // 78\n  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read                                               // 79\n  this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n}                                                                                                                    // 81\nvar proto = Parser.prototype;                                                                                        // 82\nproto.charError = function (buffer, i) {                                                                             // 83\n  this.onError(new Error(\"Unexpected \" + JSON.stringify(String.fromCharCode(buffer[i])) + \" at position \" + i + \" in state \" + toknam(this.tState)));\n};                                                                                                                   // 85\nproto.onError = function (err) { throw err; };                                                                       // 86\nproto.write = function (buffer) {                                                                                    // 87\n  if (typeof buffer === \"string\") buffer = new Buffer(buffer);                                                       // 88\n  //process.stdout.write(\"Input: \");                                                                                 // 89\n  //console.dir(buffer.toString());                                                                                  // 90\n  var n;                                                                                                             // 91\n  for (var i = 0, l = buffer.length; i < l; i++) {                                                                   // 92\n    if (this.tState === START){                                                                                      // 93\n      n = buffer[i];                                                                                                 // 94\n      if(n === 0x7b){ this.onToken(LEFT_BRACE, \"{\"); // {                                                            // 95\n      }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, \"}\"); // }                                                     // 96\n      }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, \"[\"); // [                                                    // 97\n      }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, \"]\"); // ]                                                   // 98\n      }else if(n === 0x3a){ this.onToken(COLON, \":\");  // :                                                          // 99\n      }else if(n === 0x2c){ this.onToken(COMMA, \",\"); // ,                                                           // 100\n      }else if(n === 0x74){ this.tState = TRUE1;  // t                                                               // 101\n      }else if(n === 0x66){ this.tState = FALSE1;  // f                                                              // 102\n      }else if(n === 0x6e){ this.tState = NULL1; // n                                                                // 103\n      }else if(n === 0x22){ this.string = \"\"; this.tState = STRING1; // \"                                            // 104\n      }else if(n === 0x2d){ this.negative = true; this.tState = NUMBER1; // -                                        // 105\n      }else if(n === 0x30){ this.magnatude = 0; this.tState = NUMBER2; // 0                                          // 106\n      }else{                                                                                                         // 107\n        if (n > 0x30 && n < 0x40) { // 1-9                                                                           // 108\n          this.magnatude = n - 0x30; this.tState = NUMBER3;                                                          // 109\n        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {                                           // 110\n          // whitespace                                                                                              // 111\n        } else { this.charError(buffer, i); }                                                                        // 112\n      }                                                                                                              // 113\n    }else if (this.tState === STRING1){ // After open quote                                                          // 114\n      n = buffer[i]; // get current byte from buffer                                                                 // 115\n      // check for carry over of a multi byte char split between data chunks                                         // 116\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration      // 117\n      if (this.bytes_remaining > 0) {                                                                                // 118\n        for (var j = 0; j < this.bytes_remaining; j++) {                                                             // 119\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];    // 120\n        }                                                                                                            // 121\n        this.string += this.temp_buffs[this.bytes_in_sequence].toString();                                           // 122\n        this.bytes_in_sequence = this.bytes_remaining = 0;                                                           // 123\n        i = i + j - 1;                                                                                               // 124\n      } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;                                                    // 126\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;                                                    // 127\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;                                                    // 128\n        if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split\n          for (var k = 0; k <= (buffer.length - 1 - i); k++) {                                                       // 130\n            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk\n          }                                                                                                          // 132\n          this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;                                       // 133\n          i = buffer.length - 1;                                                                                     // 134\n        } else {                                                                                                     // 135\n          this.string += buffer.slice(i, (i + this.bytes_in_sequence)).toString();                                   // 136\n          i = i + this.bytes_in_sequence - 1;                                                                        // 137\n        }                                                                                                            // 138\n      } else if (n === 0x22) { this.tState = START; this.onToken(STRING, this.string); this.string = undefined; }    // 139\n      else if (n === 0x5c) { this.tState = STRING2; }                                                                // 140\n      else if (n >= 0x20) { this.string += String.fromCharCode(n); }                                                 // 141\n      else { this.charError(buffer, i); }                                                                            // 142\n    }else if (this.tState === STRING2){ // After backslash                                                           // 143\n      n = buffer[i];                                                                                                 // 144\n      if(n === 0x22){ this.string += \"\\\"\"; this.tState = STRING1;                                                    // 145\n      }else if(n === 0x5c){ this.string += \"\\\\\"; this.tState = STRING1;                                              // 146\n      }else if(n === 0x2f){ this.string += \"\\/\"; this.tState = STRING1;                                              // 147\n      }else if(n === 0x62){ this.string += \"\\b\"; this.tState = STRING1;                                              // 148\n      }else if(n === 0x66){ this.string += \"\\f\"; this.tState = STRING1;                                              // 149\n      }else if(n === 0x6e){ this.string += \"\\n\"; this.tState = STRING1;                                              // 150\n      }else if(n === 0x72){ this.string += \"\\r\"; this.tState = STRING1;                                              // 151\n      }else if(n === 0x74){ this.string += \"\\t\"; this.tState = STRING1;                                              // 152\n      }else if(n === 0x75){ this.unicode = \"\"; this.tState = STRING3;                                                // 153\n      }else{                                                                                                         // 154\n        this.charError(buffer, i);                                                                                   // 155\n      }                                                                                                              // 156\n    }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes\n      n = buffer[i];                                                                                                 // 158\n      // 0-9 A-F a-f                                                                                                 // 159\n      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {                           // 160\n        this.unicode += String.fromCharCode(n);                                                                      // 161\n        if (this.tState++ === STRING6) {                                                                             // 162\n          this.string += String.fromCharCode(parseInt(this.unicode, 16));                                            // 163\n          this.unicode = undefined;                                                                                  // 164\n          this.tState = STRING1;                                                                                     // 165\n        }                                                                                                            // 166\n      } else {                                                                                                       // 167\n        this.charError(buffer, i);                                                                                   // 168\n      }                                                                                                              // 169\n    }else if (this.tState === NUMBER1){ // after minus                                                               // 170\n      n = buffer[i];                                                                                                 // 171\n      if (n === 0x30) { this.magnatude = 0; this.tState = NUMBER2; }                                                 // 172\n      else if (n > 0x30 && n < 0x40) { this.magnatude = n - 0x30; this.tState = NUMBER3; }                           // 173\n      else { this.charError(buffer, i); }                                                                            // 174\n    }else if (this.tState === NUMBER2){ // * After initial zero                                                      // 175\n      n = buffer[i];                                                                                                 // 176\n      if(n === 0x2e){ // .                                                                                           // 177\n        this.position = 0.1; this.tState = NUMBER4;                                                                  // 178\n      }else if(n === 0x65 ||  n === 0x45){ // e/E                                                                    // 179\n        this.exponent = 0; this.tState = NUMBER6;                                                                    // 180\n      }else{                                                                                                         // 181\n        this.tState = START;                                                                                         // 182\n        this.onToken(NUMBER, 0);                                                                                     // 183\n        this.magnatude = undefined;                                                                                  // 184\n        this.negative = undefined;                                                                                   // 185\n        i--;                                                                                                         // 186\n      }                                                                                                              // 187\n    }else if (this.tState === NUMBER3){ // * After digit (before period)                                             // 188\n      n = buffer[i];                                                                                                 // 189\n      if(n === 0x2e){ // .                                                                                           // 190\n        this.position = 0.1; this.tState = NUMBER4;                                                                  // 191\n      }else if(n === 0x65 || n === 0x45){ // e/E                                                                     // 192\n        this.exponent = 0; this.tState = NUMBER6;                                                                    // 193\n      }else{                                                                                                         // 194\n        if (n >= 0x30 && n < 0x40) { this.magnatude = this.magnatude * 10 + n - 0x30; }                              // 195\n        else {                                                                                                       // 196\n          this.tState = START;                                                                                       // 197\n          if (this.negative) {                                                                                       // 198\n            this.magnatude = -this.magnatude;                                                                        // 199\n            this.negative = undefined;                                                                               // 200\n          }                                                                                                          // 201\n          this.onToken(NUMBER, this.magnatude);                                                                      // 202\n          this.magnatude = undefined;                                                                                // 203\n          i--;                                                                                                       // 204\n        }                                                                                                            // 205\n      }                                                                                                              // 206\n    }else if (this.tState === NUMBER4){ // After period                                                              // 207\n      n = buffer[i];                                                                                                 // 208\n      if (n >= 0x30 && n < 0x40) { // 0-9                                                                            // 209\n        this.magnatude += this.position * (n - 0x30);                                                                // 210\n        this.position /= 10;                                                                                         // 211\n        this.tState = NUMBER5;                                                                                       // 212\n      } else { this.charError(buffer, i); }                                                                          // 213\n    }else if (this.tState === NUMBER5){ // * After digit (after period)                                              // 214\n      n = buffer[i];                                                                                                 // 215\n      if (n >= 0x30 && n < 0x40) { // 0-9                                                                            // 216\n        this.magnatude += this.position * (n - 0x30);                                                                // 217\n        this.position /= 10;                                                                                         // 218\n      }                                                                                                              // 219\n      else if (n === 0x65 || n === 0x45) { this.exponent = 0; this.tState = NUMBER6; } // E/e                        // 220\n      else {                                                                                                         // 221\n        this.tState = START;                                                                                         // 222\n        if (this.negative) {                                                                                         // 223\n          this.magnatude = -this.magnatude;                                                                          // 224\n          this.negative = undefined;                                                                                 // 225\n        }                                                                                                            // 226\n        this.onToken(NUMBER, this.negative ? -this.magnatude : this.magnatude);                                      // 227\n        this.magnatude = undefined;                                                                                  // 228\n        this.position = undefined;                                                                                   // 229\n        i--;                                                                                                         // 230\n      }                                                                                                              // 231\n    }else if (this.tState === NUMBER6){ // After E                                                                   // 232\n      n = buffer[i];                                                                                                 // 233\n      if (n === 0x2b || n === 0x2d) { // +/-                                                                         // 234\n        if (n === 0x2d) { this.negativeExponent = true; }                                                            // 235\n        this.tState = NUMBER7;                                                                                       // 236\n      }                                                                                                              // 237\n      else if (n >= 0x30 && n < 0x40) {                                                                              // 238\n        this.exponent = this.exponent * 10 + (n - 0x30);                                                             // 239\n        this.tState = NUMBER8;                                                                                       // 240\n      }                                                                                                              // 241\n      else { this.charError(buffer, i); }                                                                            // 242\n    }else if (this.tState === NUMBER7){ // After +/-                                                                 // 243\n      n = buffer[i];                                                                                                 // 244\n      if (n >= 0x30 && n < 0x40) { // 0-9                                                                            // 245\n        this.exponent = this.exponent * 10 + (n - 0x30);                                                             // 246\n        this.tState = NUMBER8;                                                                                       // 247\n      }                                                                                                              // 248\n      else { this.charError(buffer, i); }                                                                            // 249\n    }else if (this.tState === NUMBER8){ // * After digit (after +/-)                                                 // 250\n      n = buffer[i];                                                                                                 // 251\n      if (n >= 0x30 && n < 0x40) { // 0-9                                                                            // 252\n        this.exponent = this.exponent * 10 + (n - 0x30);                                                             // 253\n      }                                                                                                              // 254\n      else {                                                                                                         // 255\n        if (this.negativeExponent) {                                                                                 // 256\n          this.exponent = -this.exponent;                                                                            // 257\n          this.negativeExponent = undefined;                                                                         // 258\n        }                                                                                                            // 259\n        this.magnatude *= Math.pow(10, this.exponent);                                                               // 260\n        this.exponent = undefined;                                                                                   // 261\n        if (this.negative) {                                                                                         // 262\n          this.magnatude = -this.magnatude;                                                                          // 263\n          this.negative = undefined;                                                                                 // 264\n        }                                                                                                            // 265\n        this.tState = START;                                                                                         // 266\n        this.onToken(NUMBER, this.magnatude);                                                                        // 267\n        this.magnatude = undefined;                                                                                  // 268\n        i--;                                                                                                         // 269\n      }                                                                                                              // 270\n    }else if (this.tState === TRUE1){ // r                                                                           // 271\n      if (buffer[i] === 0x72) { this.tState = TRUE2; }                                                               // 272\n      else { this.charError(buffer, i); }                                                                            // 273\n    }else if (this.tState === TRUE2){ // u                                                                           // 274\n      if (buffer[i] === 0x75) { this.tState = TRUE3; }                                                               // 275\n      else { this.charError(buffer, i); }                                                                            // 276\n    }else if (this.tState === TRUE3){ // e                                                                           // 277\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); }                                     // 278\n      else { this.charError(buffer, i); }                                                                            // 279\n    }else if (this.tState === FALSE1){ // a                                                                          // 280\n      if (buffer[i] === 0x61) { this.tState = FALSE2; }                                                              // 281\n      else { this.charError(buffer, i); }                                                                            // 282\n    }else if (this.tState === FALSE2){ // l                                                                          // 283\n      if (buffer[i] === 0x6c) { this.tState = FALSE3; }                                                              // 284\n      else { this.charError(buffer, i); }                                                                            // 285\n    }else if (this.tState === FALSE3){ // s                                                                          // 286\n      if (buffer[i] === 0x73) { this.tState = FALSE4; }                                                              // 287\n      else { this.charError(buffer, i); }                                                                            // 288\n    }else if (this.tState === FALSE4){ // e                                                                          // 289\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); }                                   // 290\n      else { this.charError(buffer, i); }                                                                            // 291\n    }else if (this.tState === NULL1){ // u                                                                           // 292\n      if (buffer[i] === 0x75) { this.tState = NULL2; }                                                               // 293\n      else { this.charError(buffer, i); }                                                                            // 294\n    }else if (this.tState === NULL2){ // l                                                                           // 295\n      if (buffer[i] === 0x6c) { this.tState = NULL3; }                                                               // 296\n      else { this.charError(buffer, i); }                                                                            // 297\n    }else if (this.tState === NULL3){ // l                                                                           // 298\n      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); }                                     // 299\n      else { this.charError(buffer, i); }                                                                            // 300\n    }                                                                                                                // 301\n  }                                                                                                                  // 302\n};                                                                                                                   // 303\nproto.onToken = function (token, value) {                                                                            // 304\n  // Override this to get events                                                                                     // 305\n};                                                                                                                   // 306\n                                                                                                                     // 307\nproto.parseError = function (token, value) {                                                                         // 308\n  this.onError(new Error(\"Unexpected \" + toknam(token) + (value ? (\"(\" + JSON.stringify(value) + \")\") : \"\") + \" in state \" + toknam(this.state)));\n};                                                                                                                   // 310\nproto.onError = function (err) { throw err; };                                                                       // 311\nproto.push = function () {                                                                                           // 312\n  this.stack.push({value: this.value, key: this.key, mode: this.mode});                                              // 313\n};                                                                                                                   // 314\nproto.pop = function () {                                                                                            // 315\n  var value = this.value;                                                                                            // 316\n  var parent = this.stack.pop();                                                                                     // 317\n  this.value = parent.value;                                                                                         // 318\n  this.key = parent.key;                                                                                             // 319\n  this.mode = parent.mode;                                                                                           // 320\n  this.emit(value);                                                                                                  // 321\n  if (!this.mode) { this.state = VALUE; }                                                                            // 322\n};                                                                                                                   // 323\nproto.emit = function (value) {                                                                                      // 324\n  if (this.mode) { this.state = COMMA; }                                                                             // 325\n  this.onValue(value);                                                                                               // 326\n};                                                                                                                   // 327\nproto.onValue = function (value) {                                                                                   // 328\n  // Override me                                                                                                     // 329\n};                                                                                                                   // 330\nproto.onToken = function (token, value) {                                                                            // 331\n  //console.log(\"OnToken: state=%s token=%s %s\", toknam(this.state), toknam(token), value?JSON.stringify(value):\"\");\n  if(this.state === VALUE){                                                                                          // 333\n    if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){                 // 334\n      if (this.value) {                                                                                              // 335\n        this.value[this.key] = value;                                                                                // 336\n      }                                                                                                              // 337\n      this.emit(value);                                                                                              // 338\n    }else if(token === LEFT_BRACE){                                                                                  // 339\n      this.push();                                                                                                   // 340\n      if (this.value) {                                                                                              // 341\n        this.value = this.value[this.key] = {};                                                                      // 342\n      } else {                                                                                                       // 343\n        this.value = {};                                                                                             // 344\n      }                                                                                                              // 345\n      this.key = undefined;                                                                                          // 346\n      this.state = KEY;                                                                                              // 347\n      this.mode = OBJECT;                                                                                            // 348\n    }else if(token === LEFT_BRACKET){                                                                                // 349\n      this.push();                                                                                                   // 350\n      if (this.value) {                                                                                              // 351\n        this.value = this.value[this.key] = [];                                                                      // 352\n      } else {                                                                                                       // 353\n        this.value = [];                                                                                             // 354\n      }                                                                                                              // 355\n      this.key = 0;                                                                                                  // 356\n      this.mode = ARRAY;                                                                                             // 357\n      this.state = VALUE;                                                                                            // 358\n    }else if(token === RIGHT_BRACE){                                                                                 // 359\n      if (this.mode === OBJECT) {                                                                                    // 360\n        this.pop();                                                                                                  // 361\n      } else {                                                                                                       // 362\n        this.parseError(token, value);                                                                               // 363\n      }                                                                                                              // 364\n    }else if(token === RIGHT_BRACKET){                                                                               // 365\n      if (this.mode === ARRAY) {                                                                                     // 366\n        this.pop();                                                                                                  // 367\n      } else {                                                                                                       // 368\n        this.parseError(token, value);                                                                               // 369\n      }                                                                                                              // 370\n    }else{                                                                                                           // 371\n      this.parseError(token, value);                                                                                 // 372\n    }                                                                                                                // 373\n  }else if(this.state === KEY){                                                                                      // 374\n    if (token === STRING) {                                                                                          // 375\n      this.key = value;                                                                                              // 376\n      this.state = COLON;                                                                                            // 377\n    } else if (token === RIGHT_BRACE) {                                                                              // 378\n      this.pop();                                                                                                    // 379\n    } else {                                                                                                         // 380\n      this.parseError(token, value);                                                                                 // 381\n    }                                                                                                                // 382\n  }else if(this.state === COLON){                                                                                    // 383\n    if (token === COLON) { this.state = VALUE; }                                                                     // 384\n    else { this.parseError(token, value); }                                                                          // 385\n  }else if(this.state === COMMA){                                                                                    // 386\n    if (token === COMMA) {                                                                                           // 387\n      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }                                                   // 388\n      else if (this.mode === OBJECT) { this.state = KEY; }                                                           // 389\n                                                                                                                     // 390\n    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {    // 391\n      this.pop();                                                                                                    // 392\n    } else {                                                                                                         // 393\n      this.parseError(token, value);                                                                                 // 394\n    }                                                                                                                // 395\n  }else{                                                                                                             // 396\n    this.parseError(token, value);                                                                                   // 397\n  }                                                                                                                  // 398\n};                                                                                                                   // 399\n                                                                                                                     // 400\nmodule.exports = Parser;                                                                                             // 401\n                                                                                                                     // 402\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"through\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/through/package.json                                                                                 //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"through\";                                                                                            // 1\nexports.version = \"2.3.8\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"stream\",\"meteor-node-stubs/deps/stream\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/through/index.js                                                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar Stream = require('stream')                                                                                       // 1\n                                                                                                                     // 2\n// through                                                                                                           // 3\n//                                                                                                                   // 4\n// a stream that does nothing but re-emit the input.                                                                 // 5\n// useful for aggregating a series of changing but not ending streams into one stream)                               // 6\n                                                                                                                     // 7\nexports = module.exports = through                                                                                   // 8\nthrough.through = through                                                                                            // 9\n                                                                                                                     // 10\n//create a readable writable stream.                                                                                 // 11\n                                                                                                                     // 12\nfunction through (write, end, opts) {                                                                                // 13\n  write = write || function (data) { this.queue(data) }                                                              // 14\n  end = end || function () { this.queue(null) }                                                                      // 15\n                                                                                                                     // 16\n  var ended = false, destroyed = false, buffer = [], _ended = false                                                  // 17\n  var stream = new Stream()                                                                                          // 18\n  stream.readable = stream.writable = true                                                                           // 19\n  stream.paused = false                                                                                              // 20\n                                                                                                                     // 21\n//  stream.autoPause   = !(opts && opts.autoPause   === false)                                                       // 22\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)                                                         // 23\n                                                                                                                     // 24\n  stream.write = function (data) {                                                                                   // 25\n    write.call(this, data)                                                                                           // 26\n    return !stream.paused                                                                                            // 27\n  }                                                                                                                  // 28\n                                                                                                                     // 29\n  function drain() {                                                                                                 // 30\n    while(buffer.length && !stream.paused) {                                                                         // 31\n      var data = buffer.shift()                                                                                      // 32\n      if(null === data)                                                                                              // 33\n        return stream.emit('end')                                                                                    // 34\n      else                                                                                                           // 35\n        stream.emit('data', data)                                                                                    // 36\n    }                                                                                                                // 37\n  }                                                                                                                  // 38\n                                                                                                                     // 39\n  stream.queue = stream.push = function (data) {                                                                     // 40\n//    console.error(ended)                                                                                           // 41\n    if(_ended) return stream                                                                                         // 42\n    if(data === null) _ended = true                                                                                  // 43\n    buffer.push(data)                                                                                                // 44\n    drain()                                                                                                          // 45\n    return stream                                                                                                    // 46\n  }                                                                                                                  // 47\n                                                                                                                     // 48\n  //this will be registered as the first 'end' listener                                                              // 49\n  //must call destroy next tick, to make sure we're after any                                                        // 50\n  //stream piped from here.                                                                                          // 51\n  //this is only a problem if end is not emitted synchronously.                                                      // 52\n  //a nicer way to do this is to make sure this is the last listener for 'end'                                       // 53\n                                                                                                                     // 54\n  stream.on('end', function () {                                                                                     // 55\n    stream.readable = false                                                                                          // 56\n    if(!stream.writable && stream.autoDestroy)                                                                       // 57\n      process.nextTick(function () {                                                                                 // 58\n        stream.destroy()                                                                                             // 59\n      })                                                                                                             // 60\n  })                                                                                                                 // 61\n                                                                                                                     // 62\n  function _end () {                                                                                                 // 63\n    stream.writable = false                                                                                          // 64\n    end.call(stream)                                                                                                 // 65\n    if(!stream.readable && stream.autoDestroy)                                                                       // 66\n      stream.destroy()                                                                                               // 67\n  }                                                                                                                  // 68\n                                                                                                                     // 69\n  stream.end = function (data) {                                                                                     // 70\n    if(ended) return                                                                                                 // 71\n    ended = true                                                                                                     // 72\n    if(arguments.length) stream.write(data)                                                                          // 73\n    _end() // will emit or queue                                                                                     // 74\n    return stream                                                                                                    // 75\n  }                                                                                                                  // 76\n                                                                                                                     // 77\n  stream.destroy = function () {                                                                                     // 78\n    if(destroyed) return                                                                                             // 79\n    destroyed = true                                                                                                 // 80\n    ended = true                                                                                                     // 81\n    buffer.length = 0                                                                                                // 82\n    stream.writable = stream.readable = false                                                                        // 83\n    stream.emit('close')                                                                                             // 84\n    return stream                                                                                                    // 85\n  }                                                                                                                  // 86\n                                                                                                                     // 87\n  stream.pause = function () {                                                                                       // 88\n    if(stream.paused) return                                                                                         // 89\n    stream.paused = true                                                                                             // 90\n    return stream                                                                                                    // 91\n  }                                                                                                                  // 92\n                                                                                                                     // 93\n  stream.resume = function () {                                                                                      // 94\n    if(stream.paused) {                                                                                              // 95\n      stream.paused = false                                                                                          // 96\n      stream.emit('resume')                                                                                          // 97\n    }                                                                                                                // 98\n    drain()                                                                                                          // 99\n    //may have become paused again,                                                                                  // 100\n    //as drain emits 'data'.                                                                                         // 101\n    if(!stream.paused)                                                                                               // 102\n      stream.emit('drain')                                                                                           // 103\n    return stream                                                                                                    // 104\n  }                                                                                                                  // 105\n  return stream                                                                                                      // 106\n}                                                                                                                    // 107\n                                                                                                                     // 108\n                                                                                                                     // 109\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/modules/client.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.modules = exports, {\n  meteorInstall: meteorInstall,\n  Buffer: Buffer,\n  process: process\n});\n\n})();\n","servePath":"/packages/modules.js","sourceMap":{"version":3,"sources":["/packages/modules/client.js","/packages/modules/buffer.js","/packages/modules/css.js","/packages/modules/install-packages.js","/packages/modules/process.js","/packages/modules/stubs.js","node_modules/meteor/modules/node_modules/reify/lib/runtime.js","node_modules/meteor/modules/node_modules/reify/lib/entry.js","node_modules/meteor/modules/node_modules/reify/lib/utils.js","node_modules/dockerode/package.json","node_modules/dockerode/lib/docker.js","node_modules/dockerode/lib/container.js","node_modules/dockerode/lib/util.js","node_modules/dockerode/lib/exec.js","node_modules/dockerode/lib/image.js","node_modules/dockerode/lib/volume.js","node_modules/dockerode/lib/network.js","node_modules/meteor-node-stubs/deps/events.js","node_modules/meteor-node-stubs/deps/querystring.js","node_modules/meteor-node-stubs/deps/https.js","node_modules/meteor-node-stubs/deps/http.js","node_modules/meteor-node-stubs/deps/stream.js","node_modules/meteor-node-stubs/deps/buffer.js","node_modules/meteor-node-stubs/deps/url.js","node_modules/meteor-node-stubs/deps/fs.js","node_modules/meteor-node-stubs/deps/path.js","node_modules/meteor-node-stubs/deps/util.js","node_modules/meteor-node-stubs/deps/process.js","node_modules/meteor-node-stubs/deps/domain.js","node_modules/meteor-node-stubs/node_modules/events/package.json","node_modules/meteor-node-stubs/node_modules/events/events.js","node_modules/meteor-node-stubs/node_modules/querystring-es3/package.json","node_modules/meteor-node-stubs/node_modules/querystring-es3/index.js","node_modules/meteor-node-stubs/node_modules/querystring-es3/decode.js","node_modules/meteor-node-stubs/node_modules/querystring-es3/encode.js","node_modules/meteor-node-stubs/node_modules/https-browserify/package.json","node_modules/meteor-node-stubs/node_modules/https-browserify/index.js","node_modules/meteor-node-stubs/node_modules/http-browserify/package.json","node_modules/meteor-node-stubs/node_modules/http-browserify/index.js","node_modules/meteor-node-stubs/node_modules/http-browserify/lib/request.js","node_modules/meteor-node-stubs/node_modules/http-browserify/lib/response.js","node_modules/meteor-node-stubs/node_modules/http-browserify/node_modules/Base64/package.json","node_modules/meteor-node-stubs/node_modules/http-browserify/node_modules/Base64/base64.js","node_modules/meteor-node-stubs/node_modules/http-browserify/node_modules/inherits/package.json","node_modules/meteor-node-stubs/node_modules/http-browserify/node_modules/inherits/inherits_browser.js","node_modules/meteor-node-stubs/node_modules/stream-browserify/package.json","node_modules/meteor-node-stubs/node_modules/stream-browserify/index.js","node_modules/meteor-node-stubs/node_modules/stream-browserify/node_modules/inherits/package.json","node_modules/meteor-node-stubs/node_modules/stream-browserify/node_modules/inherits/inherits_browser.js","node_modules/meteor-node-stubs/node_modules/readable-stream/readable.js","node_modules/meteor-node-stubs/node_modules/readable-stream/lib/_stream_readable.js","node_modules/meteor-node-stubs/node_modules/readable-stream/lib/_stream_duplex.js","node_modules/meteor-node-stubs/node_modules/readable-stream/lib/_stream_writable.js","node_modules/meteor-node-stubs/node_modules/readable-stream/lib/_stream_transform.js","node_modules/meteor-node-stubs/node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/process-nextick-args/package.json","node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/process-nextick-args/index.js","node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/isarray/package.json","node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/isarray/index.js","node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/core-util-is/package.json","node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/inherits/package.json","node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/inherits/inherits_browser.js","node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/util-deprecate/package.json","node_modules/meteor-node-stubs/node_modules/readable-stream/node_modules/util-deprecate/browser.js","node_modules/meteor-node-stubs/node_modules/readable-stream/writable.js","node_modules/meteor-node-stubs/node_modules/readable-stream/duplex.js","node_modules/meteor-node-stubs/node_modules/readable-stream/transform.js","node_modules/meteor-node-stubs/node_modules/readable-stream/passthrough.js","node_modules/meteor-node-stubs/node_modules/buffer/package.json","node_modules/meteor-node-stubs/node_modules/buffer/index.js","node_modules/meteor-node-stubs/node_modules/buffer/node_modules/base64-js/package.json","node_modules/meteor-node-stubs/node_modules/buffer/node_modules/base64-js/lib/b64.js","node_modules/meteor-node-stubs/node_modules/buffer/node_modules/ieee754/package.json","node_modules/meteor-node-stubs/node_modules/buffer/node_modules/ieee754/index.js","node_modules/meteor-node-stubs/node_modules/buffer/node_modules/isarray/package.json","node_modules/meteor-node-stubs/node_modules/buffer/node_modules/isarray/index.js","node_modules/meteor-node-stubs/node_modules/util/package.json","node_modules/meteor-node-stubs/node_modules/util/util.js","node_modules/meteor-node-stubs/node_modules/util/support/isBuffer.js","node_modules/meteor-node-stubs/node_modules/util/node_modules/inherits/package.json","node_modules/meteor-node-stubs/node_modules/util/node_modules/inherits/inherits_browser.js","node_modules/meteor-node-stubs/node_modules/string_decoder/package.json","node_modules/meteor-node-stubs/node_modules/string_decoder/index.js","node_modules/meteor-node-stubs/node_modules/url/package.json","node_modules/meteor-node-stubs/node_modules/url/url.js","node_modules/meteor-node-stubs/node_modules/url/node_modules/punycode/package.json","node_modules/meteor-node-stubs/node_modules/url/node_modules/punycode/punycode.js","node_modules/meteor-node-stubs/node_modules/url/node_modules/querystring/package.json","node_modules/meteor-node-stubs/node_modules/url/node_modules/querystring/index.js","node_modules/meteor-node-stubs/node_modules/url/node_modules/querystring/decode.js","node_modules/meteor-node-stubs/node_modules/url/node_modules/querystring/encode.js","node_modules/meteor-node-stubs/node_modules/url/util.js","node_modules/meteor-node-stubs/node_modules/path-browserify/package.json","node_modules/meteor-node-stubs/node_modules/path-browserify/index.js","node_modules/meteor-node-stubs/node_modules/process/browser.js","node_modules/meteor-node-stubs/node_modules/domain-browser/package.json","node_modules/meteor-node-stubs/node_modules/domain-browser/index.js","node_modules/meteor-node-stubs/package.json","node_modules/meteor-node-stubs/index.js","node_modules/meteor-node-stubs/map.json","node_modules/docker-modem/package.json","node_modules/docker-modem/lib/modem.js","node_modules/docker-modem/lib/http_duplex.js","node_modules/follow-redirects/package.json","node_modules/follow-redirects/index.js","node_modules/underscore/package.json","node_modules/underscore/underscore.js","node_modules/readable-stream/package.json","node_modules/readable-stream/readable.js","node_modules/readable-stream/lib/_stream_readable.js","node_modules/readable-stream/lib/_stream_writable.js","node_modules/readable-stream/lib/_stream_duplex.js","node_modules/readable-stream/lib/_stream_transform.js","node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/isarray/package.json","node_modules/isarray/index.js","node_modules/core-util-is/package.json","node_modules/core-util-is/lib/util.js","node_modules/inherits/package.json","node_modules/inherits/inherits_browser.js","node_modules/string_decoder/package.json","node_modules/string_decoder/index.js","node_modules/debug/package.json","node_modules/debug/debug.js","node_modules/split-ca/package.json","node_modules/split-ca/index.js","node_modules/JSONStream/package.json","node_modules/JSONStream/index.js","node_modules/jsonparse/package.json","node_modules/jsonparse/jsonparse.js","node_modules/through/package.json","node_modules/through/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;ACPA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC9CA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC/lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACtoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACtHA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA,yH;;;;;;;;;;;ACAA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC1SA;AACA;AACA,yH;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACrFA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACdA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACxHA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC5DA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACvBA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC/HA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC/2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACngBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACzBA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACpBA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;ACLA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC3GA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACvBA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACnEA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA;AACA,yH;;;;;;;;;;;ACDA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;ACh7CA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC7GA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACpFA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;ACLA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC1kBA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACvBA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC7NA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC5tBA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AClhBA;AACA;AACA,yH;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AChBA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC3FA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACrEA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACxCA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC7UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AClDA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC7GA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;AC5gDA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACt9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AClYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC9CA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC3GA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACvBA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC7NA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACzIA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC3BA;AACA;AACA,yH;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACjMA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACjZA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H","file":"/packages/modules.js","sourcesContent":["require(\"./install-packages.js\");\nrequire(\"./stubs.js\");\nrequire(\"./buffer.js\");\nrequire(\"./process.js\");\nrequire(\"reify/lib/runtime\").enable(module.constructor);\n\nexports.addStyles = require(\"./css\").addStyles;\n","try {\n  Buffer = global.Buffer || require(\"buffer\").Buffer;\n} catch (noBuffer) {}\n","var doc = document;\nvar head = doc.getElementsByTagName(\"head\").item(0);\n\nexports.addStyles = function (css) {\n  var style = doc.createElement(\"style\");\n\n  style.setAttribute(\"type\", \"text/css\");\n\n  // https://msdn.microsoft.com/en-us/library/ms535871(v=vs.85).aspx\n  var internetExplorerSheetObject =\n    style.sheet || // Edge/IE11.\n    style.styleSheet; // Older IEs.\n\n  if (internetExplorerSheetObject) {\n    internetExplorerSheetObject.cssText = css;\n  } else {\n    style.appendChild(doc.createTextNode(css));\n  }\n\n  return head.appendChild(style);\n};\n","function install(name, mainModule) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n\n  if (mainModule) {\n    meteorDir[name + \".js\"] = [mainModule, function (require, e, module) {\n      module.exports = require(mainModule);\n    }];\n  } else {\n    // back compat with old Meteor packages\n    meteorDir[name + \".js\"] = function (r, e, module) {\n      module.exports = Package[name];\n    };\n  }\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"underscore\");\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"modules-runtime\");\ninstall(\"modules\", \"meteor/modules/client.js\");\ninstall(\"es5-shim\", \"meteor/es5-shim/client.js\");\ninstall(\"promise\", \"meteor/promise/client.js\");\ninstall(\"ecmascript-runtime\", \"meteor/ecmascript-runtime/runtime.js\");\ninstall(\"babel-compiler\");\ninstall(\"ecmascript\");\ninstall(\"base64\");\ninstall(\"ejson\");\ninstall(\"id-map\");\ninstall(\"ordered-dict\");\ninstall(\"tracker\");\ninstall(\"babel-runtime\");\ninstall(\"random\");\ninstall(\"mongo-id\");\ninstall(\"diff-sequence\");\ninstall(\"geojson-utils\", \"meteor/geojson-utils/main.js\");\ninstall(\"minimongo\");\ninstall(\"check\", \"meteor/check/match.js\");\ninstall(\"retry\");\ninstall(\"ddp-common\");\ninstall(\"reload\");\ninstall(\"ddp-client\");\ninstall(\"ddp\");\ninstall(\"ddp-server\");\ninstall(\"allow-deny\");\ninstall(\"insecure\");\ninstall(\"mongo\");\ninstall(\"blaze-html-templates\");\ninstall(\"reactive-var\");\ninstall(\"jquery\", \"meteor/jquery/main.js\");\ninstall(\"standard-minifier-css\");\ninstall(\"standard-minifier-js\");\ninstall(\"autopublish\");\ninstall(\"webapp\");\ninstall(\"livedata\");\ninstall(\"hot-code-push\");\ninstall(\"deps\");\ninstall(\"htmljs\");\ninstall(\"observe-sequence\");\ninstall(\"blaze\");\ninstall(\"spacebars\");\ninstall(\"templating\");\ninstall(\"launch-screen\");\ninstall(\"ui\");\ninstall(\"autoupdate\");\n","try {\n  // The application can run `npm install process` to provide its own\n  // process stub; otherwise this module will provide a partial stub.\n  process = global.process || require(\"process\");\n} catch (noProcess) {\n  process = {};\n}\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = process;\n      }\n    }\n  });\n} else {\n  process.platform = \"browser\";\n  process.nextTick = process.nextTick || Meteor._setImmediate;\n}\n\nif (typeof process.env !== \"object\") {\n  process.env = {};\n}\n\n_.extend(process.env, meteorEnv);\n","try {\n  // When meteor-node-stubs is installed in the application's root\n  // node_modules directory, requiring it here installs aliases for stubs\n  // for all Node built-in modules, such as fs, util, and http.\n  require(\"meteor-node-stubs\");\n} catch (noStubs) {}\n","var Entry = require(\"./entry.js\").Entry;\nvar utils = require(\"./utils.js\");\n\nexports.enable = function (Module) {\n  var Mp = Module.prototype;\n\n  if (typeof Mp.import === \"function\" &&\n      typeof Mp.export === \"function\") {\n    // If the Mp.{import,export} methods have already been\n    // defined, abandon reification immediately.\n    return Module;\n  }\n\n  // Platform-specific code should implement this method however\n  // appropriate. Module.prototype.resolve(id) should return an absolute\n  // version of the given module identifier, like require.resolve.\n  Mp.resolve = Mp.resolve || function resolve(id) {\n    throw new Error(\"Module.prototype.resolve not implemented\");\n  };\n\n  // Platform-specific code should find a way to call this method whenever\n  // the module system is about to return module.exports from require. This\n  // might happen more than once per module, in case of dependency cycles,\n  // so we want Module.prototype.runModuleSetters to run each time.\n  Mp.runModuleSetters = function runModuleSetters(valueToPassThrough) {\n    var entry = Entry.get(this.id);\n    if (entry) {\n      entry.runModuleSetters(this);\n    }\n\n    // Assignments to exported local variables get wrapped with calls to\n    // module.runModuleSetters, so module.runModuleSetters returns the\n    // valueToPassThrough parameter to allow the value of the original\n    // expression to pass through. For example,\n    //\n    //   export var a = 1;\n    //   console.log(a += 3);\n    //\n    // becomes\n    //\n    //   module.export(\"a\", () => a);\n    //   var a = 1;\n    //   console.log(module.runModuleSetters(a += 3));\n    //\n    // This ensures module.runModuleSetters runs immediately after the\n    // assignment, and does not interfere with the larger computation.\n    return valueToPassThrough;\n  };\n\n  function setESModule(module) {\n    var exports = module.exports;\n    if (exports && typeof exports === \"object\") {\n      exports.__esModule = true;\n    }\n  }\n\n  Mp.import = function (id, setters) {\n    var module = this;\n    setESModule(module);\n\n    var absoluteId = module.resolve(id);\n\n    if (setters && typeof setters === \"object\") {\n      var entry = Entry.getOrCreate(absoluteId);\n      entry.addSetters(module, setters);\n    }\n\n    var countBefore = entry && entry.runCount;\n    var exports = typeof module.require === \"function\"\n      ? module.require(absoluteId)\n      : require(absoluteId);\n\n    if (entry && entry.runCount === countBefore) {\n      // If require(absoluteId) didn't run any setters for this entry,\n      // perhaps because it's not the first time this module has been\n      // required, run the setters now using an object that passes as the\n      // real module object.\n      entry.runModuleSetters({\n        id: absoluteId,\n        exports: exports,\n        getExportByName: Mp.getExportByName\n      });\n    }\n  };\n\n  // Register getter functions for local variables in the scope of an\n  // export statement. The keys of the getters object are exported names,\n  // and the values are functions that return local values.\n  Mp.export = function (getters) {\n    var module = this;\n    setESModule(module);\n\n    if (utils.isPlainObject(getters)) {\n      Entry.getOrCreate(module.id).addGetters(getters);\n    }\n\n    if (module.loaded) {\n      // If the module has already been evaluated, then we need to trigger\n      // another round of entry.runModuleSetters calls, which begins by\n      // calling entry.runModuleGetters(module).\n      module.runModuleSetters();\n    }\n  };\n\n  // This method can be overridden by client code to implement custom export\n  // naming logic. The current implementation works well with Babel's\n  // __esModule convention.\n  Mp.getExportByName = function (name) {\n    var exports = this.exports;\n\n    if (name === \"*\") {\n      return exports;\n    }\n\n    if (name === \"default\" &&\n        ! (exports &&\n           typeof exports === \"object\" &&\n           exports.__esModule &&\n           \"default\" in exports)) {\n      return exports;\n    }\n\n    return exports && exports[name];\n  };\n\n  return Module;\n};\n","var hasOwn = Object.prototype.hasOwnProperty;\nvar entryMap = Object.create(null);\nvar utils = require(\"./utils.js\");\n\nfunction Entry(id) {\n  // Same as module.id for this module.\n  this.id = id;\n  // The number of times this.runModuleSetters has been called.\n  this.runCount = 0;\n  // Setters for assigning to local variables in parent modules.\n  this.setters = Object.create(null);\n  // Getters for local variables exported from this module.\n  this.getters = Object.create(null);\n}\n\nvar Ep = Entry.prototype;\n\nEntry.get = function (id) {\n  return entryMap[id] || null;\n};\n\nEntry.getOrCreate = function (id) {\n  return entryMap[id] = entryMap[id] || new Entry(id);\n};\n\nEp.addSetters = function (parent, setters) {\n  var entry = this;\n\n  Object.keys(setters).forEach(function (name) {\n    var setter = setters[name];\n    if (typeof setter === \"function\" &&\n        // Ignore any requests for the exports.__esModule property.\"\n        name !== \"__esModule\") {\n      setter.parent = parent;\n      (entry.setters[name] =\n       entry.setters[name] || []\n      ).push(setter);\n    }\n  });\n};\n\nEp.addGetters = function (getters) {\n  var entry = this;\n  Object.keys(getters).forEach(function (name) {\n    var getter = getters[name];\n    if (typeof getter === \"function\" &&\n        // Ignore any requests for the exports.__esModule property.\"\n        name !== \"__esModule\") {\n      // Should this throw if hasOwn.call(this.getters, name)?\n      entry.getters[name] = getter;\n    }\n  });\n};\n\nfunction runModuleSetters(module) {\n  var entry = entryMap[module.id];\n  if (entry) {\n    entry.runModuleSetters(module);\n  }\n}\n\nfunction runModuleGetters(module) {\n  var entry = entryMap[module.id];\n  return entry ? entry.runModuleGetters(module) : 0;\n}\n\nEp.runModuleGetters = function (module) {\n  var entry = this;\n  var changeCount = 0;\n\n  Object.keys(entry.getters).forEach(function (name) {\n    if (entry.runGetter(module, name)) {\n      ++changeCount;\n    }\n  });\n\n  return changeCount;\n};\n\n// Returns true iff the getter updated module.exports with a new value.\nEp.runGetter = function (module, name) {\n  if (! hasOwn.call(this.getters, name)) {\n    return false;\n  }\n\n  var getter = this.getters[name];\n  try {\n    var value = getter.call(module);\n  } catch (e) {}\n  var exports = module.exports;\n\n  if (! hasOwn.call(exports, name) ||\n      exports[name] !== value) {\n    // We update module.exports[name] with the current value so that\n    // CommonJS require calls remain consistent with module.import.\n    exports[name] = value;\n    return true;\n  }\n\n  return false;\n};\n\n// Called whenever module.exports might have changed, to trigger any\n// setters associated with the newly exported values.\nEp.runModuleSetters = function (module) {\n  var entry = this;\n  var names = Object.keys(entry.setters);\n\n  // Make sure module.exports is up to date before we call\n  // module.getExportByName(name).\n  entry.runModuleGetters(module);\n\n  // Invoke the given callback once for every (setter, value, name) triple\n  // that needs to be called. Note that forEachSetter does not call any\n  // setters itself, only the given callback.\n  function forEachSetter(callback, context) {\n    names.forEach(function (name) {\n      entry.setters[name].forEach(function (setter) {\n        var value = module.getExportByName(name);\n        if (name === \"*\") {\n          Object.keys(value).forEach(function (name) {\n            call(setter, value[name], name);\n          });\n        } else {\n          call(setter, value, name);\n        }\n      });\n    });\n\n    function call(setter, value, name) {\n      if (name === \"__esModule\") {\n        // Ignore setters asking for module.exports.__esModule.\n        return;\n      }\n\n      setter.last = setter.last || Object.create(null);\n\n      if (! hasOwn.call(setter.last, name) ||\n          setter.last[name] !== value) {\n        // Only invoke the callback if we have not called this setter\n        // (with a value of this name) before, or the current value is\n        // different from the last value we passed to this setter.\n        return callback.apply(context, arguments);\n      }\n    }\n  }\n\n  // Every three elements of this list form a (setter, value, name) triple\n  // that needs to be invoked.\n  var settersToCall = [];\n\n  // Lazily-initialized objects mapping parent module identifiers to\n  // relevant parent module objects and snapshots of their exports.\n  var relevantParents;\n  var parentSnapshots;\n\n  // Take snapshots of setter.parent.exports for any setters that we are\n  // planning to call, so that we can later determine if calling the\n  // setters modified any of those exports objects.\n  forEachSetter(function (setter, value, name) {\n    var parent = setter.parent;\n    parentSnapshots = parentSnapshots || Object.create(null);\n    if (! hasOwn.call(parentSnapshots, parent.id)) {\n      relevantParents = relevantParents || Object.create(null);\n      relevantParents[parent.id] = parent;\n      if (utils.isPlainObject(parent.exports)) {\n        // If parent.exports is an object, make a shallow clone of it so\n        // that we can see if it changes as a result of calling setters.\n        parentSnapshots[parent.id] = utils.assign({}, parent.exports);\n      } else {\n        // If parent.exports is not an object, the \"snapshot\" is just the\n        // value of parent.exports.\n        parentSnapshots[parent.id] = parent.exports;\n      }\n    }\n\n    // Push three elements at a time to avoid creating wrapper arrays for\n    // each (setter, value, name) triple. Note the i += 3 below.\n    settersToCall.push(setter, value, name);\n  });\n\n  // Now call all the setters that we decided we need to call.\n  for (var i = 0; i < settersToCall.length; i += 3) {\n    var setter = settersToCall[i];\n    var value = settersToCall[i + 1];\n    var name = settersToCall[i + 2];\n    setter.call(module, setter.last[name] = value, name);\n  }\n\n  ++entry.runCount;\n\n  if (! relevantParents) {\n    // If we never called takeSnapshot, then we can avoid checking\n    // relevantParents and parentSnapshots below.\n    return;\n  }\n\n  // If any of the setters updated the module.exports of a parent module,\n  // or updated local variables that are exported by that parent module,\n  // then we must re-run any setters registered by that parent module.\n  Object.keys(relevantParents).forEach(function (id) {\n    var parent = relevantParents[id];\n\n    if (runModuleGetters(parent) > 0) {\n      return runModuleSetters(parent);\n    }\n\n    var exports = parent.exports;\n    var snapshot = parentSnapshots[parent.id];\n    if (utils.shallowObjEqual(exports, snapshot)) {\n      // If parent.exports have not changed since we took the snapshot,\n      // then we do not need to run the parent's setters.\n      return;\n    }\n\n    runModuleSetters(parent);\n  });\n};\n\nexports.Entry = Entry;\n","var hasOwn = Object.prototype.hasOwnProperty;\nvar objToStr = Object.prototype.toString;\nvar objStr = objToStr.call({});\n\nfunction isPlainObject(value) {\n  return objToStr.call(value) === objStr;\n}\nexports.isPlainObject = isPlainObject;\n\nexports.assign = Object.assign || function (obj) {\n  var argc = arguments.length;\n  for (var i = 1; i < argc; ++i) {\n    var arg = arguments[i];\n    if (arg && typeof arg === \"object\") {\n      var keys = Object.keys(arg);\n      for (var k = 0; k < keys.length; ++k) {\n        var key = keys[k];\n        obj[key] = arg[key];\n      }\n    }\n  }\n  return obj;\n};\n\nexports.shallowObjEqual = function(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (! isPlainObject(a) ||\n      ! isPlainObject(b)) {\n    return false;\n  }\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  return aKeys.every(function (key) {\n    return hasOwn.call(b, key) &&\n      a[key] === b[key];\n  });\n};\n","exports.name = \"dockerode\";\nexports.version = \"2.2.10\";\nexports.main = \"./lib/docker\";\n","var EventEmitter = require('events').EventEmitter,\r\n  Modem = require('docker-modem'),\r\n  Container = require('./container'),\r\n  Image = require('./image'),\r\n  Volume = require('./volume'),\r\n  Network = require('./network'),\r\n  Exec = require('./exec'),\r\n  util = require('./util'),\r\n  extend = util.extend;\r\n\r\nvar Docker = function(opts) {\r\n  if (!(this instanceof Docker)) return new Docker(opts);\r\n  this.modem = new Modem(opts);\r\n};\r\n\r\n/**\r\n * Creates a new container\r\n * @param {Object}   opts     Create options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.createContainer = function(opts, callback) {\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/containers/create?',\r\n    method: 'POST',\r\n    options: opts,\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      404: 'no such container',\r\n      406: 'impossible to attach',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    if (err) return callback(err, data);\r\n    callback(err, self.getContainer(data.Id));\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a new image\r\n * @param {Object}   auth     Authentication (optional)\r\n * @param {Object}   opts     Create options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.createImage = function(auth, opts, callback) {\r\n  if (!callback && typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = auth;\r\n    auth = opts.authconfig || undefined;\r\n  }\r\n\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/images/create?',\r\n    method: 'POST',\r\n    options: opts,\r\n    authconfig: auth,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Load image\r\n * @param {String}   file     File\r\n * @param {Object}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.loadImage = function(file, opts, callback) {\r\n  if (!callback && typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = null;\r\n  }\r\n\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/images/load?',\r\n    method: 'POST',\r\n    options: opts,\r\n    file: file,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Import image from a tar archive\r\n * @param {String}   file     File\r\n * @param {Object}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.importImage = function(file, opts, callback) {\r\n  if (!callback && typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n\r\n  opts.fromSrc = '-'\r\n\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/images/create?',\r\n    method: 'POST',\r\n    options: opts,\r\n    file: file,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Verifies auth\r\n * @param {Object}   opts     Options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.checkAuth = function(opts, callback) {\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/auth',\r\n    method: 'POST',\r\n    options: opts,\r\n    statusCodes: {\r\n      200: true,\r\n      204: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Builds an image\r\n * @param {String}   file     File\r\n * @param {Object}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.buildImage = function(file, opts, callback) {\r\n  if (!callback && typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = null;\r\n  }\r\n\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/build?',\r\n    method: 'POST',\r\n    file: file,\r\n    options: opts,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  if (opts) {\r\n    if (opts.registryconfig) {\r\n      optsf.registryconfig = optsf.options.registryconfig;\r\n      delete optsf.options.registryconfig;\r\n    }\r\n\r\n    //undocumented?\r\n    if (opts.authconfig) {\r\n      optsf.authconfig = optsf.options.authconfig;\r\n      delete optsf.options.authconfig;\r\n    }\r\n  }\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Fetches a Container by ID\r\n * @param {String} id Container's ID\r\n */\r\nDocker.prototype.getContainer = function(id) {\r\n  return new Container(this.modem, id);\r\n};\r\n\r\n/**\r\n * Fetches an Image by name\r\n * @param {String} name Image's name\r\n */\r\nDocker.prototype.getImage = function(name) {\r\n  return new Image(this.modem, name);\r\n};\r\n\r\n/**\r\n * Fetches a Volume by name\r\n * @param {String} name Volume's name\r\n */\r\nDocker.prototype.getVolume = function(name) {\r\n  return new Volume(this.modem, name);\r\n};\r\n\r\n/**\r\n * Fetches a Network by id\r\n * @param {String} id network's id\r\n */\r\nDocker.prototype.getNetwork = function(id) {\r\n  return new Network(this.modem, id);\r\n};\r\n\r\n/**\r\n * Fetches an Exec instance by ID\r\n * @param {String} id Exec instance's ID\r\n */\r\nDocker.prototype.getExec = function(id) {\r\n  return new Exec(this.modem, id);\r\n};\r\n\r\n/**\r\n * Lists containers\r\n * @param {Options}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.listContainers = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/containers/json?',\r\n    method: 'GET',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Lists images\r\n * @param {Options}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.listImages = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/images/json?',\r\n    method: 'GET',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a new volume\r\n * @param {Object}   opts     Create options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.createVolume = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/volumes/create?',\r\n    method: 'POST',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    if (err) return args.callback(err, data);\r\n    args.callback(err, self.getVolume(data.Name));\r\n  });\r\n};\r\n\r\n/**\r\n * Lists volumes\r\n * @param {Options}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.listVolumes = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/volumes?',\r\n    method: 'GET',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a new network\r\n * @param {Object}   opts     Create options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.createNetwork = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/networks/create?',\r\n    method: 'POST',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      404: 'driver not found',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    if (err) return args.callback(err, data);\r\n    args.callback(err, self.getNetwork(data.Id));\r\n  });\r\n};\r\n\r\n/**\r\n * Lists networkss\r\n * @param {Options}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.listNetworks = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/networks?',\r\n    method: 'GET',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Search images\r\n * @param {Object}   opts     Options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.searchImages = function(opts, callback) {\r\n  var optsf = {\r\n    path: '/images/search?',\r\n    method: 'GET',\r\n    options: opts,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Info\r\n * @param  {Function} callback Callback with info\r\n */\r\nDocker.prototype.info = function(callback) {\r\n  var opts = {\r\n    path: '/info',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(opts, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Version\r\n * @param  {Function} callback Callback\r\n */\r\nDocker.prototype.version = function(callback) {\r\n  var opts = {\r\n    path: '/version',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(opts, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Ping\r\n * @param  {Function} callback Callback\r\n */\r\nDocker.prototype.ping = function(callback) {\r\n  if (!callback && typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = null;\r\n  }\r\n\r\n  var optsf = {\r\n    path: '/_ping',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Events\r\n * @param {Object}   opts     Events options, like 'since' (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.getEvents = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/events?',\r\n    method: 'GET',\r\n    options: args.opts,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Pull is a wrapper around parsing out the tag from the image\r\n * (which create image cannot do but run can for whatever reasons) and create image overloading.\r\n * @param  {String}   repoTag  Repository tag\r\n * @param  {Object}   opts     Options (optional)\r\n * @param  {Function} callback Callback\r\n * @param  {Object}   auth     Authentication (optional)\r\n * @return {Object}            Image\r\n */\r\nDocker.prototype.pull = function(repoTag, opts, callback, auth) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var imageSrc = util.parseRepositoryTag(repoTag);\r\n  args.opts.fromImage = imageSrc.repository;\r\n  args.opts.tag = imageSrc.tag;\r\n\r\n  var argsf = [args.opts, args.callback];\r\n  if (auth) {\r\n    argsf = [auth, args.opts, args.callback];\r\n  }\r\n  return this.createImage.apply(this, argsf);\r\n};\r\n\r\n/**\r\n * Like run command from Docker's CLI\r\n * @param  {String}   image         Image name to be used.\r\n * @param  {Array}   cmd           Command to run in array format.\r\n * @param  {Object}   streamo       Output stream\r\n * @param  {Object}   createOptions Container create options (optional)\r\n * @param  {Object}   startOptions  Container start options (optional)\r\n * @param  {Function} callback      Callback\r\n * @return {Object}                 EventEmitter\r\n */\r\nDocker.prototype.run = function(image, cmd, streamo, createOptions, startOptions, callback) {\r\n  if (!callback && typeof createOptions === 'function') {\r\n    callback = createOptions;\r\n    createOptions = {};\r\n    startOptions = {};\r\n  } else if (!callback && typeof startOptions === 'function') {\r\n    callback = startOptions;\r\n    startOptions = {};\r\n  }\r\n\r\n  var hub = new EventEmitter();\r\n\r\n  function handler(err, container) {\r\n    if (err) return callback(err, null, container);\r\n\r\n    hub.emit('container', container);\r\n\r\n    container.attach({\r\n      stream: true,\r\n      stdout: true,\r\n      stderr: true\r\n    }, function handler(err, stream) {\r\n      if (err) return callback(err, null, container);\r\n\r\n      hub.emit('stream', stream);\r\n\r\n      if (streamo) {\r\n        if (streamo instanceof Array) {\r\n          stream.on('end', function() {\r\n            try {\r\n              streamo[0].end();\r\n            } catch (e) {}\r\n            try {\r\n              streamo[1].end();\r\n            } catch (e) {}\r\n          });\r\n          container.modem.demuxStream(stream, streamo[0], streamo[1]);\r\n        } else {\r\n          stream.setEncoding('utf8');\r\n          stream.pipe(streamo, {\r\n            end: true\r\n          });\r\n        }\r\n      }\r\n\r\n      container.start(startOptions, function(err, data) {\r\n        if (err) return callback(err, data, container);\r\n\r\n        container.wait(function(err, data) {\r\n          hub.emit('data', data);\r\n          callback(err, data, container);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  var optsc = {\r\n    'Hostname': '',\r\n    'User': '',\r\n    'AttachStdin': false,\r\n    'AttachStdout': true,\r\n    'AttachStderr': true,\r\n    'Tty': true,\r\n    'OpenStdin': false,\r\n    'StdinOnce': false,\r\n    'Env': null,\r\n    'Cmd': cmd,\r\n    'Image': image,\r\n    'Volumes': {},\r\n    'VolumesFrom': []\r\n  };\r\n\r\n  extend(optsc, createOptions);\r\n\r\n  this.createContainer(optsc, handler);\r\n\r\n  return hub;\r\n};\r\n\r\nmodule.exports = Docker;\r\n","var extend = require('./util').extend,\r\n  Exec = require('./exec'),\r\n  util = require('./util');\r\n\r\n/**\r\n * Represents a Container\r\n * @param {Object} modem docker-modem\r\n * @param {String} id    Container's ID\r\n */\r\nvar Container = function(modem, id) {\r\n  this.modem = modem;\r\n  this.id = id;\r\n\r\n  this.defaultOptions = {\r\n    top: {},\r\n    start: {},\r\n    commit: {},\r\n    stop: {},\r\n    pause: {},\r\n    unpause: {},\r\n    restart: {},\r\n    resize: {},\r\n    attach: {},\r\n    remove: {},\r\n    copy: {},\r\n    kill: {},\r\n    exec: {},\r\n    rename: {},\r\n    log: {},\r\n    stats: {},\r\n    getArchive: {},\r\n    infoArchive: {},\r\n    putArchive: {},\r\n    update: {}\r\n  };\r\n};\r\n\r\n/**\r\n * Inspect\r\n * @param  {Options}  opts     Options (optional)\r\n * @param  {Function} callback Callback, if supplied will query Docker.\r\n * @return {Object}            ID only and only if callback isn't supplied.\r\n */\r\nContainer.prototype.inspect = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  if (typeof args.callback === 'function') {\r\n    var optsf = {\r\n      path: '/containers/' + this.id + '/json?',\r\n      method: 'GET',\r\n      options: args.opts,\r\n      statusCodes: {\r\n        200: true,\r\n        404: 'no such container',\r\n        500: 'server error'\r\n      }\r\n    };\r\n\r\n    this.modem.dial(optsf, function(err, data) {\r\n      args.callback(err, data);\r\n    });\r\n  } else {\r\n    return JSON.stringify({\r\n      id: this.id\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Rename\r\n * @param  {Object}   opts     Rename options\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.rename = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.rename);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/rename?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      204: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Update\r\n * @param  {Object}   opts     Update options\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.update = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.update);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/update',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      204: true,\r\n      400: 'bad parameter',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Top\r\n * @param  {Object}   Options like 'ps_args' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.top = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.top);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/top?',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Containers changes\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.changes = function(callback) {\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/changes',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Export\r\n * @param  {Function} callback Callback with the octet-stream.\r\n */\r\nContainer.prototype.export = function(callback) {\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/export',\r\n    method: 'GET',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Start\r\n * @param  {Object}   opts     Container start options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.start = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.start);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/start',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      304: 'container already started',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Pause\r\n * @param  {Object}   opts     Pause options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.pause = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.pause);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/pause',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Unpause\r\n * @param  {Object}   opts     Unpause options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.unpause = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.unpause);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/unpause',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Setup an exec call to a running container\r\n *\r\n * @param {object} opts\r\n * @param {function} callback\r\n */\r\nContainer.prototype.exec = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.exec);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/exec',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  var self = this;\r\n  this.modem.dial(optsf, function(err, data) {\r\n    if (err) return args.callback(err, data);\r\n    args.callback(err, new Exec(self.modem, data.Id));\r\n  });\r\n};\r\n\r\n/**\r\n * Commit\r\n * @param  {Object}   opts     Commit options like 'Hostname' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.commit = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.commit);\r\n\r\n  args.opts.container = this.id;\r\n\r\n  var optsf = {\r\n    path: '/commit?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Stop\r\n * @param  {Object}   opts     Container stop options, like 't' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.stop = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.stop);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/stop?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      304: 'container already stopped',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Restart\r\n * @param  {Object}   opts     Container restart options, like 't' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.restart = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.restart);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/restart',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Kill\r\n * @param  {Object}   opts     Container kill options, like 'signal' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.kill = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.kill);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/kill?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Container resize\r\n * @param  {[type]}   opts     Resize options. (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.resize = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.resize);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/resize?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Attach\r\n * @param  {Object}   opts     Attach options, like 'logs' (optional)\r\n * @param  {Function} callback Callback with stream.\r\n */\r\nContainer.prototype.attach = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.attach);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/attach?',\r\n    method: 'POST',\r\n    isStream: true,\r\n    hijack: args.opts.hijack,\r\n    openStdin: args.opts.stdin,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, stream) {\r\n    args.callback(err, stream);\r\n  });\r\n};\r\n\r\n/**\r\n * Waits for a container to end.\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.wait = function(callback) {\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/wait',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Removes a container\r\n * @param  {Object}   opts     Remove options, like 'force' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.remove = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.remove);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '?',\r\n    method: 'DELETE',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      400: 'bad parameter',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Copy (WARNING: DEPRECATED since RAPI v1.20)\r\n * @param  {Object}   opts     Copy options, like 'Resource' (optional)\r\n * @param  {Function} callback Callback with stream.\r\n */\r\nContainer.prototype.copy = function(opts, callback) {\r\n  console.log('container.copy is deprecated since Docker v1.8.x');\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.copy);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/copy',\r\n    method: 'POST',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * getArchive\r\n * @param  {Object}   opts     Archive options, like 'path'\r\n * @param  {Function} callback Callback with stream.\r\n */\r\nContainer.prototype.getArchive = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.getArchive);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/archive?',\r\n    method: 'GET',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'client error, bad parameters',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * infoArchive\r\n * @param  {Object}   opts     Archive options, like 'path'\r\n * @param  {Function} callback Callback with stream.\r\n */\r\nContainer.prototype.infoArchive = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.infoArchive);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/archive?',\r\n    method: 'HEAD',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'client error, bad parameters',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * putArchive\r\n * @param  {Object}   opts     Archive options, like 'path'\r\n * @param  {Function} callback Callback with stream.\r\n */\r\nContainer.prototype.putArchive = function(file, opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.putArchive);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/archive?',\r\n    method: 'PUT',\r\n    file: file,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'client error, bad parameters',\r\n      403: 'client error, permission denied',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Container logs\r\n * @param  {Object}   opts     Logs options. (optional)\r\n * @param  {Function} callback Callback with data\r\n */\r\nContainer.prototype.logs = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.log);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/logs?',\r\n    method: 'GET',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Container stats\r\n * @param  {Object}   opts     Stats options. (optional)\r\n * @param  {Function} callback Callback with data\r\n */\r\nContainer.prototype.stats = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.stats);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/stats?',\r\n    method: 'GET',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\nmodule.exports = Container;\r\n","// https://github.com/HenrikJoreteg/extend-object/blob/v0.1.0/extend-object.js\n\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\n\nmodule.exports.extend = function(obj) {\n  each.call(slice.call(arguments, 1), function(source) {\n    if (source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n};\n\nmodule.exports.processArgs = function(opts, callback, defaultOpts) {\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n  return {\n    callback: callback,\n    opts: module.exports.extend({}, defaultOpts, opts)\n  };\n};\n\n/**\n * Parse the given repo tag name (as a string) and break it out into repo/tag pair.\n * // if given the input http://localhost:8080/woot:latest\n * {\n *   repository: 'http://localhost:8080/woot',\n *   tag: 'latest'\n * }\n * @param {String} input Input e.g: 'repo/foo', 'ubuntu', 'ubuntu:latest'\n * @return {Object} input parsed into the repo and tag.\n */\nmodule.exports.parseRepositoryTag = function(input) {\n  var separatorPos;\n  var digestPos = input.indexOf('@');\n  var colonPos = input.lastIndexOf(':');\n  // @ symbol is more important\n  if (digestPos >= 0) {\n    separatorPos = digestPos;\n  } else if (colonPos >= 0) {\n    separatorPos = colonPos;\n  } else {\n    // no colon nor @\n    return {\n      repository: input\n    };\n  }\n\n  // last colon is either the tag (or part of a port designation)\n  var tag = input.slice(separatorPos + 1);\n\n  // if it contains a / its not a tag and is part of the url\n  if (tag.indexOf('/') === -1) {\n    return {\n      repository: input.slice(0, separatorPos),\n      tag: tag\n    };\n  }\n\n  return {\n    repository: input\n  };\n};\n","var util = require('./util');\r\n\r\n/**\r\n * Represents an Exec\r\n * @param {Object} modem docker-modem\r\n * @param {String} id    Exec's ID\r\n */\r\nvar Exec = function(modem, id) {\r\n  this.modem = modem;\r\n  this.id = id;\r\n};\r\n\r\n/**\r\n * Start the exec call that was setup.\r\n *\r\n * @param {object} options\r\n * @param {function} callback\r\n */\r\nExec.prototype.start = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/exec/' + this.id + '/start',\r\n    method: 'POST',\r\n    isStream: true,\r\n    hijack: args.opts.hijack,\r\n    openStdin: args.opts.stdin,\r\n    statusCodes: {\r\n      200: true,\r\n      204: true,\r\n      404: 'no such exec',\r\n      409: 'container stopped/paused',\r\n      500: 'container not running'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Resize the exec call that was setup.\r\n *\r\n * @param {object} options\r\n * @param {function} callback\r\n */\r\nExec.prototype.resize = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/exec/' + this.id + '/resize?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such exec',\r\n      500: 'container not running'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Get low-level information about the exec call.\r\n *\r\n * @param {function} callback\r\n */\r\nExec.prototype.inspect = function(callback) {\r\n  var optsf = {\r\n    path: '/exec/' + this.id + '/json',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such exec',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n\r\nmodule.exports = Exec;\r\n","var util = require('./util');\r\n\r\n/**\r\n * Represents an image\r\n * @param {Object} modem docker-modem\r\n * @param {String} name  Image's name\r\n */\r\nvar Image = function(modem, name) {\r\n  this.modem = modem;\r\n  this.name = name;\r\n};\r\n\r\n/**\r\n * Inspect\r\n * @param  {Function} callback Callback, if specified Docker will be queried.\r\n * @return {Object}            Name only if callback isn't specified.\r\n */\r\nImage.prototype.inspect = function(callback) {\r\n  if (typeof callback === 'function') {\r\n    var opts = {\r\n      path: '/images/' + this.name + '/json',\r\n      method: 'GET',\r\n      statusCodes: {\r\n        200: true,\r\n        404: 'no such image',\r\n        500: 'server error'\r\n      }\r\n    };\r\n\r\n    this.modem.dial(opts, function(err, data) {\r\n      callback(err, data);\r\n    });\r\n  } else {\r\n    return JSON.stringify({name: this.name});\r\n  }\r\n};\r\n\r\n/**\r\n * History\r\n * @param  {Function} callback Callback\r\n */\r\nImage.prototype.history = function(callback) {\r\n  var opts = {\r\n    path: '/images/' + this.name + '/history',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such image',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(opts, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Get\r\n * @param  {Function} callback Callback with data stream.\r\n */\r\nImage.prototype.get = function(callback) {\r\n  var opts = {\r\n    path: '/images/' + this.name + '/get',\r\n    method: 'GET',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(opts, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Push\r\n * @param  {Object}   opts     Push options, like 'registry' (optional)\r\n * @param  {Function} callback Callback with stream.\r\n * @param  {Object}   auth     Registry authentication\r\n */\r\nImage.prototype.push = function(opts, callback, auth) {\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/images/' + this.name + '/push?',\r\n    method: 'POST',\r\n    options: opts,\r\n    authconfig: opts.authconfig || auth,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such image',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  delete optsf.options.authconfig;\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Tag\r\n * @param  {Object}   opts     Tag options, like 'repo' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nImage.prototype.tag = function(opts, callback) {\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/images/' + this.name + '/tag?',\r\n    method: 'POST',\r\n    options: opts,\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      400: 'bad parameter',\r\n      404: 'no such image',\r\n      409: 'conflict',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Removes the image\r\n * @param  {[Object]}   opts     Remove options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nImage.prototype.remove = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n\r\n  var optsf = {\r\n    path: '/images/' + this.name + '?',\r\n    method: 'DELETE',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such image',\r\n      409: 'conflict',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\nmodule.exports = Image;\r\n","var util = require('./util');\r\n\r\n/**\r\n * Represents an volume\r\n * @param {Object} modem docker-modem\r\n * @param {String} name  Volume's name\r\n */\r\nvar Volume = function(modem, name) {\r\n  this.modem = modem;\r\n  this.name = name;\r\n};\r\n\r\n/**\r\n * Inspect\r\n * @param  {Function} callback Callback, if specified Docker will be queried.\r\n * @return {Object}            Name only if callback isn't specified.\r\n */\r\nVolume.prototype.inspect = function(callback) {\r\n  if (typeof callback === 'function') {\r\n    var opts = {\r\n      path: '/volumes/' + this.name,\r\n      method: 'GET',\r\n      statusCodes: {\r\n        200: true,\r\n        404: 'no such volume',\r\n        500: 'server error'\r\n      }\r\n    };\r\n\r\n    this.modem.dial(opts, function(err, data) {\r\n      callback(err, data);\r\n    });\r\n  } else {\r\n    return JSON.stringify({name: this.name});\r\n  }\r\n};\r\n\r\n/**\r\n * Removes the volume\r\n * @param  {[Object]}   opts     Remove options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nVolume.prototype.remove = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/volumes/' + this.name,\r\n    method: 'DELETE',\r\n    statusCodes: {\r\n      204: true,\r\n      404: 'no such volume',\r\n      409: 'conflict',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\nmodule.exports = Volume;\r\n","var util = require('./util');\r\n\r\n/**\r\n * Represents an network\r\n * @param {Object} modem docker-modem\r\n * @param {String} id  Network's id\r\n */\r\nvar Network = function(modem, id) {\r\n  this.modem = modem;\r\n  this.id = id;\r\n};\r\n\r\n/**\r\n * Inspect\r\n * @param  {Function} callback Callback, if specified Docker will be queried.\r\n * @return {Object}            Id only if callback isn't specified.\r\n */\r\nNetwork.prototype.inspect = function(callback) {\r\n  if (typeof callback === 'function') {\r\n    var opts = {\r\n      path: '/networks/' + this.id,\r\n      method: 'GET',\r\n      statusCodes: {\r\n        200: true,\r\n        404: 'no such network',\r\n        500: 'server error'\r\n      }\r\n    };\r\n\r\n    this.modem.dial(opts, function(err, data) {\r\n      callback(err, data);\r\n    });\r\n  } else {\r\n    return JSON.stringify({Id: this.id});\r\n  }\r\n};\r\n\r\n/**\r\n * Removes the network\r\n * @param  {[Object]}   opts     Remove options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nNetwork.prototype.remove = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/networks/' + this.id,\r\n    method: 'DELETE',\r\n    statusCodes: {\r\n      200: true,\r\n      204: true,\r\n      404: 'no such network',\r\n      409: 'conflict',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Connects a container to a network\r\n * @param  {[Object]}   opts     Connect options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nNetwork.prototype.connect = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/networks/' + this.id + '/connect',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      201: true,\r\n      404: 'network or container is not found',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Disconnects a container from a network\r\n * @param  {[Object]}   opts     Disconnect options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nNetwork.prototype.disconnect = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/networks/' + this.id + '/disconnect',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      201: true,\r\n      404: 'network or container is not found',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n\r\n\r\n\r\nmodule.exports = Network;\r\n","require(\"events/\");\n","require(\"querystring-es3/\");\n","require(\"https-browserify\");\n","require(\"http-browserify\");\n","require(\"stream-browserify\");\n","require(\"buffer/\");\n","require(\"url/\");\n","","require(\"path-browserify\");\n","require(\"util/util.js\");\n","require(\"process/browser.js\");\n","require(\"domain-browser\");\n","exports.name = \"events\";\nexports.version = \"1.1.0\";\nexports.main = \"./events.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","exports.name = \"querystring-es3\";\nexports.version = \"0.2.1\";\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","exports.name = \"https-browserify\";\nexports.version = \"0.0.1\";\nexports.main = \"index.js\";\n","var http = require('http');\n\nvar https = module.exports;\n\nfor (var key in http) {\n    if (http.hasOwnProperty(key)) https[key] = http[key];\n};\n\nhttps.request = function (params, cb) {\n    if (!params) params = {};\n    params.scheme = 'https';\n    params.protocol = 'https:';\n    return http.request.call(this, params, cb);\n}\n","exports.name = \"http-browserify\";\nexports.version = \"1.7.0\";\nexports.main = \"index.js\";\n","var http = module.exports;\nvar EventEmitter = require('events').EventEmitter;\nvar Request = require('./lib/request');\nvar url = require('url')\n\nhttp.request = function (params, cb) {\n    if (typeof params === 'string') {\n        params = url.parse(params)\n    }\n    if (!params) params = {};\n    if (!params.host && !params.port) {\n        params.port = parseInt(window.location.port, 10);\n    }\n    if (!params.host && params.hostname) {\n        params.host = params.hostname;\n    }\n\n    if (!params.protocol) {\n        if (params.scheme) {\n            params.protocol = params.scheme + ':';\n        } else {\n            params.protocol = window.location.protocol;\n        }\n    }\n\n    if (!params.host) {\n        params.host = window.location.hostname || window.location.host;\n    }\n    if (/:/.test(params.host)) {\n        if (!params.port) {\n            params.port = params.host.split(':')[1];\n        }\n        params.host = params.host.split(':')[0];\n    }\n    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;\n    \n    var req = new Request(new xhrHttp, params);\n    if (cb) req.on('response', cb);\n    return req;\n};\n\nhttp.get = function (params, cb) {\n    params.method = 'GET';\n    var req = http.request(params, cb);\n    req.end();\n    return req;\n};\n\nhttp.Agent = function () {};\nhttp.Agent.defaultMaxSockets = 4;\n\nvar xhrHttp = (function () {\n    if (typeof window === 'undefined') {\n        throw new Error('no window object present');\n    }\n    else if (window.XMLHttpRequest) {\n        return window.XMLHttpRequest;\n    }\n    else if (window.ActiveXObject) {\n        var axs = [\n            'Msxml2.XMLHTTP.6.0',\n            'Msxml2.XMLHTTP.3.0',\n            'Microsoft.XMLHTTP'\n        ];\n        for (var i = 0; i < axs.length; i++) {\n            try {\n                var ax = new(window.ActiveXObject)(axs[i]);\n                return function () {\n                    if (ax) {\n                        var ax_ = ax;\n                        ax = null;\n                        return ax_;\n                    }\n                    else {\n                        return new(window.ActiveXObject)(axs[i]);\n                    }\n                };\n            }\n            catch (e) {}\n        }\n        throw new Error('ajax not supported in this browser')\n    }\n    else {\n        throw new Error('ajax not supported in this browser');\n    }\n})();\n\nhttp.STATUS_CODES = {\n    100 : 'Continue',\n    101 : 'Switching Protocols',\n    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918\n    200 : 'OK',\n    201 : 'Created',\n    202 : 'Accepted',\n    203 : 'Non-Authoritative Information',\n    204 : 'No Content',\n    205 : 'Reset Content',\n    206 : 'Partial Content',\n    207 : 'Multi-Status',               // RFC 4918\n    300 : 'Multiple Choices',\n    301 : 'Moved Permanently',\n    302 : 'Moved Temporarily',\n    303 : 'See Other',\n    304 : 'Not Modified',\n    305 : 'Use Proxy',\n    307 : 'Temporary Redirect',\n    400 : 'Bad Request',\n    401 : 'Unauthorized',\n    402 : 'Payment Required',\n    403 : 'Forbidden',\n    404 : 'Not Found',\n    405 : 'Method Not Allowed',\n    406 : 'Not Acceptable',\n    407 : 'Proxy Authentication Required',\n    408 : 'Request Time-out',\n    409 : 'Conflict',\n    410 : 'Gone',\n    411 : 'Length Required',\n    412 : 'Precondition Failed',\n    413 : 'Request Entity Too Large',\n    414 : 'Request-URI Too Large',\n    415 : 'Unsupported Media Type',\n    416 : 'Requested Range Not Satisfiable',\n    417 : 'Expectation Failed',\n    418 : 'I\\'m a teapot',              // RFC 2324\n    422 : 'Unprocessable Entity',       // RFC 4918\n    423 : 'Locked',                     // RFC 4918\n    424 : 'Failed Dependency',          // RFC 4918\n    425 : 'Unordered Collection',       // RFC 4918\n    426 : 'Upgrade Required',           // RFC 2817\n    428 : 'Precondition Required',      // RFC 6585\n    429 : 'Too Many Requests',          // RFC 6585\n    431 : 'Request Header Fields Too Large',// RFC 6585\n    500 : 'Internal Server Error',\n    501 : 'Not Implemented',\n    502 : 'Bad Gateway',\n    503 : 'Service Unavailable',\n    504 : 'Gateway Time-out',\n    505 : 'HTTP Version Not Supported',\n    506 : 'Variant Also Negotiates',    // RFC 2295\n    507 : 'Insufficient Storage',       // RFC 4918\n    509 : 'Bandwidth Limit Exceeded',\n    510 : 'Not Extended',               // RFC 2774\n    511 : 'Network Authentication Required' // RFC 6585\n};","var Stream = require('stream');\nvar Response = require('./response');\nvar Base64 = require('Base64');\nvar inherits = require('inherits');\n\nvar Request = module.exports = function (xhr, params) {\n    var self = this;\n    self.writable = true;\n    self.xhr = xhr;\n    self.body = [];\n    \n    self.uri = (params.protocol || 'http:') + '//'\n        + params.host\n        + (params.port ? ':' + params.port : '')\n        + (params.path || '/')\n    ;\n    \n    if (typeof params.withCredentials === 'undefined') {\n        params.withCredentials = true;\n    }\n\n    try { xhr.withCredentials = params.withCredentials }\n    catch (e) {}\n    \n    if (params.responseType) try { xhr.responseType = params.responseType }\n    catch (e) {}\n    \n    xhr.open(\n        params.method || 'GET',\n        self.uri,\n        true\n    );\n\n    xhr.onerror = function(event) {\n        self.emit('error', new Error('Network error'));\n    };\n\n    self._headers = {};\n    \n    if (params.headers) {\n        var keys = objectKeys(params.headers);\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            if (!self.isSafeRequestHeader(key)) continue;\n            var value = params.headers[key];\n            self.setHeader(key, value);\n        }\n    }\n    \n    if (params.auth) {\n        //basic auth\n        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));\n    }\n\n    var res = new Response;\n    res.on('close', function () {\n        self.emit('close');\n    });\n    \n    res.on('ready', function () {\n        self.emit('response', res);\n    });\n\n    res.on('error', function (err) {\n        self.emit('error', err);\n    });\n    \n    xhr.onreadystatechange = function () {\n        // Fix for IE9 bug\n        // SCRIPT575: Could not complete the operation due to error c00c023f\n        // It happens when a request is aborted, calling the success callback anyway with readyState === 4\n        if (xhr.__aborted) return;\n        res.handle(xhr);\n    };\n};\n\ninherits(Request, Stream);\n\nRequest.prototype.setHeader = function (key, value) {\n    this._headers[key.toLowerCase()] = value\n};\n\nRequest.prototype.getHeader = function (key) {\n    return this._headers[key.toLowerCase()]\n};\n\nRequest.prototype.removeHeader = function (key) {\n    delete this._headers[key.toLowerCase()]\n};\n\nRequest.prototype.write = function (s) {\n    this.body.push(s);\n};\n\nRequest.prototype.destroy = function (s) {\n    this.xhr.__aborted = true;\n    this.xhr.abort();\n    this.emit('close');\n};\n\nRequest.prototype.end = function (s) {\n    if (s !== undefined) this.body.push(s);\n\n    var keys = objectKeys(this._headers);\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = this._headers[key];\n        if (isArray(value)) {\n            for (var j = 0; j < value.length; j++) {\n                this.xhr.setRequestHeader(key, value[j]);\n            }\n        }\n        else this.xhr.setRequestHeader(key, value)\n    }\n\n    if (this.body.length === 0) {\n        this.xhr.send('');\n    }\n    else if (typeof this.body[0] === 'string') {\n        this.xhr.send(this.body.join(''));\n    }\n    else if (isArray(this.body[0])) {\n        var body = [];\n        for (var i = 0; i < this.body.length; i++) {\n            body.push.apply(body, this.body[i]);\n        }\n        this.xhr.send(body);\n    }\n    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {\n        var len = 0;\n        for (var i = 0; i < this.body.length; i++) {\n            len += this.body[i].length;\n        }\n        var body = new(this.body[0].constructor)(len);\n        var k = 0;\n        \n        for (var i = 0; i < this.body.length; i++) {\n            var b = this.body[i];\n            for (var j = 0; j < b.length; j++) {\n                body[k++] = b[j];\n            }\n        }\n        this.xhr.send(body);\n    }\n    else if (isXHR2Compatible(this.body[0])) {\n        this.xhr.send(this.body[0]);\n    }\n    else {\n        var body = '';\n        for (var i = 0; i < this.body.length; i++) {\n            body += this.body[i].toString();\n        }\n        this.xhr.send(body);\n    }\n};\n\n// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html\nRequest.unsafeHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"cookie\",\n    \"cookie2\",\n    \"content-transfer-encoding\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"user-agent\",\n    \"via\"\n];\n\nRequest.prototype.isSafeRequestHeader = function (headerName) {\n    if (!headerName) return false;\n    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    return keys;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nvar indexOf = function (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (xs[i] === x) return i;\n    }\n    return -1;\n};\n\nvar isXHR2Compatible = function (obj) {\n    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;\n    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;\n    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;\n};\n","var Stream = require('stream');\nvar util = require('util');\n\nvar Response = module.exports = function (res) {\n    this.offset = 0;\n    this.readable = true;\n};\n\nutil.inherits(Response, Stream);\n\nvar capable = {\n    streaming : true,\n    status2 : true\n};\n\nfunction parseHeaders (res) {\n    var lines = res.getAllResponseHeaders().split(/\\r?\\n/);\n    var headers = {};\n    for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        if (line === '') continue;\n        \n        var m = line.match(/^([^:]+):\\s*(.*)/);\n        if (m) {\n            var key = m[1].toLowerCase(), value = m[2];\n            \n            if (headers[key] !== undefined) {\n            \n                if (isArray(headers[key])) {\n                    headers[key].push(value);\n                }\n                else {\n                    headers[key] = [ headers[key], value ];\n                }\n            }\n            else {\n                headers[key] = value;\n            }\n        }\n        else {\n            headers[line] = true;\n        }\n    }\n    return headers;\n}\n\nResponse.prototype.getResponse = function (xhr) {\n    var respType = String(xhr.responseType).toLowerCase();\n    if (respType === 'blob') return xhr.responseBlob || xhr.response;\n    if (respType === 'arraybuffer') return xhr.response;\n    return xhr.responseText;\n}\n\nResponse.prototype.getHeader = function (key) {\n    return this.headers[key.toLowerCase()];\n};\n\nResponse.prototype.handle = function (res) {\n    if (res.readyState === 2 && capable.status2) {\n        try {\n            this.statusCode = res.status;\n            this.headers = parseHeaders(res);\n        }\n        catch (err) {\n            capable.status2 = false;\n        }\n        \n        if (capable.status2) {\n            this.emit('ready');\n        }\n    }\n    else if (capable.streaming && res.readyState === 3) {\n        try {\n            if (!this.statusCode) {\n                this.statusCode = res.status;\n                this.headers = parseHeaders(res);\n                this.emit('ready');\n            }\n        }\n        catch (err) {}\n        \n        try {\n            this._emitData(res);\n        }\n        catch (err) {\n            capable.streaming = false;\n        }\n    }\n    else if (res.readyState === 4) {\n        if (!this.statusCode) {\n            this.statusCode = res.status;\n            this.emit('ready');\n        }\n        this._emitData(res);\n        \n        if (res.error) {\n            this.emit('error', this.getResponse(res));\n        }\n        else this.emit('end');\n        \n        this.emit('close');\n    }\n};\n\nResponse.prototype._emitData = function (res) {\n    var respBody = this.getResponse(res);\n    if (respBody.toString().match(/ArrayBuffer/)) {\n        this.emit('data', new Uint8Array(respBody, this.offset));\n        this.offset = respBody.byteLength;\n        return;\n    }\n    if (respBody.length > this.offset) {\n        this.emit('data', respBody.slice(this.offset));\n        this.offset = respBody.length;\n    }\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","exports.name = \"Base64\";\nexports.version = \"0.2.1\";\nexports.main = \"./base64.js\";\n",";(function () {\n\n  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  function InvalidCharacterError(message) {\n    this.message = message;\n  }\n  InvalidCharacterError.prototype = new Error;\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n  // encoder\n  // [https://gist.github.com/999166] by [https://github.com/nignag]\n  object.btoa || (\n  object.btoa = function (input) {\n    for (\n      // initialize result and counter\n      var block, charCode, idx = 0, map = chars, output = '';\n      // if the next input index does not exist:\n      //   change the mapping table to \"=\"\n      //   check if d has no fractional digits\n      input.charAt(idx | 0) || (map = '=', idx % 1);\n      // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n      output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n    ) {\n      charCode = input.charCodeAt(idx += 3/4);\n      if (charCode > 0xFF) {\n        throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n      }\n      block = block << 8 | charCode;\n    }\n    return output;\n  });\n\n  // decoder\n  // [https://gist.github.com/1020396] by [https://github.com/atk]\n  object.atob || (\n  object.atob = function (input) {\n    input = input.replace(/=+$/, '');\n    if (input.length % 4 == 1) {\n      throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    }\n    for (\n      // initialize result and counters\n      var bc = 0, bs, buffer, idx = 0, output = '';\n      // get next character\n      buffer = input.charAt(idx++);\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n        // and if not first of each 4 characters,\n        // convert the first 8 bits to one ascii character\n        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  });\n\n}());\n","exports.name = \"inherits\";\nexports.version = \"2.0.1\";\nexports.main = \"./inherits_browser.js\";\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","exports.name = \"stream-browserify\";\nexports.version = \"2.0.1\";\nexports.main = \"index.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","exports.name = \"inherits\";\nexports.version = \"2.0.1\";\nexports.main = \"./inherits_browser.js\";\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","var Stream = (function (){\n  try {\n    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify\n  } catch(_){}\n}());\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream || exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events');\n\n/*<replacement>*/\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = undefined;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar Duplex;\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nvar Duplex;\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function') this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      var skipAdd;\n      if (state.decoder && !addToFront && !encoding) {\n        chunk = state.decoder.write(chunk);\n        skipAdd = !state.objectMode && chunk.length === 0;\n      }\n\n      if (!addToFront) state.reading = false;\n\n      // Don't add to the buffer if we've decoded to an empty string chunk and\n      // we're not in object mode\n      if (!skipAdd) {\n        // if we want the data now, just emit it.\n        if (state.flowing && state.length === 0 && !state.sync) {\n          stream.emit('data', chunk);\n          stream.read(0);\n        } else {\n          // update the buffer info.\n          state.length += state.objectMode ? 1 : chunk.length;\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n          if (state.needReadable) emitReadable(stream);\n        }\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended) return 0;\n\n  if (state.objectMode) return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;\n  }\n\n  if (n <= 0) return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else {\n      return state.length;\n    }\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended) state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      if (state.pipesCount === 1 && state.pipes[0] === dest && src.listenerCount('data') === 1 && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error];\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var _i = 0; _i < len; _i++) {\n      dests[_i].emit('unpipe', this);\n    }return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1) return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && !this._readableState.endEmitted) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function (ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0) return null;\n\n  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode) ret = '';else ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}","// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nvar Duplex;\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // create the two objects needed to store the corked requests\n  // they are not a linked list, as no new elements are inserted in there\n  this.corkedRequestsFree = new CorkedRequest(this);\n  this.corkedRequestsFree.next = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\nvar Duplex;\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n        afterWrite(stream, state, finished, cb);\n      }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    state.corkedRequestsFree = holder.next;\n    holder.next = null;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}","// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er) {\n      done(stream, er);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nfunction done(stream, er) {\n  if (er) return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}","// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","exports.name = \"process-nextick-args\";\nexports.version = \"1.0.6\";\nexports.main = \"index.js\";\n","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn) {\n  var args = new Array(arguments.length - 1);\n  var i = 0;\n  while (i < args.length) {\n    args[i++] = arguments[i];\n  }\n  process.nextTick(function afterTick() {\n    fn.apply(null, args);\n  });\n}\n","exports.name = \"isarray\";\nexports.version = \"1.0.0\";\nexports.main = \"index.js\";\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","exports.name = \"core-util-is\";\nexports.version = \"1.0.2\";\nexports.main = \"lib/util.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","exports.name = \"inherits\";\nexports.version = \"2.0.1\";\nexports.main = \"./inherits_browser.js\";\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","exports.name = \"util-deprecate\";\nexports.version = \"1.0.2\";\nexports.main = \"browser.js\";\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","module.exports = require(\"./lib/_stream_writable.js\")\n","module.exports = require(\"./lib/_stream_duplex.js\")\n","module.exports = require(\"./lib/_stream_transform.js\")\n","module.exports = require(\"./lib/_stream_passthrough.js\")\n","exports.name = \"buffer\";\nexports.version = \"4.5.1\";\nexports.main = \"index.js\";\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(array)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n","exports.name = \"base64-js\";\nexports.version = \"1.1.2\";\nexports.main = \"lib/b64.js\";\n","'use strict'\n\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nfunction init () {\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i]\n    revLookup[code.charCodeAt(i)] = i\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62\n  revLookup['_'.charCodeAt(0)] = 63\n}\n\ninit()\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n","exports.name = \"ieee754\";\nexports.version = \"1.1.6\";\nexports.main = \"index.js\";\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","exports.name = \"isarray\";\nexports.version = \"1.0.0\";\nexports.main = \"index.js\";\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","exports.name = \"util\";\nexports.version = \"0.10.3\";\nexports.main = \"./util.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","module.exports = function isBuffer(arg) {\n  return arg instanceof Buffer;\n}\n","exports.name = \"inherits\";\nexports.version = \"2.0.1\";\nexports.main = \"./inherits_browser.js\";\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","exports.name = \"string_decoder\";\nexports.version = \"0.10.31\";\nexports.main = \"index.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n","exports.name = \"url\";\nexports.version = \"0.11.0\";\nexports.main = \"./url.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","exports.name = \"punycode\";\nexports.version = \"1.3.2\";\nexports.main = \"punycode.js\";\n","/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","exports.name = \"querystring\";\nexports.version = \"0.2.0\";\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","exports.name = \"path-browserify\";\nexports.version = \"0.0.0\";\nexports.main = \"index.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","exports.name = \"domain-browser\";\nexports.version = \"1.1.7\";\nexports.main = \"./index.js\";\n","// This file should be ES5 compatible\n/* eslint prefer-spread:0, no-var:0, prefer-reflect:0, no-magic-numbers:0 */\n'use strict'\nmodule.exports = (function () {\n\t// Import Events\n\tvar events = require('events')\n\n\t// Export Domain\n\tvar domain = {}\n\tdomain.createDomain = domain.create = function () {\n\t\tvar d = new events.EventEmitter()\n\n\t\tfunction emitError (e) {\n\t\t\td.emit('error', e)\n\t\t}\n\n\t\td.add = function (emitter) {\n\t\t\temitter.on('error', emitError)\n\t\t}\n\t\td.remove = function (emitter) {\n\t\t\temitter.removeListener('error', emitError)\n\t\t}\n\t\td.bind = function (fn) {\n\t\t\treturn function () {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments)\n\t\t\t\ttry {\n\t\t\t\t\tfn.apply(null, args)\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\temitError(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td.intercept = function (fn) {\n\t\t\treturn function (err) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\temitError(err)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments, 1)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfn.apply(null, args)\n\t\t\t\t\t}\n\t\t\t\t\tcatch (err) {\n\t\t\t\t\t\temitError(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td.run = function (fn) {\n\t\t\ttry {\n\t\t\t\tfn()\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\temitError(err)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\t\td.dispose = function () {\n\t\t\tthis.removeAllListeners()\n\t\t\treturn this\n\t\t}\n\t\td.enter = d.exit = function () {\n\t\t\treturn this\n\t\t}\n\t\treturn d\n\t}\n\treturn domain\n}).call(this)\n","exports.name = \"meteor-node-stubs\";\nexports.version = \"0.2.3\";\nexports.main = \"index.js\";\n","var map = require(\"./map.json\");\nvar meteorAliases = {};\n\nObject.keys(map).forEach(function (id) {\n  if (typeof map[id] === \"string\") {\n    try {\n      exports[id] = meteorAliases[id + \".js\"] =\n        require.resolve(map[id]);\n    } catch (e) {\n      // Resolution can fail at runtime if the stub was not included in the\n      // bundle because nothing depended on it.\n    }\n  } else {\n    exports[id] = map[id];\n    meteorAliases[id + \".js\"] = function(){};\n  }\n});\n\nif (typeof meteorInstall === \"function\") {\n  meteorInstall({\n    // Install the aliases into a node_modules directory one level up from\n    // the root directory, so that they do not clutter the namespace\n    // available to apps and packages.\n    \"..\": {\n      node_modules: meteorAliases\n    }\n  });\n}\n","module.exports = {\n  \"assert\": \"assert/\",\n  \"buffer\": \"buffer/\",\n  \"child_process\": null,\n  \"cluster\": null,\n  \"console\": \"console-browserify\",\n  \"constants\": \"constants-browserify\",\n  \"crypto\": \"crypto-browserify\",\n  \"dgram\": null,\n  \"dns\": null,\n  \"domain\": \"domain-browser\",\n  \"events\": \"events/\",\n  \"fs\": null,\n  \"http\": \"http-browserify\",\n  \"https\": \"https-browserify\",\n  \"module\": null,\n  \"net\": null,\n  \"os\": \"os-browserify/browser.js\",\n  \"path\": \"path-browserify\",\n  \"process\": \"process/browser.js\",\n  \"punycode\": \"punycode/\",\n  \"querystring\": \"querystring-es3/\",\n  \"readline\": null,\n  \"repl\": null,\n  \"stream\": \"stream-browserify\",\n  \"_stream_duplex\": \"readable-stream/duplex.js\",\n  \"_stream_passthrough\": \"readable-stream/passthrough.js\",\n  \"_stream_readable\": \"readable-stream/readable.js\",\n  \"_stream_transform\": \"readable-stream/transform.js\",\n  \"_stream_writable\": \"readable-stream/writable.js\",\n  \"string_decoder\": \"string_decoder/\",\n  \"sys\": \"util/util.js\",\n  \"timers\": \"timers-browserify\",\n  \"tls\": null,\n  \"tty\": \"tty-browserify\",\n  \"url\": \"url/\",\n  \"util\": \"util/util.js\",\n  \"vm\": \"vm-browserify\",\n  \"zlib\": \"browserify-zlib\"\n};\n","exports.name = \"docker-modem\";\nexports.version = \"0.3.1\";\nexports.main = \"./lib/modem\";\n","var querystring = require('querystring'),\r\n  http = require('follow-redirects'),\r\n  fs = require('fs'),\r\n  path = require('path'),\r\n  url = require('url'),\r\n  stream = require('readable-stream'),\r\n  HttpDuplex = require('./http_duplex'),\r\n  debug = require('debug')('modem'),\r\n  util = require('util'),\r\n  splitca = require('split-ca'),\r\n  JSONStream = require('JSONStream');\r\n\r\nvar defaultOpts = function() {\r\n  var split;\r\n  var opts = {};\r\n\r\n  if (!process.env.DOCKER_HOST) {\r\n    opts.socketPath = '/var/run/docker.sock';\r\n  } else if (process.env.DOCKER_HOST.indexOf('unix://') === 0) {\r\n    // Strip off unix://, fall back to default of /var/run/docker.sock if\r\n    // unix:// was passed without a path\r\n    opts.socketPath = process.env.DOCKER_HOST.substring(7) || '/var/run/docker.sock';\r\n  } else {\r\n    split = /(?:tcp:\\/\\/)?(.*?):([0-9]+)/g.exec(process.env.DOCKER_HOST);\r\n\r\n    if (!split || split.length !== 3) {\r\n      throw new Error('DOCKER_HOST env variable should be something like tcp://localhost:1234');\r\n    }\r\n\r\n    opts.port = split[2];\r\n\r\n    if (process.env.DOCKER_TLS_VERIFY === '1' || opts.port === '2376') {\r\n      opts.protocol = 'https';\r\n    } else {\r\n      opts.protocol = 'http';\r\n    }\r\n\r\n    opts.host = split[1];\r\n\r\n    if (process.env.DOCKER_CERT_PATH) {\r\n      opts.ca = splitca(path.join(process.env.DOCKER_CERT_PATH, 'ca.pem'));\r\n      opts.cert = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'cert.pem'));\r\n      opts.key = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'key.pem'));\r\n    }\r\n  }\r\n\r\n  return opts;\r\n};\r\n\r\nvar Modem = function(opts) {\r\n  if (!opts) {\r\n    opts = defaultOpts();\r\n  }\r\n\r\n  this.socketPath = opts.socketPath;\r\n  this.host = opts.host;\r\n  this.port = opts.port;\r\n  this.version = opts.version;\r\n  this.key = opts.key;\r\n  this.cert = opts.cert;\r\n  this.ca = opts.ca;\r\n  this.timeout = opts.timeout;\r\n  this.checkServerIdentity = opts.checkServerIdentity;\r\n\r\n  if (this.key && this.cert && this.ca) {\r\n    this.protocol = 'https';\r\n  }\r\n  this.protocol = opts.protocol || this.protocol || 'http';\r\n};\r\n\r\nModem.prototype.dial = function(options, callback) {\r\n  var opts, address, data;\r\n  var self = this;\r\n\r\n  if (options.options) {\r\n    opts = options.options;\r\n  }\r\n\r\n  if (this.version) {\r\n    options.path = '/' + this.version + options.path;\r\n  }\r\n\r\n  if (this.host) {\r\n    var parsed = url.parse(self.host);\r\n    address = url.format({\r\n      'protocol': parsed.protocol || self.protocol,\r\n      'hostname': parsed.hostname || self.host,\r\n      'port': self.port\r\n    });\r\n    address = url.resolve(address, options.path);\r\n  } else {\r\n    address = options.path;\r\n  }\r\n\r\n  if (options.path.indexOf('?') !== -1) {\r\n    if (opts && Object.keys(opts).length > 0) {\r\n      address += this.buildQuerystring(opts);\r\n    } else {\r\n      address = address.substring(0, address.length - 1);\r\n    }\r\n  }\r\n\r\n  var optionsf = {\r\n    path: address,\r\n    method: options.method,\r\n    headers: options.headers || {},\r\n    key: self.key,\r\n    cert: self.cert,\r\n    ca: self.ca\r\n  };\r\n\r\n  if (this.checkServerIdentity) {\r\n    optionsf.checkServerIdentity = this.checkServerIdentity;\r\n  }\r\n\r\n  if (options.authconfig) {\r\n    optionsf.headers['X-Registry-Auth'] = options.authconfig.key || options.authconfig.base64 ||\r\n      new Buffer(JSON.stringify(options.authconfig)).toString('base64');\r\n  }\r\n\r\n  if (options.registryconfig) {\r\n    optionsf.headers['X-Registry-Config'] = options.registryconfig.base64 ||\r\n      new Buffer(JSON.stringify(options.registryconfig)).toString('base64');\r\n  }\r\n\r\n  if (options.file) {\r\n    if (typeof options.file === 'string') {\r\n      data = fs.readFileSync(path.resolve(options.file));\r\n    } else {\r\n      data = options.file;\r\n    }\r\n    optionsf.headers['Content-Type'] = 'application/tar';\r\n  } else if (opts && options.method === 'POST') {\r\n    data = JSON.stringify(opts);\r\n    optionsf.headers['Content-Type'] = 'application/json';\r\n  }\r\n\r\n  if (typeof data === \"string\") {\r\n    optionsf.headers['Content-Length'] = Buffer.byteLength(data);\r\n  } else if (Buffer.isBuffer(data) === true) {\r\n    optionsf.headers['Content-Length'] = data.length;\r\n  }\r\n\r\n  if (options.hijack) {\r\n    optionsf.headers.Connection = 'Upgrade';\r\n    optionsf.headers.Upgrade = 'tcp';\r\n  }\r\n\r\n  if (this.socketPath) {\r\n    optionsf.socketPath = this.socketPath;\r\n  } else {\r\n    var urlp = url.parse(address);\r\n    optionsf.hostname = urlp.hostname;\r\n    optionsf.port = urlp.port;\r\n    optionsf.path = urlp.path;\r\n  }\r\n\r\n  this.buildRequest(optionsf, options, data, callback);\r\n};\r\n\r\nModem.prototype.buildRequest = function(options, context, data, callback) {\r\n  var self = this;\r\n  var req = http[self.protocol].request(options, function() {});\r\n\r\n  debug('Sending: %s', util.inspect(options, {\r\n    showHidden: true,\r\n    depth: null\r\n  }));\r\n\r\n  if (self.timeout) {\r\n    req.on('socket', function(socket) {\r\n      socket.setTimeout(self.timeout);\r\n      socket.on('timeout', function() {\r\n        debug('Timeout of %s ms exceeded', self.timeout);\r\n        req.abort();\r\n      });\r\n    });\r\n  }\r\n\r\n  if (context.hijack === true) {\r\n    req.on('upgrade', function(res, sock, head) {\r\n      return callback(null, sock);\r\n    });\r\n  }\r\n\r\n  req.on('response', function(res) {\r\n    if (context.isStream === true) {\r\n      self.buildPayload(null, context.isStream, context.statusCodes, context.openStdin, req, res, null, callback);\r\n    } else {\r\n      var chunks = '';\r\n      res.on('data', function(chunk) {\r\n        chunks += chunk;\r\n      });\r\n\r\n      res.on('end', function() {\r\n        debug('Received: %s', chunks);\r\n\r\n        var json;\r\n        try {\r\n          json = JSON.parse(chunks);\r\n        } catch (e) {\r\n          json = chunks;\r\n        }\r\n        self.buildPayload(null, context.isStream, context.statusCodes, false, req, res, json, callback);\r\n      });\r\n    }\r\n  });\r\n\r\n  req.on('error', function(error) {\r\n    self.buildPayload(error, context.isStream, context.statusCodes, false, {}, {}, null, callback);\r\n  });\r\n\r\n  if (typeof data === \"string\" || Buffer.isBuffer(data)) {\r\n    req.write(data);\r\n  } else if (data) {\r\n    data.pipe(req);\r\n  }\r\n\r\n  if (!context.hijack && !context.openStdin && (typeof data === \"string\" || data === undefined || Buffer.isBuffer(data))) {\r\n    req.end();\r\n  }\r\n};\r\n\r\nModem.prototype.buildPayload = function(err, isStream, statusCodes, openStdin, req, res, json, cb) {\r\n  if (err) return cb(err, null);\r\n\r\n  if (statusCodes[res.statusCode] !== true) {\r\n    getCause(isStream, res, json, function(err, cause) {\r\n      var msg = new Error(\r\n        '(HTTP code ' + res.statusCode + ') ' +\r\n        (statusCodes[res.statusCode] || 'unexpected') + ' - ' +\r\n        (cause.message || cause) + ' '\r\n      );\r\n      msg.reason = statusCodes[res.statusCode];\r\n      msg.statusCode = res.statusCode;\r\n      msg.json = json;\r\n      cb(msg, null);\r\n    });\r\n  } else {\r\n    if (openStdin) {\r\n      cb(null, new HttpDuplex(req, res));\r\n    } else if (isStream) {\r\n      cb(null, res);\r\n    } else {\r\n      cb(null, json);\r\n    }\r\n  }\r\n\r\n  function getCause(isStream, res, json, callback) {\r\n    var chunks = '';\r\n    if (isStream) {\r\n      res.on('data', function(chunk) {\r\n        chunks += chunk;\r\n      });\r\n      res.on('end', function() {\r\n        callback(null, chunks);\r\n      });\r\n    } else {\r\n      callback(null, json);\r\n    }\r\n  }\r\n};\r\n\r\nModem.prototype.demuxStream = function(stream, stdout, stderr) {\r\n  var header = null;\r\n\r\n  stream.on('readable', function() {\r\n    header = header || stream.read(8);\r\n    while (header !== null) {\r\n      var type = header.readUInt8(0);\r\n      var payload = stream.read(header.readUInt32BE(4));\r\n      if (payload === null) break;\r\n      if (type == 2) {\r\n        stderr.write(payload);\r\n      } else {\r\n        stdout.write(payload);\r\n      }\r\n      header = stream.read(8);\r\n    }\r\n  });\r\n};\r\n\r\nModem.prototype.followProgress = function(stream, onFinished, onProgress) {\r\n  var parser = JSONStream.parse(),\r\n    output = [];\r\n\r\n  parser.on('root', onStreamEvent);\r\n  parser.on('error', onStreamError);\r\n  parser.on('end', onStreamEnd);\r\n\r\n  stream.pipe(parser);\r\n\r\n  function onStreamEvent(evt) {\r\n    if (!(evt instanceof Object)) {\r\n      evt = {};\r\n    }\r\n\r\n    output.push(evt);\r\n\r\n    if (evt.error) {\r\n      return onStreamError(evt.error);\r\n    }\r\n\r\n    if (onProgress) {\r\n      onProgress(evt);\r\n    }\r\n  }\r\n\r\n  function onStreamError(err) {\r\n    parser.removeListener('root', onStreamEvent);\r\n    parser.removeListener('error', onStreamError);\r\n    parser.removeListener('end', onStreamEnd);\r\n    onFinished(err, output);\r\n  }\r\n\r\n  function onStreamEnd() {\r\n    onFinished(null, output);\r\n  }\r\n};\r\n\r\nModem.prototype.buildQuerystring = function(opts) {\r\n  var clone = {};\r\n\r\n  // serialize map values as JSON strings, else querystring truncates.\r\n  Object.keys(opts).map(function(key, i) {\r\n    clone[key] = (opts[key] && typeof opts[key] === 'object') ?\r\n      JSON.stringify(opts[key]) : opts[key];\r\n  });\r\n\r\n  return querystring.stringify(clone);\r\n};\r\n\r\nmodule.exports = Modem;\r\n","module.exports = HttpDuplex;\n\nvar util = require('util'),\n  stream = require('readable-stream');\n\nutil.inherits(HttpDuplex, stream.Duplex);\n\nfunction HttpDuplex(req, res, options) {\n  var self = this;\n\n  if (!(self instanceof HttpDuplex)) return new HttpDuplex(req, res);\n\n  stream.Duplex.call(self, options);\n  self._output = null;\n\n  self.connect(req, res);\n}\n\nHttpDuplex.prototype.connect = function(req, res) {\n  var self = this;\n  self.req = req;\n  self._output = res;\n  self.emit('response', res);\n\n  res.on('data', function(c) {\n    if (!self.push(c)) self._output.pause();\n  });\n  res.on('end', function() {\n    self.push(null);\n  });\n};\n\nHttpDuplex.prototype._read = function(n) {\n  if (this._output) this._output.resume();\n};\n\nHttpDuplex.prototype._write = function(chunk, encoding, cb) {\n  this.req.write(chunk, encoding);\n  cb();\n};\n\nHttpDuplex.prototype.end = function(chunk, encoding, cb) {\n  this._output.socket.destroy();\n  return this.req.end(chunk, encoding, cb);\n};\n\nHttpDuplex.prototype.destroy = function() {\n  this.req.destroy();\n  this._output.socket.destroy();\n};\n","exports.name = \"follow-redirects\";\nexports.version = \"0.0.3\";\nexports.main = \"index.js\";\n","var nativeHttps = require('https'),\n  nativeHttp = require('http'),\n  url = require('url'),\n  _ = require('underscore');\n\nvar maxRedirects = module.exports.maxRedirects = 5;\n\nvar protocols = {\n  https: nativeHttps,\n  http: nativeHttp\n};\n\n// Only use GETs on redirects\nfor (var protocol in protocols) {\n  // h is either our cloned http or https object\n  var h =  function() {};\n  h.prototype = protocols[protocol];\n  h = new h();\n\n  module.exports[protocol] = h;\n\n  h.request = function (h) {\n    return function (options, callback, redirectOptions) {\n\n      redirectOptions = redirectOptions || {};\n\n      var max = (typeof options === 'object' && 'maxRedirects' in options) ? options.maxRedirects : exports.maxRedirects;\n\n      var redirect = _.extend({\n        count: 0,\n        max: max,\n        clientRequest: null,\n        userCallback: callback\n      }, redirectOptions);\n\n      //console.log(redirect.count);\n      //console.log(redirect.max);\n      /**\n       * Emit error if too many redirects\n       */\n      if (redirect.count > redirect.max) {\n        var err = new Error('Max redirects exceeded. To allow more redirects, pass options.maxRedirects property.');\n        redirect.clientRequest.emit('error', err);\n        return redirect.clientRequest;\n      }\n\n      redirect.count++;\n\n      /**\n       * Parse URL from options\n       */\n      var reqUrl;\n      if (typeof options === 'string') {\n        reqUrl = options;\n      }\n      else {\n        reqUrl = url.format(_.extend({ protocol: protocol }, options));\n      }\n\n      /*\n       * Build client request\n       */\n      var clientRequest = h.__proto__.request(options, redirectCallback(reqUrl, redirect));\n\n      // Save user's clientRequest so we can emit errors later\n      if (!redirect.clientRequest) redirect.clientRequest = clientRequest;\n\n      /**\n       * ClientRequest callback for redirects\n       */\n      function redirectCallback (reqUrl, redirect) {\n        return function (res) {\n          // status must be 300-399 for redirects\n          if (res.statusCode < 300 || res.statusCode > 399) {\n            //console.log('[' + res.statusCode + '] callback user on url ' + reqUrl);\n            return redirect.userCallback(res);\n          }\n\n          // no `Location:` header => nowhere to redirect\n          if (!('location' in res.headers)) {\n            //console.log('[no location header] callback user on url ' + reqUrl);\n            return redirect.userCallback(res);\n          }\n\n          // save the original clientRequest to our redirectOptions so we can emit errors later\n\n          // need to use url.resolve() in case location is a relative URL\n          var redirectUrl = url.resolve(reqUrl, res.headers['location']);\n          // we need to call the right api (http vs https) depending on protocol\n          var proto = url.parse(redirectUrl).protocol;\n          proto = proto.substr(0, proto.length - 1);\n          //console.log('Redirecting from ' + reqUrl + ' to ' + redirectUrl);\n          return module.exports[proto].get(redirectUrl, redirectCallback(reqUrl, redirect), redirect);\n        };\n      }\n\n      return clientRequest;\n    }\n  }(h);\n\n  // see https://github.com/joyent/node/blob/master/lib/http.js#L1623\n  h.get = function (h) {\n    return function (options, cb, redirectOptions) {\n      var req = h.request(options, cb, redirectOptions);\n      req.end();\n      return req;\n    };\n  }(h);\n}\n","exports.name = \"underscore\";\nexports.version = \"1.8.3\";\nexports.main = \"underscore.js\";\n","//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result  either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n","exports.name = \"readable-stream\";\nexports.version = \"1.0.34\";\nexports.main = \"readable.js\";\n","var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nif (!process.browser && process.env.READABLE_STREAM === 'disable') {\n  module.exports = require('stream');\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = false;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // In streams that never have any data, and do push(null) right away,\n  // the consumer can miss the 'end' event if they do some I/O before\n  // consuming the stream.  So, we don't emit('end') until some reading\n  // happens.\n  this.calledRead = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (typeof chunk === 'string' && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null || chunk === undefined) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      // update the buffer info.\n      state.length += state.objectMode ? 1 : chunk.length;\n      if (addToFront) {\n        state.buffer.unshift(chunk);\n      } else {\n        state.reading = false;\n        state.buffer.push(chunk);\n      }\n\n      if (state.needReadable)\n        emitReadable(stream);\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  var state = this._readableState;\n  state.calledRead = true;\n  var nOrig = n;\n  var ret;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    ret = null;\n\n    // In cases where the decoder did not receive enough data\n    // to produce a full chunk, then immediately received an\n    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].\n    // howMuchToRead will see this and coerce the amount to\n    // read to zero (because it's looking at the length of the\n    // first <Buffer > in state.buffer), and we'll end up here.\n    //\n    // This can only happen via state.decoder -- no other venue\n    // exists for pushing a zero-length chunk into state.buffer\n    // and triggering this behavior. In this case, we return our\n    // remaining data and end the stream, if appropriate.\n    if (state.length > 0 && state.decoder) {\n      ret = fromList(n, state);\n      state.length -= ret.length;\n    }\n\n    if (state.length === 0)\n      endReadable(this);\n\n    return ret;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length - n <= state.highWaterMark)\n    doRead = true;\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading)\n    doRead = false;\n\n  if (doRead) {\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read called its callback synchronously, then `reading`\n  // will be false, and we need to re-evaluate how much data we\n  // can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we happened to read() exactly the remaining amount in the\n  // buffer, and the EOF has been seen at this point, then make sure\n  // that we emit 'end' on the very next tick.\n  if (state.ended && !state.endEmitted && state.length === 0)\n    endReadable(this);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // if we've ended and we have some data left, then emit\n  // 'readable' now to make sure it gets picked up.\n  if (state.length > 0)\n    emitReadable(stream);\n  else\n    endReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (state.emittedReadable)\n    return;\n\n  state.emittedReadable = true;\n  if (state.sync)\n    process.nextTick(function() {\n      emitReadable_(stream);\n    });\n  else\n    emitReadable_(stream);\n}\n\nfunction emitReadable_(stream) {\n  stream.emit('readable');\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    if (readable !== src) return;\n    cleanup();\n  }\n\n  function onend() {\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (!dest._writableState || dest._writableState.needDrain)\n      ondrain();\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    // the handler that waits for readable events after all\n    // the data gets sucked out in flow.\n    // This would be easier to follow with a .once() handler\n    // in flow(), but that is too slow.\n    this.on('readable', pipeOnReadable);\n\n    state.flowing = true;\n    process.nextTick(function() {\n      flow(src);\n    });\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var dest = this;\n    var state = src._readableState;\n    state.awaitDrain--;\n    if (state.awaitDrain === 0)\n      flow(src);\n  };\n}\n\nfunction flow(src) {\n  var state = src._readableState;\n  var chunk;\n  state.awaitDrain = 0;\n\n  function write(dest, i, list) {\n    var written = dest.write(chunk);\n    if (false === written) {\n      state.awaitDrain++;\n    }\n  }\n\n  while (state.pipesCount && null !== (chunk = src.read())) {\n\n    if (state.pipesCount === 1)\n      write(state.pipes, 0, null);\n    else\n      forEach(state.pipes, write);\n\n    src.emit('data', chunk);\n\n    // if anyone needs a drain, then we have to wait for that.\n    if (state.awaitDrain > 0)\n      return;\n  }\n\n  // if every destination was unpiped, either before entering this\n  // function, or in the while loop, then stop flowing.\n  //\n  // NB: This is a pretty rare edge case.\n  if (state.pipesCount === 0) {\n    state.flowing = false;\n\n    // if there were data event listeners added, then switch to old mode.\n    if (EE.listenerCount(src, 'data') > 0)\n      emitDataEvents(src);\n    return;\n  }\n\n  // at this point, no one needed a drain, so we just ran out of data\n  // on the next readable event, start it over again.\n  state.ranOut = true;\n}\n\nfunction pipeOnReadable() {\n  if (this._readableState.ranOut) {\n    this._readableState.ranOut = false;\n    flow(this);\n  }\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data' && !this._readableState.flowing)\n    emitDataEvents(this);\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        this.read(0);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  emitDataEvents(this);\n  this.read(0);\n  this.emit('resume');\n};\n\nReadable.prototype.pause = function() {\n  emitDataEvents(this, true);\n  this.emit('pause');\n};\n\nfunction emitDataEvents(stream, startPaused) {\n  var state = stream._readableState;\n\n  if (state.flowing) {\n    // https://github.com/isaacs/readable-stream/issues/16\n    throw new Error('Cannot switch to old mode now.');\n  }\n\n  var paused = startPaused || false;\n  var readable = false;\n\n  // convert to an old-style stream.\n  stream.readable = true;\n  stream.pipe = Stream.prototype.pipe;\n  stream.on = stream.addListener = Stream.prototype.on;\n\n  stream.on('readable', function() {\n    readable = true;\n\n    var c;\n    while (!paused && (null !== (c = stream.read())))\n      stream.emit('data', c);\n\n    if (c === null) {\n      readable = false;\n      stream._readableState.needReadable = true;\n    }\n  });\n\n  stream.pause = function() {\n    paused = true;\n    this.emit('pause');\n  };\n\n  stream.resume = function() {\n    paused = false;\n    if (readable)\n      process.nextTick(function() {\n        stream.emit('readable');\n      });\n    else\n      this.read(0);\n    this.emit('resume');\n  };\n\n  // now make it start, just in case it hadn't already.\n  stream.emit('readable');\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    //if (state.objectMode && util.isNullOrUndefined(chunk))\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (typeof stream[i] === 'function' &&\n        typeof this[i] === 'undefined') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted && state.calledRead) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb))\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\n  return ret;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      cb(er);\n    });\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished && !state.bufferProcessing && state.buffer.length)\n      clearBuffer(stream, state);\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  cb();\n  if (finished)\n    finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  for (var c = 0; c < state.buffer.length; c++) {\n    var entry = state.buffer[c];\n    var chunk = entry.chunk;\n    var encoding = entry.encoding;\n    var cb = entry.callback;\n    var len = state.objectMode ? 1 : chunk.length;\n\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n    // if we didn't call the onwrite immediately, then\n    // it means that we need to wait until it does.\n    // also, that means that the chunk and cb are currently\n    // being processed, so move the buffer counter past them.\n    if (state.writing) {\n      c++;\n      break;\n    }\n  }\n\n  state.bufferProcessing = false;\n  if (c < state.buffer.length)\n    state.buffer = state.buffer.slice(c);\n  else\n    state.buffer.length = 0;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (typeof chunk !== 'undefined' && chunk !== null)\n    this.write(chunk, encoding);\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    state.finished = true;\n    stream.emit('finish');\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  var ts = this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('finish', function() {\n    if ('function' === typeof this._flush)\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var rs = stream._readableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n","exports.name = \"isarray\";\nexports.version = \"0.0.1\";\nexports.main = \"index.js\";\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","exports.name = \"core-util-is\";\nexports.version = \"1.0.2\";\nexports.main = \"lib/util.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","exports.name = \"inherits\";\nexports.version = \"2.0.1\";\nexports.main = \"./inherits_browser.js\";\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","exports.name = \"string_decoder\";\nexports.version = \"0.10.31\";\nexports.main = \"index.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n","exports.name = \"debug\";\nexports.version = \"0.7.4\";\nexports.main = \"./debug.js\";\n","\n/**\n * Expose `debug()` as the module.\n */\n\nmodule.exports = debug;\n\n/**\n * Create a debugger with the given `name`.\n *\n * @param {String} name\n * @return {Type}\n * @api public\n */\n\nfunction debug(name) {\n  if (!debug.enabled(name)) return function(){};\n\n  return function(fmt){\n    fmt = coerce(fmt);\n\n    var curr = new Date;\n    var ms = curr - (debug[name] || curr);\n    debug[name] = curr;\n\n    fmt = name\n      + ' '\n      + fmt\n      + ' +' + debug.humanize(ms);\n\n    // This hackery is required for IE8\n    // where `console.log` doesn't have 'apply'\n    window.console\n      && console.log\n      && Function.prototype.apply.call(console.log, console, arguments);\n  }\n}\n\n/**\n * The currently active debug mode names.\n */\n\ndebug.names = [];\ndebug.skips = [];\n\n/**\n * Enables a debug mode by name. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} name\n * @api public\n */\n\ndebug.enable = function(name) {\n  try {\n    localStorage.debug = name;\n  } catch(e){}\n\n  var split = (name || '').split(/[\\s,]+/)\n    , len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    name = split[i].replace('*', '.*?');\n    if (name[0] === '-') {\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));\n    }\n    else {\n      debug.names.push(new RegExp('^' + name + '$'));\n    }\n  }\n};\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\ndebug.disable = function(){\n  debug.enable('');\n};\n\n/**\n * Humanize the given `ms`.\n *\n * @param {Number} m\n * @return {String}\n * @api private\n */\n\ndebug.humanize = function(ms) {\n  var sec = 1000\n    , min = 60 * 1000\n    , hour = 60 * min;\n\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';\n  if (ms >= sec) return (ms / sec | 0) + 's';\n  return ms + 'ms';\n};\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\ndebug.enabled = function(name) {\n  for (var i = 0, len = debug.skips.length; i < len; i++) {\n    if (debug.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (var i = 0, len = debug.names.length; i < len; i++) {\n    if (debug.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Coerce `val`.\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n// persist\n\ntry {\n  if (window.localStorage) debug.enable(localStorage.debug);\n} catch(e){}\n","exports.name = \"split-ca\";\nexports.version = \"1.0.1\";\nexports.main = \"index.js\";\n","var fs = require('fs');\n\nmodule.exports = function (filepath, split, encoding) {\n  split = typeof split !== 'undefined' ? split : \"\\n\";\n  encoding = typeof encoding !== 'undefined' ? encoding : \"utf8\";\n\n  var ca = [];\n  var chain = fs.readFileSync(filepath, encoding);\n  if(chain.indexOf(\"-END CERTIFICATE-\") < 0 || chain.indexOf(\"-BEGIN CERTIFICATE-\") < 0){\n    throw Error(\"File does not contain 'BEGIN CERTIFICATE' or 'END CERTIFICATE'\");\n  }\n  chain = chain.split(split);\n  var cert = [];\n  var _i, _len;\n  for (_i = 0, _len = chain.length; _i < _len; _i++) {\n    var line = chain[_i];\n    if (!(line.length !== 0)) {\n      continue;\n    }\n    cert.push(line);\n    if (line.match(/-END CERTIFICATE-/)) {\n      ca.push(cert.join(split));\n      cert = [];\n    }\n  }\n  return ca;\n}\n","exports.name = \"JSONStream\";\nexports.version = \"0.10.0\";\n","\n\nvar Parser = require('jsonparse')\n  , through = require('through')\n\n/*\n\n  the value of this.stack that creationix's jsonparse has is weird.\n\n  it makes this code ugly, but his problem is way harder that mine,\n  so i'll forgive him.\n\n*/\n\nexports.parse = function (path, map) {\n\n  var parser = new Parser()\n  var stream = through(function (chunk) {\n    if('string' === typeof chunk)\n      chunk = new Buffer(chunk)\n    parser.write(chunk)\n  },\n  function (data) {\n    if(data)\n      stream.write(data)\n    stream.queue(null)\n  })\n\n  if('string' === typeof path)\n    path = path.split('.').map(function (e) {\n      if (e === '*')\n        return true\n      else if (e === '') // '..'.split('.') returns an empty string\n        return {recurse: true}\n      else\n        return e\n    })\n\n\n  var count = 0, _key\n  if(!path || !path.length)\n    path = null\n\n  parser.onValue = function (value) {\n    if (!this.root)\n      stream.root = value\n\n    if(! path) return\n\n    var i = 0 // iterates on path\n    var j  = 0 // iterates on stack\n    while (i < path.length) {\n      var key = path[i]\n      var c\n      j++\n\n      if (key && !key.recurse) {\n        c = (j === this.stack.length) ? this : this.stack[j]\n        if (!c) return\n        if (! check(key, c.key)) return\n        i++\n      } else {\n        i++\n        var nextKey = path[i]\n        if (! nextKey) return\n        while (true) {\n          c = (j === this.stack.length) ? this : this.stack[j]\n          if (!c) return\n          if (check(nextKey, c.key)) { i++; break}\n          j++\n        }\n      }\n    }\n    if (j !== this.stack.length) return\n\n    count ++\n    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])\n    var data = this.value[this.key]\n    if(null != data)\n      if(null != (data = map ? map(data, actualPath) : data))\n        stream.queue(data)\n    delete this.value[this.key]\n  }\n  parser._onToken = parser.onToken;\n\n  parser.onToken = function (token, value) {\n    parser._onToken(token, value);\n    if (this.stack.length === 0) {\n      if (stream.root) {\n        if(!path)\n          stream.queue(stream.root)\n        stream.emit('root', stream.root, count)\n        count = 0;\n        stream.root = null;\n      }\n    }\n  }\n\n  parser.onError = function (err) {\n    stream.emit('error', err)\n  }\n\n\n  return stream\n}\n\nfunction check (x, y) {\n  if ('string' === typeof x)\n    return y == x\n  else if (x && 'function' === typeof x.exec)\n    return x.exec(y)\n  else if ('boolean' === typeof x)\n    return x\n  else if ('function' === typeof x)\n    return x(y)\n  return false\n}\n\nexports.stringify = function (op, sep, cl, indent) {\n  indent = indent || 0\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n\n    op = '[\\n'\n    sep = '\\n,\\n'\n    cl = '\\n]\\n'\n\n  }\n\n  //else, what ever you like\n\n  var stream\n    , first = true\n    , anyData = false\n  stream = through(function (data) {\n    anyData = true\n    var json = JSON.stringify(data, null, indent)\n    if(first) { first = false ; stream.queue(op + json)}\n    else stream.queue(sep + json)\n  },\n  function (data) {\n    if(!anyData)\n      stream.queue(op)\n    stream.queue(cl)\n    stream.queue(null)\n  })\n\n  return stream\n}\n\nexports.stringifyObject = function (op, sep, cl, indent) {\n  indent = indent || 0\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n\n    op = '{\\n'\n    sep = '\\n,\\n'\n    cl = '\\n}\\n'\n\n  }\n\n  //else, what ever you like\n\n  var first = true\n    , anyData = false\n  stream = through(function (data) {\n    anyData = true\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)\n    if(first) { first = false ; this.queue(op + json)}\n    else this.queue(sep + json)\n  },\n  function (data) {\n    if(!anyData) this.queue(op)\n    this.queue(cl)\n\n    this.queue(null)\n  })\n\n  return stream\n}\n\nif(!module.parent && process.title !== 'browser') {\n  process.stdin\n    .pipe(exports.parse(process.argv[2]))\n    .pipe(exports.stringify('[', ',\\n', ']\\n', 2))\n    .pipe(process.stdout)\n}\n","exports.name = \"jsonparse\";\nexports.version = \"0.0.5\";\nexports.main = \"jsonparse.js\";\n","/*global Buffer*/\n// Named constants with unique integer values\nvar C = {};\n// Tokens\nvar LEFT_BRACE    = C.LEFT_BRACE    = 0x1;\nvar RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;\nvar LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;\nvar RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;\nvar COLON         = C.COLON         = 0x5;\nvar COMMA         = C.COMMA         = 0x6;\nvar TRUE          = C.TRUE          = 0x7;\nvar FALSE         = C.FALSE         = 0x8;\nvar NULL          = C.NULL          = 0x9;\nvar STRING        = C.STRING        = 0xa;\nvar NUMBER        = C.NUMBER        = 0xb;\n// Tokenizer States\nvar START   = C.START   = 0x11;\nvar TRUE1   = C.TRUE1   = 0x21;\nvar TRUE2   = C.TRUE2   = 0x22;\nvar TRUE3   = C.TRUE3   = 0x23;\nvar FALSE1  = C.FALSE1  = 0x31;\nvar FALSE2  = C.FALSE2  = 0x32;\nvar FALSE3  = C.FALSE3  = 0x33;\nvar FALSE4  = C.FALSE4  = 0x34;\nvar NULL1   = C.NULL1   = 0x41;\nvar NULL2   = C.NULL3   = 0x42;\nvar NULL3   = C.NULL2   = 0x43;\nvar NUMBER1 = C.NUMBER1 = 0x51;\nvar NUMBER2 = C.NUMBER2 = 0x52;\nvar NUMBER3 = C.NUMBER3 = 0x53;\nvar NUMBER4 = C.NUMBER4 = 0x54;\nvar NUMBER5 = C.NUMBER5 = 0x55;\nvar NUMBER6 = C.NUMBER6 = 0x56;\nvar NUMBER7 = C.NUMBER7 = 0x57;\nvar NUMBER8 = C.NUMBER8 = 0x58;\nvar STRING1 = C.STRING1 = 0x61;\nvar STRING2 = C.STRING2 = 0x62;\nvar STRING3 = C.STRING3 = 0x63;\nvar STRING4 = C.STRING4 = 0x64;\nvar STRING5 = C.STRING5 = 0x65;\nvar STRING6 = C.STRING6 = 0x66;\n// Parser States\nvar VALUE   = C.VALUE   = 0x71;\nvar KEY     = C.KEY     = 0x72;\n// Parser Modes\nvar OBJECT  = C.OBJECT  = 0x81;\nvar ARRAY   = C.ARRAY   = 0x82;\n\n// Slow code to string converter (only used when throwing syntax errors)\nfunction toknam(code) {\n  var keys = Object.keys(C);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    if (C[key] === code) { return key; }\n  }\n  return code && (\"0x\" + code.toString(16));\n}\n\n\nfunction Parser() {\n  this.tState = START;\n  this.value = undefined;\n\n  this.string = undefined; // string data\n  this.unicode = undefined; // unicode escapes\n\n  // For number parsing\n  this.negative = undefined;\n  this.magnatude = undefined;\n  this.position = undefined;\n  this.exponent = undefined;\n  this.negativeExponent = undefined;\n  \n  this.key = undefined;\n  this.mode = undefined;\n  this.stack = [];\n  this.state = VALUE;\n  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n  this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n}\nvar proto = Parser.prototype;\nproto.charError = function (buffer, i) {\n  this.onError(new Error(\"Unexpected \" + JSON.stringify(String.fromCharCode(buffer[i])) + \" at position \" + i + \" in state \" + toknam(this.tState)));\n};\nproto.onError = function (err) { throw err; };\nproto.write = function (buffer) {\n  if (typeof buffer === \"string\") buffer = new Buffer(buffer);\n  //process.stdout.write(\"Input: \");\n  //console.dir(buffer.toString());\n  var n;\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    if (this.tState === START){\n      n = buffer[i];\n      if(n === 0x7b){ this.onToken(LEFT_BRACE, \"{\"); // {\n      }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, \"}\"); // }\n      }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, \"[\"); // [\n      }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, \"]\"); // ]\n      }else if(n === 0x3a){ this.onToken(COLON, \":\");  // :\n      }else if(n === 0x2c){ this.onToken(COMMA, \",\"); // ,\n      }else if(n === 0x74){ this.tState = TRUE1;  // t\n      }else if(n === 0x66){ this.tState = FALSE1;  // f\n      }else if(n === 0x6e){ this.tState = NULL1; // n\n      }else if(n === 0x22){ this.string = \"\"; this.tState = STRING1; // \"\n      }else if(n === 0x2d){ this.negative = true; this.tState = NUMBER1; // -\n      }else if(n === 0x30){ this.magnatude = 0; this.tState = NUMBER2; // 0\n      }else{\n        if (n > 0x30 && n < 0x40) { // 1-9\n          this.magnatude = n - 0x30; this.tState = NUMBER3;\n        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {\n          // whitespace\n        } else { this.charError(buffer, i); }\n      }\n    }else if (this.tState === STRING1){ // After open quote\n      n = buffer[i]; // get current byte from buffer\n      // check for carry over of a multi byte char split between data chunks\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n      if (this.bytes_remaining > 0) {\n        for (var j = 0; j < this.bytes_remaining; j++) {\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];\n        }\n        this.string += this.temp_buffs[this.bytes_in_sequence].toString();\n        this.bytes_in_sequence = this.bytes_remaining = 0;\n        i = i + j - 1;\n      } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;\n        if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split\n          for (var k = 0; k <= (buffer.length - 1 - i); k++) {\n            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk\n          }\n          this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;\n          i = buffer.length - 1;\n        } else {\n          this.string += buffer.slice(i, (i + this.bytes_in_sequence)).toString();\n          i = i + this.bytes_in_sequence - 1;\n        }\n      } else if (n === 0x22) { this.tState = START; this.onToken(STRING, this.string); this.string = undefined; }\n      else if (n === 0x5c) { this.tState = STRING2; }\n      else if (n >= 0x20) { this.string += String.fromCharCode(n); }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === STRING2){ // After backslash\n      n = buffer[i];\n      if(n === 0x22){ this.string += \"\\\"\"; this.tState = STRING1;\n      }else if(n === 0x5c){ this.string += \"\\\\\"; this.tState = STRING1; \n      }else if(n === 0x2f){ this.string += \"\\/\"; this.tState = STRING1; \n      }else if(n === 0x62){ this.string += \"\\b\"; this.tState = STRING1; \n      }else if(n === 0x66){ this.string += \"\\f\"; this.tState = STRING1; \n      }else if(n === 0x6e){ this.string += \"\\n\"; this.tState = STRING1; \n      }else if(n === 0x72){ this.string += \"\\r\"; this.tState = STRING1; \n      }else if(n === 0x74){ this.string += \"\\t\"; this.tState = STRING1; \n      }else if(n === 0x75){ this.unicode = \"\"; this.tState = STRING3;\n      }else{ \n        this.charError(buffer, i); \n      }\n    }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes\n      n = buffer[i];\n      // 0-9 A-F a-f\n      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {\n        this.unicode += String.fromCharCode(n);\n        if (this.tState++ === STRING6) {\n          this.string += String.fromCharCode(parseInt(this.unicode, 16));\n          this.unicode = undefined;\n          this.tState = STRING1; \n        }\n      } else {\n        this.charError(buffer, i);\n      }\n    }else if (this.tState === NUMBER1){ // after minus\n      n = buffer[i];\n      if (n === 0x30) { this.magnatude = 0; this.tState = NUMBER2; }\n      else if (n > 0x30 && n < 0x40) { this.magnatude = n - 0x30; this.tState = NUMBER3; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === NUMBER2){ // * After initial zero\n      n = buffer[i];\n      if(n === 0x2e){ // .\n        this.position = 0.1; this.tState = NUMBER4;\n      }else if(n === 0x65 ||  n === 0x45){ // e/E\n        this.exponent = 0; this.tState = NUMBER6;\n      }else{\n        this.tState = START;\n        this.onToken(NUMBER, 0);\n        this.magnatude = undefined;\n        this.negative = undefined;\n        i--;\n      }\n    }else if (this.tState === NUMBER3){ // * After digit (before period)\n      n = buffer[i];\n      if(n === 0x2e){ // .\n        this.position = 0.1; this.tState = NUMBER4;\n      }else if(n === 0x65 || n === 0x45){ // e/E\n        this.exponent = 0; this.tState = NUMBER6;\n      }else{\n        if (n >= 0x30 && n < 0x40) { this.magnatude = this.magnatude * 10 + n - 0x30; }\n        else {\n          this.tState = START; \n          if (this.negative) {\n            this.magnatude = -this.magnatude;\n            this.negative = undefined;\n          }\n          this.onToken(NUMBER, this.magnatude); \n          this.magnatude = undefined;\n          i--;\n        }\n      }\n    }else if (this.tState === NUMBER4){ // After period\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.magnatude += this.position * (n - 0x30);\n        this.position /= 10;\n        this.tState = NUMBER5; \n      } else { this.charError(buffer, i); }\n    }else if (this.tState === NUMBER5){ // * After digit (after period)\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.magnatude += this.position * (n - 0x30);\n        this.position /= 10;\n      }\n      else if (n === 0x65 || n === 0x45) { this.exponent = 0; this.tState = NUMBER6; } // E/e\n      else {\n        this.tState = START; \n        if (this.negative) {\n          this.magnatude = -this.magnatude;\n          this.negative = undefined;\n        }\n        this.onToken(NUMBER, this.negative ? -this.magnatude : this.magnatude); \n        this.magnatude = undefined;\n        this.position = undefined;\n        i--; \n      }\n    }else if (this.tState === NUMBER6){ // After E\n      n = buffer[i];\n      if (n === 0x2b || n === 0x2d) { // +/-\n        if (n === 0x2d) { this.negativeExponent = true; }\n        this.tState = NUMBER7;\n      }\n      else if (n >= 0x30 && n < 0x40) {\n        this.exponent = this.exponent * 10 + (n - 0x30);\n        this.tState = NUMBER8;\n      }\n      else { this.charError(buffer, i); }  \n    }else if (this.tState === NUMBER7){ // After +/-\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.exponent = this.exponent * 10 + (n - 0x30);\n        this.tState = NUMBER8;\n      }\n      else { this.charError(buffer, i); }  \n    }else if (this.tState === NUMBER8){ // * After digit (after +/-)\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.exponent = this.exponent * 10 + (n - 0x30);\n      }\n      else {\n        if (this.negativeExponent) {\n          this.exponent = -this.exponent;\n          this.negativeExponent = undefined;\n        }\n        this.magnatude *= Math.pow(10, this.exponent);\n        this.exponent = undefined;\n        if (this.negative) { \n          this.magnatude = -this.magnatude;\n          this.negative = undefined;\n        }\n        this.tState = START;\n        this.onToken(NUMBER, this.magnatude);\n        this.magnatude = undefined;\n        i--; \n      } \n    }else if (this.tState === TRUE1){ // r\n      if (buffer[i] === 0x72) { this.tState = TRUE2; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === TRUE2){ // u\n      if (buffer[i] === 0x75) { this.tState = TRUE3; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === TRUE3){ // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === FALSE1){ // a\n      if (buffer[i] === 0x61) { this.tState = FALSE2; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === FALSE2){ // l\n      if (buffer[i] === 0x6c) { this.tState = FALSE3; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === FALSE3){ // s\n      if (buffer[i] === 0x73) { this.tState = FALSE4; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === FALSE4){ // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === NULL1){ // u\n      if (buffer[i] === 0x75) { this.tState = NULL2; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === NULL2){ // l\n      if (buffer[i] === 0x6c) { this.tState = NULL3; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === NULL3){ // l\n      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); }\n      else { this.charError(buffer, i); }\n    }\n  }\n};\nproto.onToken = function (token, value) {\n  // Override this to get events\n};\n\nproto.parseError = function (token, value) {\n  this.onError(new Error(\"Unexpected \" + toknam(token) + (value ? (\"(\" + JSON.stringify(value) + \")\") : \"\") + \" in state \" + toknam(this.state)));\n};\nproto.onError = function (err) { throw err; };\nproto.push = function () {\n  this.stack.push({value: this.value, key: this.key, mode: this.mode});\n};\nproto.pop = function () {\n  var value = this.value;\n  var parent = this.stack.pop();\n  this.value = parent.value;\n  this.key = parent.key;\n  this.mode = parent.mode;\n  this.emit(value);\n  if (!this.mode) { this.state = VALUE; }\n};\nproto.emit = function (value) {\n  if (this.mode) { this.state = COMMA; }\n  this.onValue(value);\n};\nproto.onValue = function (value) {\n  // Override me\n};  \nproto.onToken = function (token, value) {\n  //console.log(\"OnToken: state=%s token=%s %s\", toknam(this.state), toknam(token), value?JSON.stringify(value):\"\");\n  if(this.state === VALUE){\n    if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){\n      if (this.value) {\n        this.value[this.key] = value;\n      }\n      this.emit(value);  \n    }else if(token === LEFT_BRACE){\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = {};\n      } else {\n        this.value = {};\n      }\n      this.key = undefined;\n      this.state = KEY;\n      this.mode = OBJECT;\n    }else if(token === LEFT_BRACKET){\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = [];\n      } else {\n        this.value = [];\n      }\n      this.key = 0;\n      this.mode = ARRAY;\n      this.state = VALUE;\n    }else if(token === RIGHT_BRACE){\n      if (this.mode === OBJECT) {\n        this.pop();\n      } else {\n        this.parseError(token, value);\n      }\n    }else if(token === RIGHT_BRACKET){\n      if (this.mode === ARRAY) {\n        this.pop();\n      } else {\n        this.parseError(token, value);\n      }\n    }else{\n      this.parseError(token, value);\n    }\n  }else if(this.state === KEY){\n    if (token === STRING) {\n      this.key = value;\n      this.state = COLON;\n    } else if (token === RIGHT_BRACE) {\n      this.pop();\n    } else {\n      this.parseError(token, value);\n    }\n  }else if(this.state === COLON){\n    if (token === COLON) { this.state = VALUE; }\n    else { this.parseError(token, value); }\n  }else if(this.state === COMMA){\n    if (token === COMMA) { \n      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }\n      else if (this.mode === OBJECT) { this.state = KEY; }\n\n    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {\n      this.pop();\n    } else {\n      this.parseError(token, value);\n    }\n  }else{\n    this.parseError(token, value);\n  }\n};\n\nmodule.exports = Parser;\n","exports.name = \"through\";\nexports.version = \"2.3.8\";\nexports.main = \"index.js\";\n","var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n"]}}]