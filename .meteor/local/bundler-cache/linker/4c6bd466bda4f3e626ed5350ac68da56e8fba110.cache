[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar _ = Package.underscore._;\nvar meteorInstall = Package['modules-runtime'].meteorInstall;\n\n/* Package-scope variables */\nvar Buffer, process, opts, exports, stream;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"modules\":{\"client.js\":[\"./install-packages.js\",\"./stubs.js\",\"./buffer.js\",\"./process.js\",\"reify/lib/runtime\",\"./css\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/client.js                                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nrequire(\"./install-packages.js\");                                                                                    // 1\nrequire(\"./stubs.js\");                                                                                               // 2\nrequire(\"./buffer.js\");                                                                                              // 3\nrequire(\"./process.js\");                                                                                             // 4\nrequire(\"reify/lib/runtime\").enable(module.constructor);                                                             // 5\n                                                                                                                     // 6\nexports.addStyles = require(\"./css\").addStyles;                                                                      // 7\n                                                                                                                     // 8\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"buffer.js\":[\"buffer\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/buffer.js                                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\ntry {                                                                                                                // 1\n  Buffer = global.Buffer || require(\"buffer\").Buffer;                                                                // 2\n} catch (noBuffer) {}                                                                                                // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"css.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/css.js                                                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar doc = document;                                                                                                  // 1\nvar head = doc.getElementsByTagName(\"head\").item(0);                                                                 // 2\n                                                                                                                     // 3\nexports.addStyles = function (css) {                                                                                 // 4\n  var style = doc.createElement(\"style\");                                                                            // 5\n                                                                                                                     // 6\n  style.setAttribute(\"type\", \"text/css\");                                                                            // 7\n                                                                                                                     // 8\n  // https://msdn.microsoft.com/en-us/library/ms535871(v=vs.85).aspx                                                 // 9\n  var internetExplorerSheetObject =                                                                                  // 10\n    style.sheet || // Edge/IE11.                                                                                     // 11\n    style.styleSheet; // Older IEs.                                                                                  // 12\n                                                                                                                     // 13\n  if (internetExplorerSheetObject) {                                                                                 // 14\n    internetExplorerSheetObject.cssText = css;                                                                       // 15\n  } else {                                                                                                           // 16\n    style.appendChild(doc.createTextNode(css));                                                                      // 17\n  }                                                                                                                  // 18\n                                                                                                                     // 19\n  return head.appendChild(style);                                                                                    // 20\n};                                                                                                                   // 21\n                                                                                                                     // 22\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"install-packages.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/install-packages.js                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nfunction install(name, mainModule) {                                                                                 // 1\n  var meteorDir = {};                                                                                                // 2\n                                                                                                                     // 3\n  // Given a package name <name>, install a stub module in the                                                       // 4\n  // /node_modules/meteor directory called <name>.js, so that                                                        // 5\n  // require.resolve(\"meteor/<name>\") will always return                                                             // 6\n  // /node_modules/meteor/<name>.js instead of something like                                                        // 7\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event                                            // 8\n  // that the package contains a file called index.js (#6590).                                                       // 9\n                                                                                                                     // 10\n  if (mainModule) {                                                                                                  // 11\n    meteorDir[name + \".js\"] = [mainModule, function (require, e, module) {                                           // 12\n      module.exports = require(mainModule);                                                                          // 13\n    }];                                                                                                              // 14\n  } else {                                                                                                           // 15\n    // back compat with old Meteor packages                                                                          // 16\n    meteorDir[name + \".js\"] = function (r, e, module) {                                                              // 17\n      module.exports = Package[name];                                                                                // 18\n    };                                                                                                               // 19\n  }                                                                                                                  // 20\n                                                                                                                     // 21\n  meteorInstall({                                                                                                    // 22\n    node_modules: {                                                                                                  // 23\n      meteor: meteorDir                                                                                              // 24\n    }                                                                                                                // 25\n  });                                                                                                                // 26\n}                                                                                                                    // 27\n                                                                                                                     // 28\n// This file will be modified during computeJsOutputFilesMap to include                                              // 29\n// install(<name>) calls for every Meteor package.                                                                   // 30\n                                                                                                                     // 31\ninstall(\"underscore\");                                                                                               // 32\ninstall(\"meteor\");                                                                                                   // 33\ninstall(\"meteor-base\");                                                                                              // 34\ninstall(\"mobile-experience\");                                                                                        // 35\ninstall(\"modules-runtime\");                                                                                          // 36\ninstall(\"modules\", \"meteor/modules/client.js\");                                                                      // 37\ninstall(\"es5-shim\", \"meteor/es5-shim/client.js\");                                                                    // 38\ninstall(\"promise\", \"meteor/promise/client.js\");                                                                      // 39\ninstall(\"ecmascript-runtime\", \"meteor/ecmascript-runtime/runtime.js\");                                               // 40\ninstall(\"babel-compiler\");                                                                                           // 41\ninstall(\"ecmascript\");                                                                                               // 42\ninstall(\"base64\");                                                                                                   // 43\ninstall(\"ejson\");                                                                                                    // 44\ninstall(\"id-map\");                                                                                                   // 45\ninstall(\"ordered-dict\");                                                                                             // 46\ninstall(\"tracker\");                                                                                                  // 47\ninstall(\"babel-runtime\");                                                                                            // 48\ninstall(\"random\");                                                                                                   // 49\ninstall(\"mongo-id\");                                                                                                 // 50\ninstall(\"diff-sequence\");                                                                                            // 51\ninstall(\"geojson-utils\", \"meteor/geojson-utils/main.js\");                                                            // 52\ninstall(\"minimongo\");                                                                                                // 53\ninstall(\"check\", \"meteor/check/match.js\");                                                                           // 54\ninstall(\"retry\");                                                                                                    // 55\ninstall(\"ddp-common\");                                                                                               // 56\ninstall(\"reload\");                                                                                                   // 57\ninstall(\"ddp-client\");                                                                                               // 58\ninstall(\"ddp\");                                                                                                      // 59\ninstall(\"ddp-server\");                                                                                               // 60\ninstall(\"allow-deny\");                                                                                               // 61\ninstall(\"insecure\");                                                                                                 // 62\ninstall(\"mongo\");                                                                                                    // 63\ninstall(\"blaze-html-templates\");                                                                                     // 64\ninstall(\"reactive-var\");                                                                                             // 65\ninstall(\"jquery\", \"meteor/jquery/main.js\");                                                                          // 66\ninstall(\"standard-minifier-css\");                                                                                    // 67\ninstall(\"standard-minifier-js\");                                                                                     // 68\ninstall(\"autopublish\");                                                                                              // 69\ninstall(\"webapp\");                                                                                                   // 70\ninstall(\"livedata\");                                                                                                 // 71\ninstall(\"hot-code-push\");                                                                                            // 72\ninstall(\"deps\");                                                                                                     // 73\ninstall(\"htmljs\");                                                                                                   // 74\ninstall(\"observe-sequence\");                                                                                         // 75\ninstall(\"blaze\");                                                                                                    // 76\ninstall(\"spacebars\");                                                                                                // 77\ninstall(\"templating\");                                                                                               // 78\ninstall(\"launch-screen\");                                                                                            // 79\ninstall(\"ui\");                                                                                                       // 80\ninstall(\"autoupdate\");                                                                                               // 81\n                                                                                                                     // 82\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"process.js\":[\"process\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/process.js                                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\ntry {                                                                                                                // 1\n  // The application can run `npm install process` to provide its own                                                // 2\n  // process stub; otherwise this module will provide a partial stub.                                                // 3\n  process = global.process || require(\"process\");                                                                    // 4\n} catch (noProcess) {                                                                                                // 5\n  process = {};                                                                                                      // 6\n}                                                                                                                    // 7\n                                                                                                                     // 8\nif (Meteor.isServer) {                                                                                               // 9\n  // Make require(\"process\") work on the server in all versions of Node.                                             // 10\n  meteorInstall({                                                                                                    // 11\n    node_modules: {                                                                                                  // 12\n      \"process.js\": function (r, e, module) {                                                                        // 13\n        module.exports = process;                                                                                    // 14\n      }                                                                                                              // 15\n    }                                                                                                                // 16\n  });                                                                                                                // 17\n} else {                                                                                                             // 18\n  process.platform = \"browser\";                                                                                      // 19\n  process.nextTick = process.nextTick || Meteor._setImmediate;                                                       // 20\n}                                                                                                                    // 21\n                                                                                                                     // 22\nif (typeof process.env !== \"object\") {                                                                               // 23\n  process.env = {};                                                                                                  // 24\n}                                                                                                                    // 25\n                                                                                                                     // 26\n_.extend(process.env, meteorEnv);                                                                                    // 27\n                                                                                                                     // 28\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"stubs.js\":[\"meteor-node-stubs\",function(require){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/modules/stubs.js                                                                                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\ntry {                                                                                                                // 1\n  // When meteor-node-stubs is installed in the application's root                                                   // 2\n  // node_modules directory, requiring it here installs aliases for stubs                                            // 3\n  // for all Node built-in modules, such as fs, util, and http.                                                      // 4\n  require(\"meteor-node-stubs\");                                                                                      // 5\n} catch (noStubs) {}                                                                                                 // 6\n                                                                                                                     // 7\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"node_modules\":{\"reify\":{\"lib\":{\"runtime.js\":[\"./entry.js\",\"./utils.js\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor/modules/node_modules/reify/lib/runtime.js                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar Entry = require(\"./entry.js\").Entry;                                                                             // 1\nvar utils = require(\"./utils.js\");                                                                                   // 2\n                                                                                                                     // 3\nexports.enable = function (Module) {                                                                                 // 4\n  var Mp = Module.prototype;                                                                                         // 5\n                                                                                                                     // 6\n  if (typeof Mp.import === \"function\" &&                                                                             // 7\n      typeof Mp.export === \"function\") {                                                                             // 8\n    // If the Mp.{import,export} methods have already been                                                           // 9\n    // defined, abandon reification immediately.                                                                     // 10\n    return Module;                                                                                                   // 11\n  }                                                                                                                  // 12\n                                                                                                                     // 13\n  // Platform-specific code should implement this method however                                                     // 14\n  // appropriate. Module.prototype.resolve(id) should return an absolute                                             // 15\n  // version of the given module identifier, like require.resolve.                                                   // 16\n  Mp.resolve = Mp.resolve || function resolve(id) {                                                                  // 17\n    throw new Error(\"Module.prototype.resolve not implemented\");                                                     // 18\n  };                                                                                                                 // 19\n                                                                                                                     // 20\n  // Platform-specific code should find a way to call this method whenever                                           // 21\n  // the module system is about to return module.exports from require. This                                          // 22\n  // might happen more than once per module, in case of dependency cycles,                                           // 23\n  // so we want Module.prototype.runModuleSetters to run each time.                                                  // 24\n  Mp.runModuleSetters = function runModuleSetters(valueToPassThrough) {                                              // 25\n    var entry = Entry.get(this.id);                                                                                  // 26\n    if (entry) {                                                                                                     // 27\n      entry.runModuleSetters(this);                                                                                  // 28\n    }                                                                                                                // 29\n                                                                                                                     // 30\n    // Assignments to exported local variables get wrapped with calls to                                             // 31\n    // module.runModuleSetters, so module.runModuleSetters returns the                                               // 32\n    // valueToPassThrough parameter to allow the value of the original                                               // 33\n    // expression to pass through. For example,                                                                      // 34\n    //                                                                                                               // 35\n    //   export var a = 1;                                                                                           // 36\n    //   console.log(a += 3);                                                                                        // 37\n    //                                                                                                               // 38\n    // becomes                                                                                                       // 39\n    //                                                                                                               // 40\n    //   module.export(\"a\", () => a);                                                                                // 41\n    //   var a = 1;                                                                                                  // 42\n    //   console.log(module.runModuleSetters(a += 3));                                                               // 43\n    //                                                                                                               // 44\n    // This ensures module.runModuleSetters runs immediately after the                                               // 45\n    // assignment, and does not interfere with the larger computation.                                               // 46\n    return valueToPassThrough;                                                                                       // 47\n  };                                                                                                                 // 48\n                                                                                                                     // 49\n  function setESModule(module) {                                                                                     // 50\n    var exports = module.exports;                                                                                    // 51\n    if (exports && typeof exports === \"object\") {                                                                    // 52\n      exports.__esModule = true;                                                                                     // 53\n    }                                                                                                                // 54\n  }                                                                                                                  // 55\n                                                                                                                     // 56\n  Mp.import = function (id, setters) {                                                                               // 57\n    var module = this;                                                                                               // 58\n    setESModule(module);                                                                                             // 59\n                                                                                                                     // 60\n    var absoluteId = module.resolve(id);                                                                             // 61\n                                                                                                                     // 62\n    if (setters && typeof setters === \"object\") {                                                                    // 63\n      var entry = Entry.getOrCreate(absoluteId);                                                                     // 64\n      entry.addSetters(module, setters);                                                                             // 65\n    }                                                                                                                // 66\n                                                                                                                     // 67\n    var countBefore = entry && entry.runCount;                                                                       // 68\n    var exports = typeof module.require === \"function\"                                                               // 69\n      ? module.require(absoluteId)                                                                                   // 70\n      : require(absoluteId);                                                                                         // 71\n                                                                                                                     // 72\n    if (entry && entry.runCount === countBefore) {                                                                   // 73\n      // If require(absoluteId) didn't run any setters for this entry,                                               // 74\n      // perhaps because it's not the first time this module has been                                                // 75\n      // required, run the setters now using an object that passes as the                                            // 76\n      // real module object.                                                                                         // 77\n      entry.runModuleSetters({                                                                                       // 78\n        id: absoluteId,                                                                                              // 79\n        exports: exports,                                                                                            // 80\n        getExportByName: Mp.getExportByName                                                                          // 81\n      });                                                                                                            // 82\n    }                                                                                                                // 83\n  };                                                                                                                 // 84\n                                                                                                                     // 85\n  // Register getter functions for local variables in the scope of an                                                // 86\n  // export statement. The keys of the getters object are exported names,                                            // 87\n  // and the values are functions that return local values.                                                          // 88\n  Mp.export = function (getters) {                                                                                   // 89\n    var module = this;                                                                                               // 90\n    setESModule(module);                                                                                             // 91\n                                                                                                                     // 92\n    if (utils.isPlainObject(getters)) {                                                                              // 93\n      Entry.getOrCreate(module.id).addGetters(getters);                                                              // 94\n    }                                                                                                                // 95\n                                                                                                                     // 96\n    if (module.loaded) {                                                                                             // 97\n      // If the module has already been evaluated, then we need to trigger                                           // 98\n      // another round of entry.runModuleSetters calls, which begins by                                              // 99\n      // calling entry.runModuleGetters(module).                                                                     // 100\n      module.runModuleSetters();                                                                                     // 101\n    }                                                                                                                // 102\n  };                                                                                                                 // 103\n                                                                                                                     // 104\n  // This method can be overridden by client code to implement custom export                                         // 105\n  // naming logic. The current implementation works well with Babel's                                                // 106\n  // __esModule convention.                                                                                          // 107\n  Mp.getExportByName = function (name) {                                                                             // 108\n    var exports = this.exports;                                                                                      // 109\n                                                                                                                     // 110\n    if (name === \"*\") {                                                                                              // 111\n      return exports;                                                                                                // 112\n    }                                                                                                                // 113\n                                                                                                                     // 114\n    if (name === \"default\" &&                                                                                        // 115\n        ! (exports &&                                                                                                // 116\n           typeof exports === \"object\" &&                                                                            // 117\n           exports.__esModule &&                                                                                     // 118\n           \"default\" in exports)) {                                                                                  // 119\n      return exports;                                                                                                // 120\n    }                                                                                                                // 121\n                                                                                                                     // 122\n    return exports && exports[name];                                                                                 // 123\n  };                                                                                                                 // 124\n                                                                                                                     // 125\n  return Module;                                                                                                     // 126\n};                                                                                                                   // 127\n                                                                                                                     // 128\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"entry.js\":[\"./utils.js\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor/modules/node_modules/reify/lib/entry.js                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar hasOwn = Object.prototype.hasOwnProperty;                                                                        // 1\nvar entryMap = Object.create(null);                                                                                  // 2\nvar utils = require(\"./utils.js\");                                                                                   // 3\n                                                                                                                     // 4\nfunction Entry(id) {                                                                                                 // 5\n  // Same as module.id for this module.                                                                              // 6\n  this.id = id;                                                                                                      // 7\n  // The number of times this.runModuleSetters has been called.                                                      // 8\n  this.runCount = 0;                                                                                                 // 9\n  // Setters for assigning to local variables in parent modules.                                                     // 10\n  this.setters = Object.create(null);                                                                                // 11\n  // Getters for local variables exported from this module.                                                          // 12\n  this.getters = Object.create(null);                                                                                // 13\n}                                                                                                                    // 14\n                                                                                                                     // 15\nvar Ep = Entry.prototype;                                                                                            // 16\n                                                                                                                     // 17\nEntry.get = function (id) {                                                                                          // 18\n  return entryMap[id] || null;                                                                                       // 19\n};                                                                                                                   // 20\n                                                                                                                     // 21\nEntry.getOrCreate = function (id) {                                                                                  // 22\n  return entryMap[id] = entryMap[id] || new Entry(id);                                                               // 23\n};                                                                                                                   // 24\n                                                                                                                     // 25\nEp.addSetters = function (parent, setters) {                                                                         // 26\n  var entry = this;                                                                                                  // 27\n                                                                                                                     // 28\n  Object.keys(setters).forEach(function (name) {                                                                     // 29\n    var setter = setters[name];                                                                                      // 30\n    if (typeof setter === \"function\" &&                                                                              // 31\n        // Ignore any requests for the exports.__esModule property.\"                                                 // 32\n        name !== \"__esModule\") {                                                                                     // 33\n      setter.parent = parent;                                                                                        // 34\n      (entry.setters[name] =                                                                                         // 35\n       entry.setters[name] || []                                                                                     // 36\n      ).push(setter);                                                                                                // 37\n    }                                                                                                                // 38\n  });                                                                                                                // 39\n};                                                                                                                   // 40\n                                                                                                                     // 41\nEp.addGetters = function (getters) {                                                                                 // 42\n  var entry = this;                                                                                                  // 43\n  Object.keys(getters).forEach(function (name) {                                                                     // 44\n    var getter = getters[name];                                                                                      // 45\n    if (typeof getter === \"function\" &&                                                                              // 46\n        // Ignore any requests for the exports.__esModule property.\"                                                 // 47\n        name !== \"__esModule\") {                                                                                     // 48\n      // Should this throw if hasOwn.call(this.getters, name)?                                                       // 49\n      entry.getters[name] = getter;                                                                                  // 50\n    }                                                                                                                // 51\n  });                                                                                                                // 52\n};                                                                                                                   // 53\n                                                                                                                     // 54\nfunction runModuleSetters(module) {                                                                                  // 55\n  var entry = entryMap[module.id];                                                                                   // 56\n  if (entry) {                                                                                                       // 57\n    entry.runModuleSetters(module);                                                                                  // 58\n  }                                                                                                                  // 59\n}                                                                                                                    // 60\n                                                                                                                     // 61\nfunction runModuleGetters(module) {                                                                                  // 62\n  var entry = entryMap[module.id];                                                                                   // 63\n  return entry ? entry.runModuleGetters(module) : 0;                                                                 // 64\n}                                                                                                                    // 65\n                                                                                                                     // 66\nEp.runModuleGetters = function (module) {                                                                            // 67\n  var entry = this;                                                                                                  // 68\n  var changeCount = 0;                                                                                               // 69\n                                                                                                                     // 70\n  Object.keys(entry.getters).forEach(function (name) {                                                               // 71\n    if (entry.runGetter(module, name)) {                                                                             // 72\n      ++changeCount;                                                                                                 // 73\n    }                                                                                                                // 74\n  });                                                                                                                // 75\n                                                                                                                     // 76\n  return changeCount;                                                                                                // 77\n};                                                                                                                   // 78\n                                                                                                                     // 79\n// Returns true iff the getter updated module.exports with a new value.                                              // 80\nEp.runGetter = function (module, name) {                                                                             // 81\n  if (! hasOwn.call(this.getters, name)) {                                                                           // 82\n    return false;                                                                                                    // 83\n  }                                                                                                                  // 84\n                                                                                                                     // 85\n  var getter = this.getters[name];                                                                                   // 86\n  try {                                                                                                              // 87\n    var value = getter.call(module);                                                                                 // 88\n  } catch (e) {}                                                                                                     // 89\n  var exports = module.exports;                                                                                      // 90\n                                                                                                                     // 91\n  if (! hasOwn.call(exports, name) ||                                                                                // 92\n      exports[name] !== value) {                                                                                     // 93\n    // We update module.exports[name] with the current value so that                                                 // 94\n    // CommonJS require calls remain consistent with module.import.                                                  // 95\n    exports[name] = value;                                                                                           // 96\n    return true;                                                                                                     // 97\n  }                                                                                                                  // 98\n                                                                                                                     // 99\n  return false;                                                                                                      // 100\n};                                                                                                                   // 101\n                                                                                                                     // 102\n// Called whenever module.exports might have changed, to trigger any                                                 // 103\n// setters associated with the newly exported values.                                                                // 104\nEp.runModuleSetters = function (module) {                                                                            // 105\n  var entry = this;                                                                                                  // 106\n  var names = Object.keys(entry.setters);                                                                            // 107\n                                                                                                                     // 108\n  // Make sure module.exports is up to date before we call                                                           // 109\n  // module.getExportByName(name).                                                                                   // 110\n  entry.runModuleGetters(module);                                                                                    // 111\n                                                                                                                     // 112\n  // Invoke the given callback once for every (setter, value, name) triple                                           // 113\n  // that needs to be called. Note that forEachSetter does not call any                                              // 114\n  // setters itself, only the given callback.                                                                        // 115\n  function forEachSetter(callback, context) {                                                                        // 116\n    names.forEach(function (name) {                                                                                  // 117\n      entry.setters[name].forEach(function (setter) {                                                                // 118\n        var value = module.getExportByName(name);                                                                    // 119\n        if (name === \"*\") {                                                                                          // 120\n          Object.keys(value).forEach(function (name) {                                                               // 121\n            call(setter, value[name], name);                                                                         // 122\n          });                                                                                                        // 123\n        } else {                                                                                                     // 124\n          call(setter, value, name);                                                                                 // 125\n        }                                                                                                            // 126\n      });                                                                                                            // 127\n    });                                                                                                              // 128\n                                                                                                                     // 129\n    function call(setter, value, name) {                                                                             // 130\n      if (name === \"__esModule\") {                                                                                   // 131\n        // Ignore setters asking for module.exports.__esModule.                                                      // 132\n        return;                                                                                                      // 133\n      }                                                                                                              // 134\n                                                                                                                     // 135\n      setter.last = setter.last || Object.create(null);                                                              // 136\n                                                                                                                     // 137\n      if (! hasOwn.call(setter.last, name) ||                                                                        // 138\n          setter.last[name] !== value) {                                                                             // 139\n        // Only invoke the callback if we have not called this setter                                                // 140\n        // (with a value of this name) before, or the current value is                                               // 141\n        // different from the last value we passed to this setter.                                                   // 142\n        return callback.apply(context, arguments);                                                                   // 143\n      }                                                                                                              // 144\n    }                                                                                                                // 145\n  }                                                                                                                  // 146\n                                                                                                                     // 147\n  // Every three elements of this list form a (setter, value, name) triple                                           // 148\n  // that needs to be invoked.                                                                                       // 149\n  var settersToCall = [];                                                                                            // 150\n                                                                                                                     // 151\n  // Lazily-initialized objects mapping parent module identifiers to                                                 // 152\n  // relevant parent module objects and snapshots of their exports.                                                  // 153\n  var relevantParents;                                                                                               // 154\n  var parentSnapshots;                                                                                               // 155\n                                                                                                                     // 156\n  // Take snapshots of setter.parent.exports for any setters that we are                                             // 157\n  // planning to call, so that we can later determine if calling the                                                 // 158\n  // setters modified any of those exports objects.                                                                  // 159\n  forEachSetter(function (setter, value, name) {                                                                     // 160\n    var parent = setter.parent;                                                                                      // 161\n    parentSnapshots = parentSnapshots || Object.create(null);                                                        // 162\n    if (! hasOwn.call(parentSnapshots, parent.id)) {                                                                 // 163\n      relevantParents = relevantParents || Object.create(null);                                                      // 164\n      relevantParents[parent.id] = parent;                                                                           // 165\n      if (utils.isPlainObject(parent.exports)) {                                                                     // 166\n        // If parent.exports is an object, make a shallow clone of it so                                             // 167\n        // that we can see if it changes as a result of calling setters.                                             // 168\n        parentSnapshots[parent.id] = utils.assign({}, parent.exports);                                               // 169\n      } else {                                                                                                       // 170\n        // If parent.exports is not an object, the \"snapshot\" is just the                                            // 171\n        // value of parent.exports.                                                                                  // 172\n        parentSnapshots[parent.id] = parent.exports;                                                                 // 173\n      }                                                                                                              // 174\n    }                                                                                                                // 175\n                                                                                                                     // 176\n    // Push three elements at a time to avoid creating wrapper arrays for                                            // 177\n    // each (setter, value, name) triple. Note the i += 3 below.                                                     // 178\n    settersToCall.push(setter, value, name);                                                                         // 179\n  });                                                                                                                // 180\n                                                                                                                     // 181\n  // Now call all the setters that we decided we need to call.                                                       // 182\n  for (var i = 0; i < settersToCall.length; i += 3) {                                                                // 183\n    var setter = settersToCall[i];                                                                                   // 184\n    var value = settersToCall[i + 1];                                                                                // 185\n    var name = settersToCall[i + 2];                                                                                 // 186\n    setter.call(module, setter.last[name] = value, name);                                                            // 187\n  }                                                                                                                  // 188\n                                                                                                                     // 189\n  ++entry.runCount;                                                                                                  // 190\n                                                                                                                     // 191\n  if (! relevantParents) {                                                                                           // 192\n    // If we never called takeSnapshot, then we can avoid checking                                                   // 193\n    // relevantParents and parentSnapshots below.                                                                    // 194\n    return;                                                                                                          // 195\n  }                                                                                                                  // 196\n                                                                                                                     // 197\n  // If any of the setters updated the module.exports of a parent module,                                            // 198\n  // or updated local variables that are exported by that parent module,                                             // 199\n  // then we must re-run any setters registered by that parent module.                                               // 200\n  Object.keys(relevantParents).forEach(function (id) {                                                               // 201\n    var parent = relevantParents[id];                                                                                // 202\n                                                                                                                     // 203\n    if (runModuleGetters(parent) > 0) {                                                                              // 204\n      return runModuleSetters(parent);                                                                               // 205\n    }                                                                                                                // 206\n                                                                                                                     // 207\n    var exports = parent.exports;                                                                                    // 208\n    var snapshot = parentSnapshots[parent.id];                                                                       // 209\n    if (utils.shallowObjEqual(exports, snapshot)) {                                                                  // 210\n      // If parent.exports have not changed since we took the snapshot,                                              // 211\n      // then we do not need to run the parent's setters.                                                            // 212\n      return;                                                                                                        // 213\n    }                                                                                                                // 214\n                                                                                                                     // 215\n    runModuleSetters(parent);                                                                                        // 216\n  });                                                                                                                // 217\n};                                                                                                                   // 218\n                                                                                                                     // 219\nexports.Entry = Entry;                                                                                               // 220\n                                                                                                                     // 221\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"utils.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/meteor/modules/node_modules/reify/lib/utils.js                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar hasOwn = Object.prototype.hasOwnProperty;                                                                        // 1\nvar objToStr = Object.prototype.toString;                                                                            // 2\nvar objStr = objToStr.call({});                                                                                      // 3\n                                                                                                                     // 4\nfunction isPlainObject(value) {                                                                                      // 5\n  return objToStr.call(value) === objStr;                                                                            // 6\n}                                                                                                                    // 7\nexports.isPlainObject = isPlainObject;                                                                               // 8\n                                                                                                                     // 9\nexports.assign = Object.assign || function (obj) {                                                                   // 10\n  var argc = arguments.length;                                                                                       // 11\n  for (var i = 1; i < argc; ++i) {                                                                                   // 12\n    var arg = arguments[i];                                                                                          // 13\n    if (arg && typeof arg === \"object\") {                                                                            // 14\n      var keys = Object.keys(arg);                                                                                   // 15\n      for (var k = 0; k < keys.length; ++k) {                                                                        // 16\n        var key = keys[k];                                                                                           // 17\n        obj[key] = arg[key];                                                                                         // 18\n      }                                                                                                              // 19\n    }                                                                                                                // 20\n  }                                                                                                                  // 21\n  return obj;                                                                                                        // 22\n};                                                                                                                   // 23\n                                                                                                                     // 24\nexports.shallowObjEqual = function(a, b) {                                                                           // 25\n  if (a === b) {                                                                                                     // 26\n    return true;                                                                                                     // 27\n  }                                                                                                                  // 28\n                                                                                                                     // 29\n  if (! isPlainObject(a) ||                                                                                          // 30\n      ! isPlainObject(b)) {                                                                                          // 31\n    return false;                                                                                                    // 32\n  }                                                                                                                  // 33\n                                                                                                                     // 34\n  var aKeys = Object.keys(a);                                                                                        // 35\n  var bKeys = Object.keys(b);                                                                                        // 36\n                                                                                                                     // 37\n  if (aKeys.length !== bKeys.length) {                                                                               // 38\n    return false;                                                                                                    // 39\n  }                                                                                                                  // 40\n                                                                                                                     // 41\n  return aKeys.every(function (key) {                                                                                // 42\n    return hasOwn.call(b, key) &&                                                                                    // 43\n      a[key] === b[key];                                                                                             // 44\n  });                                                                                                                // 45\n};                                                                                                                   // 46\n                                                                                                                     // 47\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}}},\"dockerode\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/package.json                                                                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"dockerode\";                                                                                          // 1\nexports.version = \"2.2.10\";                                                                                          // 2\nexports.main = \"./lib/docker\";                                                                                       // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lib\":{\"docker.js\":[\"events\",\"docker-modem\",\"./container\",\"./image\",\"./volume\",\"./network\",\"./exec\",\"./util\",\"meteor-node-stubs/deps/events\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/docker.js                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar EventEmitter = require('events').EventEmitter,                                                                   // 1\n  Modem = require('docker-modem'),                                                                                   // 2\n  Container = require('./container'),                                                                                // 3\n  Image = require('./image'),                                                                                        // 4\n  Volume = require('./volume'),                                                                                      // 5\n  Network = require('./network'),                                                                                    // 6\n  Exec = require('./exec'),                                                                                          // 7\n  util = require('./util'),                                                                                          // 8\n  extend = util.extend;                                                                                              // 9\n                                                                                                                     // 10\nvar Docker = function(opts) {                                                                                        // 11\n  if (!(this instanceof Docker)) return new Docker(opts);                                                            // 12\n  this.modem = new Modem(opts);                                                                                      // 13\n};                                                                                                                   // 14\n                                                                                                                     // 15\n/**                                                                                                                  // 16\n * Creates a new container                                                                                           // 17\n * @param {Object}   opts     Create options                                                                         // 18\n * @param {Function} callback Callback                                                                               // 19\n */                                                                                                                  // 20\nDocker.prototype.createContainer = function(opts, callback) {                                                        // 21\n  var self = this;                                                                                                   // 22\n  var optsf = {                                                                                                      // 23\n    path: '/containers/create?',                                                                                     // 24\n    method: 'POST',                                                                                                  // 25\n    options: opts,                                                                                                   // 26\n    statusCodes: {                                                                                                   // 27\n      200: true, // unofficial, but proxies may return it                                                            // 28\n      201: true,                                                                                                     // 29\n      404: 'no such container',                                                                                      // 30\n      406: 'impossible to attach',                                                                                   // 31\n      500: 'server error'                                                                                            // 32\n    }                                                                                                                // 33\n  };                                                                                                                 // 34\n                                                                                                                     // 35\n  this.modem.dial(optsf, function(err, data) {                                                                       // 36\n    if (err) return callback(err, data);                                                                             // 37\n    callback(err, self.getContainer(data.Id));                                                                       // 38\n  });                                                                                                                // 39\n};                                                                                                                   // 40\n                                                                                                                     // 41\n/**                                                                                                                  // 42\n * Creates a new image                                                                                               // 43\n * @param {Object}   auth     Authentication (optional)                                                              // 44\n * @param {Object}   opts     Create options                                                                         // 45\n * @param {Function} callback Callback                                                                               // 46\n */                                                                                                                  // 47\nDocker.prototype.createImage = function(auth, opts, callback) {                                                      // 48\n  if (!callback && typeof opts === 'function') {                                                                     // 49\n    callback = opts;                                                                                                 // 50\n    opts = auth;                                                                                                     // 51\n    auth = opts.authconfig || undefined;                                                                             // 52\n  }                                                                                                                  // 53\n                                                                                                                     // 54\n  var self = this;                                                                                                   // 55\n  var optsf = {                                                                                                      // 56\n    path: '/images/create?',                                                                                         // 57\n    method: 'POST',                                                                                                  // 58\n    options: opts,                                                                                                   // 59\n    authconfig: auth,                                                                                                // 60\n    isStream: true,                                                                                                  // 61\n    statusCodes: {                                                                                                   // 62\n      200: true,                                                                                                     // 63\n      500: 'server error'                                                                                            // 64\n    }                                                                                                                // 65\n  };                                                                                                                 // 66\n                                                                                                                     // 67\n  this.modem.dial(optsf, function(err, data) {                                                                       // 68\n    callback(err, data);                                                                                             // 69\n  });                                                                                                                // 70\n};                                                                                                                   // 71\n                                                                                                                     // 72\n/**                                                                                                                  // 73\n * Load image                                                                                                        // 74\n * @param {String}   file     File                                                                                   // 75\n * @param {Object}   opts     Options (optional)                                                                     // 76\n * @param {Function} callback Callback                                                                               // 77\n */                                                                                                                  // 78\nDocker.prototype.loadImage = function(file, opts, callback) {                                                        // 79\n  if (!callback && typeof opts === 'function') {                                                                     // 80\n    callback = opts;                                                                                                 // 81\n    opts = null;                                                                                                     // 82\n  }                                                                                                                  // 83\n                                                                                                                     // 84\n  var self = this;                                                                                                   // 85\n  var optsf = {                                                                                                      // 86\n    path: '/images/load?',                                                                                           // 87\n    method: 'POST',                                                                                                  // 88\n    options: opts,                                                                                                   // 89\n    file: file,                                                                                                      // 90\n    isStream: true,                                                                                                  // 91\n    statusCodes: {                                                                                                   // 92\n      200: true,                                                                                                     // 93\n      500: 'server error'                                                                                            // 94\n    }                                                                                                                // 95\n  };                                                                                                                 // 96\n                                                                                                                     // 97\n  this.modem.dial(optsf, function(err, data) {                                                                       // 98\n    callback(err, data);                                                                                             // 99\n  });                                                                                                                // 100\n};                                                                                                                   // 101\n                                                                                                                     // 102\n/**                                                                                                                  // 103\n * Import image from a tar archive                                                                                   // 104\n * @param {String}   file     File                                                                                   // 105\n * @param {Object}   opts     Options (optional)                                                                     // 106\n * @param {Function} callback Callback                                                                               // 107\n */                                                                                                                  // 108\nDocker.prototype.importImage = function(file, opts, callback) {                                                      // 109\n  if (!callback && typeof opts === 'function') {                                                                     // 110\n    callback = opts;                                                                                                 // 111\n    opts = {};                                                                                                       // 112\n  }                                                                                                                  // 113\n                                                                                                                     // 114\n  opts.fromSrc = '-'                                                                                                 // 115\n                                                                                                                     // 116\n  var self = this;                                                                                                   // 117\n  var optsf = {                                                                                                      // 118\n    path: '/images/create?',                                                                                         // 119\n    method: 'POST',                                                                                                  // 120\n    options: opts,                                                                                                   // 121\n    file: file,                                                                                                      // 122\n    isStream: true,                                                                                                  // 123\n    statusCodes: {                                                                                                   // 124\n      200: true,                                                                                                     // 125\n      500: 'server error'                                                                                            // 126\n    }                                                                                                                // 127\n  };                                                                                                                 // 128\n                                                                                                                     // 129\n  this.modem.dial(optsf, function(err, data) {                                                                       // 130\n    callback(err, data);                                                                                             // 131\n  });                                                                                                                // 132\n};                                                                                                                   // 133\n                                                                                                                     // 134\n/**                                                                                                                  // 135\n * Verifies auth                                                                                                     // 136\n * @param {Object}   opts     Options                                                                                // 137\n * @param {Function} callback Callback                                                                               // 138\n */                                                                                                                  // 139\nDocker.prototype.checkAuth = function(opts, callback) {                                                              // 140\n  var self = this;                                                                                                   // 141\n  var optsf = {                                                                                                      // 142\n    path: '/auth',                                                                                                   // 143\n    method: 'POST',                                                                                                  // 144\n    options: opts,                                                                                                   // 145\n    statusCodes: {                                                                                                   // 146\n      200: true,                                                                                                     // 147\n      204: true,                                                                                                     // 148\n      500: 'server error'                                                                                            // 149\n    }                                                                                                                // 150\n  };                                                                                                                 // 151\n                                                                                                                     // 152\n  this.modem.dial(optsf, function(err, data) {                                                                       // 153\n    callback(err, data);                                                                                             // 154\n  });                                                                                                                // 155\n};                                                                                                                   // 156\n                                                                                                                     // 157\n/**                                                                                                                  // 158\n * Builds an image                                                                                                   // 159\n * @param {String}   file     File                                                                                   // 160\n * @param {Object}   opts     Options (optional)                                                                     // 161\n * @param {Function} callback Callback                                                                               // 162\n */                                                                                                                  // 163\nDocker.prototype.buildImage = function(file, opts, callback) {                                                       // 164\n  if (!callback && typeof opts === 'function') {                                                                     // 165\n    callback = opts;                                                                                                 // 166\n    opts = null;                                                                                                     // 167\n  }                                                                                                                  // 168\n                                                                                                                     // 169\n  var self = this;                                                                                                   // 170\n  var optsf = {                                                                                                      // 171\n    path: '/build?',                                                                                                 // 172\n    method: 'POST',                                                                                                  // 173\n    file: file,                                                                                                      // 174\n    options: opts,                                                                                                   // 175\n    isStream: true,                                                                                                  // 176\n    statusCodes: {                                                                                                   // 177\n      200: true,                                                                                                     // 178\n      500: 'server error'                                                                                            // 179\n    }                                                                                                                // 180\n  };                                                                                                                 // 181\n                                                                                                                     // 182\n  if (opts) {                                                                                                        // 183\n    if (opts.registryconfig) {                                                                                       // 184\n      optsf.registryconfig = optsf.options.registryconfig;                                                           // 185\n      delete optsf.options.registryconfig;                                                                           // 186\n    }                                                                                                                // 187\n                                                                                                                     // 188\n    //undocumented?                                                                                                  // 189\n    if (opts.authconfig) {                                                                                           // 190\n      optsf.authconfig = optsf.options.authconfig;                                                                   // 191\n      delete optsf.options.authconfig;                                                                               // 192\n    }                                                                                                                // 193\n  }                                                                                                                  // 194\n                                                                                                                     // 195\n  this.modem.dial(optsf, function(err, data) {                                                                       // 196\n    callback(err, data);                                                                                             // 197\n  });                                                                                                                // 198\n};                                                                                                                   // 199\n                                                                                                                     // 200\n/**                                                                                                                  // 201\n * Fetches a Container by ID                                                                                         // 202\n * @param {String} id Container's ID                                                                                 // 203\n */                                                                                                                  // 204\nDocker.prototype.getContainer = function(id) {                                                                       // 205\n  return new Container(this.modem, id);                                                                              // 206\n};                                                                                                                   // 207\n                                                                                                                     // 208\n/**                                                                                                                  // 209\n * Fetches an Image by name                                                                                          // 210\n * @param {String} name Image's name                                                                                 // 211\n */                                                                                                                  // 212\nDocker.prototype.getImage = function(name) {                                                                         // 213\n  return new Image(this.modem, name);                                                                                // 214\n};                                                                                                                   // 215\n                                                                                                                     // 216\n/**                                                                                                                  // 217\n * Fetches a Volume by name                                                                                          // 218\n * @param {String} name Volume's name                                                                                // 219\n */                                                                                                                  // 220\nDocker.prototype.getVolume = function(name) {                                                                        // 221\n  return new Volume(this.modem, name);                                                                               // 222\n};                                                                                                                   // 223\n                                                                                                                     // 224\n/**                                                                                                                  // 225\n * Fetches a Network by id                                                                                           // 226\n * @param {String} id network's id                                                                                   // 227\n */                                                                                                                  // 228\nDocker.prototype.getNetwork = function(id) {                                                                         // 229\n  return new Network(this.modem, id);                                                                                // 230\n};                                                                                                                   // 231\n                                                                                                                     // 232\n/**                                                                                                                  // 233\n * Fetches an Exec instance by ID                                                                                    // 234\n * @param {String} id Exec instance's ID                                                                             // 235\n */                                                                                                                  // 236\nDocker.prototype.getExec = function(id) {                                                                            // 237\n  return new Exec(this.modem, id);                                                                                   // 238\n};                                                                                                                   // 239\n                                                                                                                     // 240\n/**                                                                                                                  // 241\n * Lists containers                                                                                                  // 242\n * @param {Options}   opts     Options (optional)                                                                    // 243\n * @param {Function} callback Callback                                                                               // 244\n */                                                                                                                  // 245\nDocker.prototype.listContainers = function(opts, callback) {                                                         // 246\n  var args = util.processArgs(opts, callback);                                                                       // 247\n                                                                                                                     // 248\n  var optsf = {                                                                                                      // 249\n    path: '/containers/json?',                                                                                       // 250\n    method: 'GET',                                                                                                   // 251\n    options: args.opts,                                                                                              // 252\n    statusCodes: {                                                                                                   // 253\n      200: true,                                                                                                     // 254\n      400: 'bad parameter',                                                                                          // 255\n      500: 'server error'                                                                                            // 256\n    }                                                                                                                // 257\n  };                                                                                                                 // 258\n                                                                                                                     // 259\n  this.modem.dial(optsf, function(err, data) {                                                                       // 260\n    args.callback(err, data);                                                                                        // 261\n  });                                                                                                                // 262\n};                                                                                                                   // 263\n                                                                                                                     // 264\n/**                                                                                                                  // 265\n * Lists images                                                                                                      // 266\n * @param {Options}   opts     Options (optional)                                                                    // 267\n * @param {Function} callback Callback                                                                               // 268\n */                                                                                                                  // 269\nDocker.prototype.listImages = function(opts, callback) {                                                             // 270\n  var args = util.processArgs(opts, callback);                                                                       // 271\n                                                                                                                     // 272\n  var optsf = {                                                                                                      // 273\n    path: '/images/json?',                                                                                           // 274\n    method: 'GET',                                                                                                   // 275\n    options: args.opts,                                                                                              // 276\n    statusCodes: {                                                                                                   // 277\n      200: true,                                                                                                     // 278\n      400: 'bad parameter',                                                                                          // 279\n      500: 'server error'                                                                                            // 280\n    }                                                                                                                // 281\n  };                                                                                                                 // 282\n                                                                                                                     // 283\n  this.modem.dial(optsf, function(err, data) {                                                                       // 284\n    args.callback(err, data);                                                                                        // 285\n  });                                                                                                                // 286\n};                                                                                                                   // 287\n                                                                                                                     // 288\n/**                                                                                                                  // 289\n * Creates a new volume                                                                                              // 290\n * @param {Object}   opts     Create options                                                                         // 291\n * @param {Function} callback Callback                                                                               // 292\n */                                                                                                                  // 293\nDocker.prototype.createVolume = function(opts, callback) {                                                           // 294\n  var args = util.processArgs(opts, callback);                                                                       // 295\n  var self = this;                                                                                                   // 296\n  var optsf = {                                                                                                      // 297\n    path: '/volumes/create?',                                                                                        // 298\n    method: 'POST',                                                                                                  // 299\n    options: args.opts,                                                                                              // 300\n    statusCodes: {                                                                                                   // 301\n      200: true, // unofficial, but proxies may return it                                                            // 302\n      201: true,                                                                                                     // 303\n      500: 'server error'                                                                                            // 304\n    }                                                                                                                // 305\n  };                                                                                                                 // 306\n                                                                                                                     // 307\n  this.modem.dial(optsf, function(err, data) {                                                                       // 308\n    if (err) return args.callback(err, data);                                                                        // 309\n    args.callback(err, self.getVolume(data.Name));                                                                   // 310\n  });                                                                                                                // 311\n};                                                                                                                   // 312\n                                                                                                                     // 313\n/**                                                                                                                  // 314\n * Lists volumes                                                                                                     // 315\n * @param {Options}   opts     Options (optional)                                                                    // 316\n * @param {Function} callback Callback                                                                               // 317\n */                                                                                                                  // 318\nDocker.prototype.listVolumes = function(opts, callback) {                                                            // 319\n  var args = util.processArgs(opts, callback);                                                                       // 320\n                                                                                                                     // 321\n  var optsf = {                                                                                                      // 322\n    path: '/volumes?',                                                                                               // 323\n    method: 'GET',                                                                                                   // 324\n    options: args.opts,                                                                                              // 325\n    statusCodes: {                                                                                                   // 326\n      200: true,                                                                                                     // 327\n      400: 'bad parameter',                                                                                          // 328\n      500: 'server error'                                                                                            // 329\n    }                                                                                                                // 330\n  };                                                                                                                 // 331\n                                                                                                                     // 332\n  this.modem.dial(optsf, function(err, data) {                                                                       // 333\n    args.callback(err, data);                                                                                        // 334\n  });                                                                                                                // 335\n};                                                                                                                   // 336\n                                                                                                                     // 337\n/**                                                                                                                  // 338\n * Creates a new network                                                                                             // 339\n * @param {Object}   opts     Create options                                                                         // 340\n * @param {Function} callback Callback                                                                               // 341\n */                                                                                                                  // 342\nDocker.prototype.createNetwork = function(opts, callback) {                                                          // 343\n  var args = util.processArgs(opts, callback);                                                                       // 344\n  var self = this;                                                                                                   // 345\n  var optsf = {                                                                                                      // 346\n    path: '/networks/create?',                                                                                       // 347\n    method: 'POST',                                                                                                  // 348\n    options: args.opts,                                                                                              // 349\n    statusCodes: {                                                                                                   // 350\n      200: true, // unofficial, but proxies may return it                                                            // 351\n      201: true,                                                                                                     // 352\n      404: 'driver not found',                                                                                       // 353\n      500: 'server error'                                                                                            // 354\n    }                                                                                                                // 355\n  };                                                                                                                 // 356\n                                                                                                                     // 357\n  this.modem.dial(optsf, function(err, data) {                                                                       // 358\n    if (err) return args.callback(err, data);                                                                        // 359\n    args.callback(err, self.getNetwork(data.Id));                                                                    // 360\n  });                                                                                                                // 361\n};                                                                                                                   // 362\n                                                                                                                     // 363\n/**                                                                                                                  // 364\n * Lists networkss                                                                                                   // 365\n * @param {Options}   opts     Options (optional)                                                                    // 366\n * @param {Function} callback Callback                                                                               // 367\n */                                                                                                                  // 368\nDocker.prototype.listNetworks = function(opts, callback) {                                                           // 369\n  var args = util.processArgs(opts, callback);                                                                       // 370\n                                                                                                                     // 371\n  var optsf = {                                                                                                      // 372\n    path: '/networks?',                                                                                              // 373\n    method: 'GET',                                                                                                   // 374\n    options: args.opts,                                                                                              // 375\n    statusCodes: {                                                                                                   // 376\n      200: true,                                                                                                     // 377\n      400: 'bad parameter',                                                                                          // 378\n      500: 'server error'                                                                                            // 379\n    }                                                                                                                // 380\n  };                                                                                                                 // 381\n                                                                                                                     // 382\n  this.modem.dial(optsf, function(err, data) {                                                                       // 383\n    args.callback(err, data);                                                                                        // 384\n  });                                                                                                                // 385\n};                                                                                                                   // 386\n                                                                                                                     // 387\n/**                                                                                                                  // 388\n * Search images                                                                                                     // 389\n * @param {Object}   opts     Options                                                                                // 390\n * @param {Function} callback Callback                                                                               // 391\n */                                                                                                                  // 392\nDocker.prototype.searchImages = function(opts, callback) {                                                           // 393\n  var optsf = {                                                                                                      // 394\n    path: '/images/search?',                                                                                         // 395\n    method: 'GET',                                                                                                   // 396\n    options: opts,                                                                                                   // 397\n    statusCodes: {                                                                                                   // 398\n      200: true,                                                                                                     // 399\n      500: 'server error'                                                                                            // 400\n    }                                                                                                                // 401\n  };                                                                                                                 // 402\n                                                                                                                     // 403\n  this.modem.dial(optsf, function(err, data) {                                                                       // 404\n    callback(err, data);                                                                                             // 405\n  });                                                                                                                // 406\n};                                                                                                                   // 407\n                                                                                                                     // 408\n/**                                                                                                                  // 409\n * Info                                                                                                              // 410\n * @param  {Function} callback Callback with info                                                                    // 411\n */                                                                                                                  // 412\nDocker.prototype.info = function(callback) {                                                                         // 413\n  var opts = {                                                                                                       // 414\n    path: '/info',                                                                                                   // 415\n    method: 'GET',                                                                                                   // 416\n    statusCodes: {                                                                                                   // 417\n      200: true,                                                                                                     // 418\n      500: 'server error'                                                                                            // 419\n    }                                                                                                                // 420\n  };                                                                                                                 // 421\n                                                                                                                     // 422\n  this.modem.dial(opts, function(err, data) {                                                                        // 423\n    callback(err, data);                                                                                             // 424\n  });                                                                                                                // 425\n};                                                                                                                   // 426\n                                                                                                                     // 427\n/**                                                                                                                  // 428\n * Version                                                                                                           // 429\n * @param  {Function} callback Callback                                                                              // 430\n */                                                                                                                  // 431\nDocker.prototype.version = function(callback) {                                                                      // 432\n  var opts = {                                                                                                       // 433\n    path: '/version',                                                                                                // 434\n    method: 'GET',                                                                                                   // 435\n    statusCodes: {                                                                                                   // 436\n      200: true,                                                                                                     // 437\n      500: 'server error'                                                                                            // 438\n    }                                                                                                                // 439\n  };                                                                                                                 // 440\n                                                                                                                     // 441\n  this.modem.dial(opts, function(err, data) {                                                                        // 442\n    callback(err, data);                                                                                             // 443\n  });                                                                                                                // 444\n};                                                                                                                   // 445\n                                                                                                                     // 446\n/**                                                                                                                  // 447\n * Ping                                                                                                              // 448\n * @param  {Function} callback Callback                                                                              // 449\n */                                                                                                                  // 450\nDocker.prototype.ping = function(callback) {                                                                         // 451\n  if (!callback && typeof opts === 'function') {                                                                     // 452\n    callback = opts;                                                                                                 // 453\n    opts = null;                                                                                                     // 454\n  }                                                                                                                  // 455\n                                                                                                                     // 456\n  var optsf = {                                                                                                      // 457\n    path: '/_ping',                                                                                                  // 458\n    method: 'GET',                                                                                                   // 459\n    statusCodes: {                                                                                                   // 460\n      200: true,                                                                                                     // 461\n      500: 'server error'                                                                                            // 462\n    }                                                                                                                // 463\n  };                                                                                                                 // 464\n                                                                                                                     // 465\n  this.modem.dial(optsf, function(err, data) {                                                                       // 466\n    callback(err, data);                                                                                             // 467\n  });                                                                                                                // 468\n};                                                                                                                   // 469\n                                                                                                                     // 470\n/**                                                                                                                  // 471\n * Events                                                                                                            // 472\n * @param {Object}   opts     Events options, like 'since' (optional)                                                // 473\n * @param {Function} callback Callback                                                                               // 474\n */                                                                                                                  // 475\nDocker.prototype.getEvents = function(opts, callback) {                                                              // 476\n  var args = util.processArgs(opts, callback);                                                                       // 477\n                                                                                                                     // 478\n  var optsf = {                                                                                                      // 479\n    path: '/events?',                                                                                                // 480\n    method: 'GET',                                                                                                   // 481\n    options: args.opts,                                                                                              // 482\n    isStream: true,                                                                                                  // 483\n    statusCodes: {                                                                                                   // 484\n      200: true,                                                                                                     // 485\n      500: 'server error'                                                                                            // 486\n    }                                                                                                                // 487\n  };                                                                                                                 // 488\n                                                                                                                     // 489\n  this.modem.dial(optsf, function(err, data) {                                                                       // 490\n    args.callback(err, data);                                                                                        // 491\n  });                                                                                                                // 492\n};                                                                                                                   // 493\n                                                                                                                     // 494\n/**                                                                                                                  // 495\n * Pull is a wrapper around parsing out the tag from the image                                                       // 496\n * (which create image cannot do but run can for whatever reasons) and create image overloading.                     // 497\n * @param  {String}   repoTag  Repository tag                                                                        // 498\n * @param  {Object}   opts     Options (optional)                                                                    // 499\n * @param  {Function} callback Callback                                                                              // 500\n * @param  {Object}   auth     Authentication (optional)                                                             // 501\n * @return {Object}            Image                                                                                 // 502\n */                                                                                                                  // 503\nDocker.prototype.pull = function(repoTag, opts, callback, auth) {                                                    // 504\n  var args = util.processArgs(opts, callback);                                                                       // 505\n                                                                                                                     // 506\n  var imageSrc = util.parseRepositoryTag(repoTag);                                                                   // 507\n  args.opts.fromImage = imageSrc.repository;                                                                         // 508\n  args.opts.tag = imageSrc.tag;                                                                                      // 509\n                                                                                                                     // 510\n  var argsf = [args.opts, args.callback];                                                                            // 511\n  if (auth) {                                                                                                        // 512\n    argsf = [auth, args.opts, args.callback];                                                                        // 513\n  }                                                                                                                  // 514\n  return this.createImage.apply(this, argsf);                                                                        // 515\n};                                                                                                                   // 516\n                                                                                                                     // 517\n/**                                                                                                                  // 518\n * Like run command from Docker's CLI                                                                                // 519\n * @param  {String}   image         Image name to be used.                                                           // 520\n * @param  {Array}   cmd           Command to run in array format.                                                   // 521\n * @param  {Object}   streamo       Output stream                                                                    // 522\n * @param  {Object}   createOptions Container create options (optional)                                              // 523\n * @param  {Object}   startOptions  Container start options (optional)                                               // 524\n * @param  {Function} callback      Callback                                                                         // 525\n * @return {Object}                 EventEmitter                                                                     // 526\n */                                                                                                                  // 527\nDocker.prototype.run = function(image, cmd, streamo, createOptions, startOptions, callback) {                        // 528\n  if (!callback && typeof createOptions === 'function') {                                                            // 529\n    callback = createOptions;                                                                                        // 530\n    createOptions = {};                                                                                              // 531\n    startOptions = {};                                                                                               // 532\n  } else if (!callback && typeof startOptions === 'function') {                                                      // 533\n    callback = startOptions;                                                                                         // 534\n    startOptions = {};                                                                                               // 535\n  }                                                                                                                  // 536\n                                                                                                                     // 537\n  var hub = new EventEmitter();                                                                                      // 538\n                                                                                                                     // 539\n  function handler(err, container) {                                                                                 // 540\n    if (err) return callback(err, null, container);                                                                  // 541\n                                                                                                                     // 542\n    hub.emit('container', container);                                                                                // 543\n                                                                                                                     // 544\n    container.attach({                                                                                               // 545\n      stream: true,                                                                                                  // 546\n      stdout: true,                                                                                                  // 547\n      stderr: true                                                                                                   // 548\n    }, function handler(err, stream) {                                                                               // 549\n      if (err) return callback(err, null, container);                                                                // 550\n                                                                                                                     // 551\n      hub.emit('stream', stream);                                                                                    // 552\n                                                                                                                     // 553\n      if (streamo) {                                                                                                 // 554\n        if (streamo instanceof Array) {                                                                              // 555\n          stream.on('end', function() {                                                                              // 556\n            try {                                                                                                    // 557\n              streamo[0].end();                                                                                      // 558\n            } catch (e) {}                                                                                           // 559\n            try {                                                                                                    // 560\n              streamo[1].end();                                                                                      // 561\n            } catch (e) {}                                                                                           // 562\n          });                                                                                                        // 563\n          container.modem.demuxStream(stream, streamo[0], streamo[1]);                                               // 564\n        } else {                                                                                                     // 565\n          stream.setEncoding('utf8');                                                                                // 566\n          stream.pipe(streamo, {                                                                                     // 567\n            end: true                                                                                                // 568\n          });                                                                                                        // 569\n        }                                                                                                            // 570\n      }                                                                                                              // 571\n                                                                                                                     // 572\n      container.start(startOptions, function(err, data) {                                                            // 573\n        if (err) return callback(err, data, container);                                                              // 574\n                                                                                                                     // 575\n        container.wait(function(err, data) {                                                                         // 576\n          hub.emit('data', data);                                                                                    // 577\n          callback(err, data, container);                                                                            // 578\n        });                                                                                                          // 579\n      });                                                                                                            // 580\n    });                                                                                                              // 581\n  }                                                                                                                  // 582\n                                                                                                                     // 583\n  var optsc = {                                                                                                      // 584\n    'Hostname': '',                                                                                                  // 585\n    'User': '',                                                                                                      // 586\n    'AttachStdin': false,                                                                                            // 587\n    'AttachStdout': true,                                                                                            // 588\n    'AttachStderr': true,                                                                                            // 589\n    'Tty': true,                                                                                                     // 590\n    'OpenStdin': false,                                                                                              // 591\n    'StdinOnce': false,                                                                                              // 592\n    'Env': null,                                                                                                     // 593\n    'Cmd': cmd,                                                                                                      // 594\n    'Image': image,                                                                                                  // 595\n    'Volumes': {},                                                                                                   // 596\n    'VolumesFrom': []                                                                                                // 597\n  };                                                                                                                 // 598\n                                                                                                                     // 599\n  extend(optsc, createOptions);                                                                                      // 600\n                                                                                                                     // 601\n  this.createContainer(optsc, handler);                                                                              // 602\n                                                                                                                     // 603\n  return hub;                                                                                                        // 604\n};                                                                                                                   // 605\n                                                                                                                     // 606\nmodule.exports = Docker;                                                                                             // 607\n                                                                                                                     // 608\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"container.js\":[\"./util\",\"./exec\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/container.js                                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar extend = require('./util').extend,                                                                               // 1\n  Exec = require('./exec'),                                                                                          // 2\n  util = require('./util');                                                                                          // 3\n                                                                                                                     // 4\n/**                                                                                                                  // 5\n * Represents a Container                                                                                            // 6\n * @param {Object} modem docker-modem                                                                                // 7\n * @param {String} id    Container's ID                                                                              // 8\n */                                                                                                                  // 9\nvar Container = function(modem, id) {                                                                                // 10\n  this.modem = modem;                                                                                                // 11\n  this.id = id;                                                                                                      // 12\n                                                                                                                     // 13\n  this.defaultOptions = {                                                                                            // 14\n    top: {},                                                                                                         // 15\n    start: {},                                                                                                       // 16\n    commit: {},                                                                                                      // 17\n    stop: {},                                                                                                        // 18\n    pause: {},                                                                                                       // 19\n    unpause: {},                                                                                                     // 20\n    restart: {},                                                                                                     // 21\n    resize: {},                                                                                                      // 22\n    attach: {},                                                                                                      // 23\n    remove: {},                                                                                                      // 24\n    copy: {},                                                                                                        // 25\n    kill: {},                                                                                                        // 26\n    exec: {},                                                                                                        // 27\n    rename: {},                                                                                                      // 28\n    log: {},                                                                                                         // 29\n    stats: {},                                                                                                       // 30\n    getArchive: {},                                                                                                  // 31\n    infoArchive: {},                                                                                                 // 32\n    putArchive: {},                                                                                                  // 33\n    update: {}                                                                                                       // 34\n  };                                                                                                                 // 35\n};                                                                                                                   // 36\n                                                                                                                     // 37\n/**                                                                                                                  // 38\n * Inspect                                                                                                           // 39\n * @param  {Options}  opts     Options (optional)                                                                    // 40\n * @param  {Function} callback Callback, if supplied will query Docker.                                              // 41\n * @return {Object}            ID only and only if callback isn't supplied.                                          // 42\n */                                                                                                                  // 43\nContainer.prototype.inspect = function(opts, callback) {                                                             // 44\n  var args = util.processArgs(opts, callback);                                                                       // 45\n                                                                                                                     // 46\n  if (typeof args.callback === 'function') {                                                                         // 47\n    var optsf = {                                                                                                    // 48\n      path: '/containers/' + this.id + '/json?',                                                                     // 49\n      method: 'GET',                                                                                                 // 50\n      options: args.opts,                                                                                            // 51\n      statusCodes: {                                                                                                 // 52\n        200: true,                                                                                                   // 53\n        404: 'no such container',                                                                                    // 54\n        500: 'server error'                                                                                          // 55\n      }                                                                                                              // 56\n    };                                                                                                               // 57\n                                                                                                                     // 58\n    this.modem.dial(optsf, function(err, data) {                                                                     // 59\n      args.callback(err, data);                                                                                      // 60\n    });                                                                                                              // 61\n  } else {                                                                                                           // 62\n    return JSON.stringify({                                                                                          // 63\n      id: this.id                                                                                                    // 64\n    });                                                                                                              // 65\n  }                                                                                                                  // 66\n};                                                                                                                   // 67\n                                                                                                                     // 68\n/**                                                                                                                  // 69\n * Rename                                                                                                            // 70\n * @param  {Object}   opts     Rename options                                                                        // 71\n * @param  {Function} callback Callback                                                                              // 72\n */                                                                                                                  // 73\nContainer.prototype.rename = function(opts, callback) {                                                              // 74\n  var args = util.processArgs(opts, callback, this.defaultOptions.rename);                                           // 75\n                                                                                                                     // 76\n  var optsf = {                                                                                                      // 77\n    path: '/containers/' + this.id + '/rename?',                                                                     // 78\n    method: 'POST',                                                                                                  // 79\n    statusCodes: {                                                                                                   // 80\n      200: true,                                                                                                     // 81\n      204: true,                                                                                                     // 82\n      404: 'no such container',                                                                                      // 83\n      500: 'server error'                                                                                            // 84\n    },                                                                                                               // 85\n    options: args.opts                                                                                               // 86\n  };                                                                                                                 // 87\n                                                                                                                     // 88\n  this.modem.dial(optsf, function(err, data) {                                                                       // 89\n    args.callback(err, data);                                                                                        // 90\n  });                                                                                                                // 91\n};                                                                                                                   // 92\n                                                                                                                     // 93\n/**                                                                                                                  // 94\n * Update                                                                                                            // 95\n * @param  {Object}   opts     Update options                                                                        // 96\n * @param  {Function} callback Callback                                                                              // 97\n */                                                                                                                  // 98\nContainer.prototype.update = function(opts, callback) {                                                              // 99\n  var args = util.processArgs(opts, callback, this.defaultOptions.update);                                           // 100\n                                                                                                                     // 101\n  var optsf = {                                                                                                      // 102\n    path: '/containers/' + this.id + '/update',                                                                      // 103\n    method: 'POST',                                                                                                  // 104\n    statusCodes: {                                                                                                   // 105\n      200: true,                                                                                                     // 106\n      204: true,                                                                                                     // 107\n      400: 'bad parameter',                                                                                          // 108\n      404: 'no such container',                                                                                      // 109\n      500: 'server error'                                                                                            // 110\n    },                                                                                                               // 111\n    options: args.opts                                                                                               // 112\n  };                                                                                                                 // 113\n                                                                                                                     // 114\n  this.modem.dial(optsf, function(err, data) {                                                                       // 115\n    args.callback(err, data);                                                                                        // 116\n  });                                                                                                                // 117\n};                                                                                                                   // 118\n                                                                                                                     // 119\n/**                                                                                                                  // 120\n * Top                                                                                                               // 121\n * @param  {Object}   Options like 'ps_args' (optional)                                                              // 122\n * @param  {Function} callback Callback                                                                              // 123\n */                                                                                                                  // 124\nContainer.prototype.top = function(opts, callback) {                                                                 // 125\n  var args = util.processArgs(opts, callback, this.defaultOptions.top);                                              // 126\n                                                                                                                     // 127\n  var optsf = {                                                                                                      // 128\n    path: '/containers/' + this.id + '/top?',                                                                        // 129\n    method: 'GET',                                                                                                   // 130\n    statusCodes: {                                                                                                   // 131\n      200: true,                                                                                                     // 132\n      404: 'no such container',                                                                                      // 133\n      500: 'server error'                                                                                            // 134\n    },                                                                                                               // 135\n    options: args.opts                                                                                               // 136\n  };                                                                                                                 // 137\n                                                                                                                     // 138\n  this.modem.dial(optsf, function(err, data) {                                                                       // 139\n    args.callback(err, data);                                                                                        // 140\n  });                                                                                                                // 141\n};                                                                                                                   // 142\n                                                                                                                     // 143\n/**                                                                                                                  // 144\n * Containers changes                                                                                                // 145\n * @param  {Function} callback Callback                                                                              // 146\n */                                                                                                                  // 147\nContainer.prototype.changes = function(callback) {                                                                   // 148\n  var optsf = {                                                                                                      // 149\n    path: '/containers/' + this.id + '/changes',                                                                     // 150\n    method: 'GET',                                                                                                   // 151\n    statusCodes: {                                                                                                   // 152\n      200: true,                                                                                                     // 153\n      404: 'no such container',                                                                                      // 154\n      500: 'server error'                                                                                            // 155\n    }                                                                                                                // 156\n  };                                                                                                                 // 157\n                                                                                                                     // 158\n  this.modem.dial(optsf, function(err, data) {                                                                       // 159\n    callback(err, data);                                                                                             // 160\n  });                                                                                                                // 161\n};                                                                                                                   // 162\n                                                                                                                     // 163\n/**                                                                                                                  // 164\n * Export                                                                                                            // 165\n * @param  {Function} callback Callback with the octet-stream.                                                       // 166\n */                                                                                                                  // 167\nContainer.prototype.export = function(callback) {                                                                    // 168\n  var optsf = {                                                                                                      // 169\n    path: '/containers/' + this.id + '/export',                                                                      // 170\n    method: 'GET',                                                                                                   // 171\n    isStream: true,                                                                                                  // 172\n    statusCodes: {                                                                                                   // 173\n      200: true,                                                                                                     // 174\n      404: 'no such container',                                                                                      // 175\n      500: 'server error'                                                                                            // 176\n    }                                                                                                                // 177\n  };                                                                                                                 // 178\n                                                                                                                     // 179\n  this.modem.dial(optsf, function(err, data) {                                                                       // 180\n    callback(err, data);                                                                                             // 181\n  });                                                                                                                // 182\n};                                                                                                                   // 183\n                                                                                                                     // 184\n/**                                                                                                                  // 185\n * Start                                                                                                             // 186\n * @param  {Object}   opts     Container start options (optional)                                                    // 187\n * @param  {Function} callback Callback                                                                              // 188\n */                                                                                                                  // 189\nContainer.prototype.start = function(opts, callback) {                                                               // 190\n  var args = util.processArgs(opts, callback, this.defaultOptions.start);                                            // 191\n                                                                                                                     // 192\n  var optsf = {                                                                                                      // 193\n    path: '/containers/' + this.id + '/start',                                                                       // 194\n    method: 'POST',                                                                                                  // 195\n    statusCodes: {                                                                                                   // 196\n      200: true, // unofficial, but proxies may return it                                                            // 197\n      204: true,                                                                                                     // 198\n      304: 'container already started',                                                                              // 199\n      404: 'no such container',                                                                                      // 200\n      500: 'server error'                                                                                            // 201\n    },                                                                                                               // 202\n    options: args.opts                                                                                               // 203\n  };                                                                                                                 // 204\n                                                                                                                     // 205\n  this.modem.dial(optsf, function(err, data) {                                                                       // 206\n    args.callback(err, data);                                                                                        // 207\n  });                                                                                                                // 208\n};                                                                                                                   // 209\n                                                                                                                     // 210\n/**                                                                                                                  // 211\n * Pause                                                                                                             // 212\n * @param  {Object}   opts     Pause options (optional)                                                              // 213\n * @param  {Function} callback Callback                                                                              // 214\n */                                                                                                                  // 215\nContainer.prototype.pause = function(opts, callback) {                                                               // 216\n  var args = util.processArgs(opts, callback, this.defaultOptions.pause);                                            // 217\n                                                                                                                     // 218\n  var optsf = {                                                                                                      // 219\n    path: '/containers/' + this.id + '/pause',                                                                       // 220\n    method: 'POST',                                                                                                  // 221\n    statusCodes: {                                                                                                   // 222\n      200: true, // unofficial, but proxies may return it                                                            // 223\n      204: true,                                                                                                     // 224\n      500: 'server error'                                                                                            // 225\n    },                                                                                                               // 226\n    options: args.opts                                                                                               // 227\n  };                                                                                                                 // 228\n                                                                                                                     // 229\n  this.modem.dial(optsf, function(err, data) {                                                                       // 230\n    args.callback(err, data);                                                                                        // 231\n  });                                                                                                                // 232\n};                                                                                                                   // 233\n                                                                                                                     // 234\n/**                                                                                                                  // 235\n * Unpause                                                                                                           // 236\n * @param  {Object}   opts     Unpause options (optional)                                                            // 237\n * @param  {Function} callback Callback                                                                              // 238\n */                                                                                                                  // 239\nContainer.prototype.unpause = function(opts, callback) {                                                             // 240\n  var args = util.processArgs(opts, callback, this.defaultOptions.unpause);                                          // 241\n                                                                                                                     // 242\n  var optsf = {                                                                                                      // 243\n    path: '/containers/' + this.id + '/unpause',                                                                     // 244\n    method: 'POST',                                                                                                  // 245\n    statusCodes: {                                                                                                   // 246\n      200: true, // unofficial, but proxies may return it                                                            // 247\n      204: true,                                                                                                     // 248\n      404: 'no such container',                                                                                      // 249\n      500: 'server error'                                                                                            // 250\n    },                                                                                                               // 251\n    options: args.opts                                                                                               // 252\n  };                                                                                                                 // 253\n                                                                                                                     // 254\n  this.modem.dial(optsf, function(err, data) {                                                                       // 255\n    args.callback(err, data);                                                                                        // 256\n  });                                                                                                                // 257\n};                                                                                                                   // 258\n                                                                                                                     // 259\n/**                                                                                                                  // 260\n * Setup an exec call to a running container                                                                         // 261\n *                                                                                                                   // 262\n * @param {object} opts                                                                                              // 263\n * @param {function} callback                                                                                        // 264\n */                                                                                                                  // 265\nContainer.prototype.exec = function(opts, callback) {                                                                // 266\n  var args = util.processArgs(opts, callback, this.defaultOptions.exec);                                             // 267\n                                                                                                                     // 268\n  var optsf = {                                                                                                      // 269\n    path: '/containers/' + this.id + '/exec',                                                                        // 270\n    method: 'POST',                                                                                                  // 271\n    statusCodes: {                                                                                                   // 272\n      200: true, // unofficial, but proxies may return it                                                            // 273\n      201: true,                                                                                                     // 274\n      404: 'no such container',                                                                                      // 275\n      500: 'server error'                                                                                            // 276\n    },                                                                                                               // 277\n    options: args.opts                                                                                               // 278\n  };                                                                                                                 // 279\n                                                                                                                     // 280\n  var self = this;                                                                                                   // 281\n  this.modem.dial(optsf, function(err, data) {                                                                       // 282\n    if (err) return args.callback(err, data);                                                                        // 283\n    args.callback(err, new Exec(self.modem, data.Id));                                                               // 284\n  });                                                                                                                // 285\n};                                                                                                                   // 286\n                                                                                                                     // 287\n/**                                                                                                                  // 288\n * Commit                                                                                                            // 289\n * @param  {Object}   opts     Commit options like 'Hostname' (optional)                                             // 290\n * @param  {Function} callback Callback                                                                              // 291\n */                                                                                                                  // 292\nContainer.prototype.commit = function(opts, callback) {                                                              // 293\n  var args = util.processArgs(opts, callback, this.defaultOptions.commit);                                           // 294\n                                                                                                                     // 295\n  args.opts.container = this.id;                                                                                     // 296\n                                                                                                                     // 297\n  var optsf = {                                                                                                      // 298\n    path: '/commit?',                                                                                                // 299\n    method: 'POST',                                                                                                  // 300\n    statusCodes: {                                                                                                   // 301\n      200: true, // unofficial, but proxies may return it                                                            // 302\n      201: true,                                                                                                     // 303\n      404: 'no such container',                                                                                      // 304\n      500: 'server error'                                                                                            // 305\n    },                                                                                                               // 306\n    options: args.opts                                                                                               // 307\n  };                                                                                                                 // 308\n                                                                                                                     // 309\n  this.modem.dial(optsf, function(err, data) {                                                                       // 310\n    args.callback(err, data);                                                                                        // 311\n  });                                                                                                                // 312\n};                                                                                                                   // 313\n                                                                                                                     // 314\n/**                                                                                                                  // 315\n * Stop                                                                                                              // 316\n * @param  {Object}   opts     Container stop options, like 't' (optional)                                           // 317\n * @param  {Function} callback Callback                                                                              // 318\n */                                                                                                                  // 319\nContainer.prototype.stop = function(opts, callback) {                                                                // 320\n  var args = util.processArgs(opts, callback, this.defaultOptions.stop);                                             // 321\n                                                                                                                     // 322\n  var optsf = {                                                                                                      // 323\n    path: '/containers/' + this.id + '/stop?',                                                                       // 324\n    method: 'POST',                                                                                                  // 325\n    statusCodes: {                                                                                                   // 326\n      200: true, // unofficial, but proxies may return it                                                            // 327\n      204: true,                                                                                                     // 328\n      304: 'container already stopped',                                                                              // 329\n      404: 'no such container',                                                                                      // 330\n      500: 'server error'                                                                                            // 331\n    },                                                                                                               // 332\n    options: args.opts                                                                                               // 333\n  };                                                                                                                 // 334\n                                                                                                                     // 335\n  this.modem.dial(optsf, function(err, data) {                                                                       // 336\n    args.callback(err, data);                                                                                        // 337\n  });                                                                                                                // 338\n};                                                                                                                   // 339\n                                                                                                                     // 340\n/**                                                                                                                  // 341\n * Restart                                                                                                           // 342\n * @param  {Object}   opts     Container restart options, like 't' (optional)                                        // 343\n * @param  {Function} callback Callback                                                                              // 344\n */                                                                                                                  // 345\nContainer.prototype.restart = function(opts, callback) {                                                             // 346\n  var args = util.processArgs(opts, callback, this.defaultOptions.restart);                                          // 347\n                                                                                                                     // 348\n  var optsf = {                                                                                                      // 349\n    path: '/containers/' + this.id + '/restart',                                                                     // 350\n    method: 'POST',                                                                                                  // 351\n    statusCodes: {                                                                                                   // 352\n      200: true, // unofficial, but proxies may return it                                                            // 353\n      204: true,                                                                                                     // 354\n      404: 'no such container',                                                                                      // 355\n      500: 'server error'                                                                                            // 356\n    },                                                                                                               // 357\n    options: args.opts                                                                                               // 358\n  };                                                                                                                 // 359\n                                                                                                                     // 360\n  this.modem.dial(optsf, function(err, data) {                                                                       // 361\n    args.callback(err, data);                                                                                        // 362\n  });                                                                                                                // 363\n};                                                                                                                   // 364\n                                                                                                                     // 365\n/**                                                                                                                  // 366\n * Kill                                                                                                              // 367\n * @param  {Object}   opts     Container kill options, like 'signal' (optional)                                      // 368\n * @param  {Function} callback Callback                                                                              // 369\n */                                                                                                                  // 370\nContainer.prototype.kill = function(opts, callback) {                                                                // 371\n  var args = util.processArgs(opts, callback, this.defaultOptions.kill);                                             // 372\n                                                                                                                     // 373\n  var optsf = {                                                                                                      // 374\n    path: '/containers/' + this.id + '/kill?',                                                                       // 375\n    method: 'POST',                                                                                                  // 376\n    statusCodes: {                                                                                                   // 377\n      200: true, // unofficial, but proxies may return it                                                            // 378\n      204: true,                                                                                                     // 379\n      404: 'no such container',                                                                                      // 380\n      500: 'server error'                                                                                            // 381\n    },                                                                                                               // 382\n    options: args.opts                                                                                               // 383\n  };                                                                                                                 // 384\n                                                                                                                     // 385\n  this.modem.dial(optsf, function(err, data) {                                                                       // 386\n    args.callback(err, data);                                                                                        // 387\n  });                                                                                                                // 388\n};                                                                                                                   // 389\n                                                                                                                     // 390\n/**                                                                                                                  // 391\n * Container resize                                                                                                  // 392\n * @param  {[type]}   opts     Resize options. (optional)                                                            // 393\n * @param  {Function} callback Callback                                                                              // 394\n */                                                                                                                  // 395\nContainer.prototype.resize = function(opts, callback) {                                                              // 396\n  var args = util.processArgs(opts, callback, this.defaultOptions.resize);                                           // 397\n                                                                                                                     // 398\n  var optsf = {                                                                                                      // 399\n    path: '/containers/' + this.id + '/resize?',                                                                     // 400\n    method: 'POST',                                                                                                  // 401\n    statusCodes: {                                                                                                   // 402\n      200: true,                                                                                                     // 403\n      400: 'bad parameter',                                                                                          // 404\n      404: 'no such container',                                                                                      // 405\n      500: 'server error'                                                                                            // 406\n    },                                                                                                               // 407\n    options: args.opts                                                                                               // 408\n  };                                                                                                                 // 409\n                                                                                                                     // 410\n  this.modem.dial(optsf, function(err, data) {                                                                       // 411\n    args.callback(err, data);                                                                                        // 412\n  });                                                                                                                // 413\n};                                                                                                                   // 414\n                                                                                                                     // 415\n/**                                                                                                                  // 416\n * Attach                                                                                                            // 417\n * @param  {Object}   opts     Attach options, like 'logs' (optional)                                                // 418\n * @param  {Function} callback Callback with stream.                                                                 // 419\n */                                                                                                                  // 420\nContainer.prototype.attach = function(opts, callback) {                                                              // 421\n  var args = util.processArgs(opts, callback, this.defaultOptions.attach);                                           // 422\n                                                                                                                     // 423\n  var optsf = {                                                                                                      // 424\n    path: '/containers/' + this.id + '/attach?',                                                                     // 425\n    method: 'POST',                                                                                                  // 426\n    isStream: true,                                                                                                  // 427\n    hijack: args.opts.hijack,                                                                                        // 428\n    openStdin: args.opts.stdin,                                                                                      // 429\n    statusCodes: {                                                                                                   // 430\n      200: true,                                                                                                     // 431\n      404: 'no such container',                                                                                      // 432\n      500: 'server error'                                                                                            // 433\n    },                                                                                                               // 434\n    options: args.opts                                                                                               // 435\n  };                                                                                                                 // 436\n                                                                                                                     // 437\n  this.modem.dial(optsf, function(err, stream) {                                                                     // 438\n    args.callback(err, stream);                                                                                      // 439\n  });                                                                                                                // 440\n};                                                                                                                   // 441\n                                                                                                                     // 442\n/**                                                                                                                  // 443\n * Waits for a container to end.                                                                                     // 444\n * @param  {Function} callback Callback                                                                              // 445\n */                                                                                                                  // 446\nContainer.prototype.wait = function(callback) {                                                                      // 447\n  var optsf = {                                                                                                      // 448\n    path: '/containers/' + this.id + '/wait',                                                                        // 449\n    method: 'POST',                                                                                                  // 450\n    statusCodes: {                                                                                                   // 451\n      200: true,                                                                                                     // 452\n      400: 'bad parameter',                                                                                          // 453\n      404: 'no such container',                                                                                      // 454\n      500: 'server error'                                                                                            // 455\n    }                                                                                                                // 456\n  };                                                                                                                 // 457\n                                                                                                                     // 458\n  this.modem.dial(optsf, function(err, data) {                                                                       // 459\n    callback(err, data);                                                                                             // 460\n  });                                                                                                                // 461\n};                                                                                                                   // 462\n                                                                                                                     // 463\n/**                                                                                                                  // 464\n * Removes a container                                                                                               // 465\n * @param  {Object}   opts     Remove options, like 'force' (optional)                                               // 466\n * @param  {Function} callback Callback                                                                              // 467\n */                                                                                                                  // 468\nContainer.prototype.remove = function(opts, callback) {                                                              // 469\n  var args = util.processArgs(opts, callback, this.defaultOptions.remove);                                           // 470\n                                                                                                                     // 471\n  var optsf = {                                                                                                      // 472\n    path: '/containers/' + this.id + '?',                                                                            // 473\n    method: 'DELETE',                                                                                                // 474\n    statusCodes: {                                                                                                   // 475\n      200: true, // unofficial, but proxies may return it                                                            // 476\n      204: true,                                                                                                     // 477\n      400: 'bad parameter',                                                                                          // 478\n      404: 'no such container',                                                                                      // 479\n      500: 'server error'                                                                                            // 480\n    },                                                                                                               // 481\n    options: args.opts                                                                                               // 482\n  };                                                                                                                 // 483\n                                                                                                                     // 484\n  this.modem.dial(optsf, function(err, data) {                                                                       // 485\n    args.callback(err, data);                                                                                        // 486\n  });                                                                                                                // 487\n};                                                                                                                   // 488\n                                                                                                                     // 489\n/**                                                                                                                  // 490\n * Copy (WARNING: DEPRECATED since RAPI v1.20)                                                                       // 491\n * @param  {Object}   opts     Copy options, like 'Resource' (optional)                                              // 492\n * @param  {Function} callback Callback with stream.                                                                 // 493\n */                                                                                                                  // 494\nContainer.prototype.copy = function(opts, callback) {                                                                // 495\n  console.log('container.copy is deprecated since Docker v1.8.x');                                                   // 496\n  var args = util.processArgs(opts, callback, this.defaultOptions.copy);                                             // 497\n                                                                                                                     // 498\n  var optsf = {                                                                                                      // 499\n    path: '/containers/' + this.id + '/copy',                                                                        // 500\n    method: 'POST',                                                                                                  // 501\n    isStream: true,                                                                                                  // 502\n    statusCodes: {                                                                                                   // 503\n      200: true,                                                                                                     // 504\n      404: 'no such container',                                                                                      // 505\n      500: 'server error'                                                                                            // 506\n    },                                                                                                               // 507\n    options: args.opts                                                                                               // 508\n  };                                                                                                                 // 509\n                                                                                                                     // 510\n  this.modem.dial(optsf, function(err, data) {                                                                       // 511\n    args.callback(err, data);                                                                                        // 512\n  });                                                                                                                // 513\n};                                                                                                                   // 514\n                                                                                                                     // 515\n/**                                                                                                                  // 516\n * getArchive                                                                                                        // 517\n * @param  {Object}   opts     Archive options, like 'path'                                                          // 518\n * @param  {Function} callback Callback with stream.                                                                 // 519\n */                                                                                                                  // 520\nContainer.prototype.getArchive = function(opts, callback) {                                                          // 521\n  var args = util.processArgs(opts, callback, this.defaultOptions.getArchive);                                       // 522\n                                                                                                                     // 523\n  var optsf = {                                                                                                      // 524\n    path: '/containers/' + this.id + '/archive?',                                                                    // 525\n    method: 'GET',                                                                                                   // 526\n    isStream: true,                                                                                                  // 527\n    statusCodes: {                                                                                                   // 528\n      200: true,                                                                                                     // 529\n      400: 'client error, bad parameters',                                                                           // 530\n      404: 'no such container',                                                                                      // 531\n      500: 'server error'                                                                                            // 532\n    },                                                                                                               // 533\n    options: args.opts                                                                                               // 534\n  };                                                                                                                 // 535\n                                                                                                                     // 536\n  this.modem.dial(optsf, function(err, data) {                                                                       // 537\n    args.callback(err, data);                                                                                        // 538\n  });                                                                                                                // 539\n};                                                                                                                   // 540\n                                                                                                                     // 541\n/**                                                                                                                  // 542\n * infoArchive                                                                                                       // 543\n * @param  {Object}   opts     Archive options, like 'path'                                                          // 544\n * @param  {Function} callback Callback with stream.                                                                 // 545\n */                                                                                                                  // 546\nContainer.prototype.infoArchive = function(opts, callback) {                                                         // 547\n  var args = util.processArgs(opts, callback, this.defaultOptions.infoArchive);                                      // 548\n                                                                                                                     // 549\n  var optsf = {                                                                                                      // 550\n    path: '/containers/' + this.id + '/archive?',                                                                    // 551\n    method: 'HEAD',                                                                                                  // 552\n    isStream: true,                                                                                                  // 553\n    statusCodes: {                                                                                                   // 554\n      200: true,                                                                                                     // 555\n      400: 'client error, bad parameters',                                                                           // 556\n      404: 'no such container',                                                                                      // 557\n      500: 'server error'                                                                                            // 558\n    },                                                                                                               // 559\n    options: args.opts                                                                                               // 560\n  };                                                                                                                 // 561\n                                                                                                                     // 562\n  this.modem.dial(optsf, function(err, data) {                                                                       // 563\n    args.callback(err, data);                                                                                        // 564\n  });                                                                                                                // 565\n};                                                                                                                   // 566\n                                                                                                                     // 567\n/**                                                                                                                  // 568\n * putArchive                                                                                                        // 569\n * @param  {Object}   opts     Archive options, like 'path'                                                          // 570\n * @param  {Function} callback Callback with stream.                                                                 // 571\n */                                                                                                                  // 572\nContainer.prototype.putArchive = function(file, opts, callback) {                                                    // 573\n  var args = util.processArgs(opts, callback, this.defaultOptions.putArchive);                                       // 574\n                                                                                                                     // 575\n  var optsf = {                                                                                                      // 576\n    path: '/containers/' + this.id + '/archive?',                                                                    // 577\n    method: 'PUT',                                                                                                   // 578\n    file: file,                                                                                                      // 579\n    isStream: true,                                                                                                  // 580\n    statusCodes: {                                                                                                   // 581\n      200: true,                                                                                                     // 582\n      400: 'client error, bad parameters',                                                                           // 583\n      403: 'client error, permission denied',                                                                        // 584\n      404: 'no such container',                                                                                      // 585\n      500: 'server error'                                                                                            // 586\n    },                                                                                                               // 587\n    options: args.opts                                                                                               // 588\n  };                                                                                                                 // 589\n                                                                                                                     // 590\n  this.modem.dial(optsf, function(err, data) {                                                                       // 591\n    args.callback(err, data);                                                                                        // 592\n  });                                                                                                                // 593\n};                                                                                                                   // 594\n                                                                                                                     // 595\n/**                                                                                                                  // 596\n * Container logs                                                                                                    // 597\n * @param  {Object}   opts     Logs options. (optional)                                                              // 598\n * @param  {Function} callback Callback with data                                                                    // 599\n */                                                                                                                  // 600\nContainer.prototype.logs = function(opts, callback) {                                                                // 601\n  var args = util.processArgs(opts, callback, this.defaultOptions.log);                                              // 602\n                                                                                                                     // 603\n  var optsf = {                                                                                                      // 604\n    path: '/containers/' + this.id + '/logs?',                                                                       // 605\n    method: 'GET',                                                                                                   // 606\n    isStream: true,                                                                                                  // 607\n    statusCodes: {                                                                                                   // 608\n      200: true,                                                                                                     // 609\n      404: 'no such container',                                                                                      // 610\n      500: 'server error'                                                                                            // 611\n    },                                                                                                               // 612\n    options: args.opts                                                                                               // 613\n  };                                                                                                                 // 614\n                                                                                                                     // 615\n  this.modem.dial(optsf, function(err, data) {                                                                       // 616\n    args.callback(err, data);                                                                                        // 617\n  });                                                                                                                // 618\n};                                                                                                                   // 619\n                                                                                                                     // 620\n/**                                                                                                                  // 621\n * Container stats                                                                                                   // 622\n * @param  {Object}   opts     Stats options. (optional)                                                             // 623\n * @param  {Function} callback Callback with data                                                                    // 624\n */                                                                                                                  // 625\nContainer.prototype.stats = function(opts, callback) {                                                               // 626\n  var args = util.processArgs(opts, callback, this.defaultOptions.stats);                                            // 627\n                                                                                                                     // 628\n  var optsf = {                                                                                                      // 629\n    path: '/containers/' + this.id + '/stats?',                                                                      // 630\n    method: 'GET',                                                                                                   // 631\n    isStream: true,                                                                                                  // 632\n    statusCodes: {                                                                                                   // 633\n      200: true,                                                                                                     // 634\n      404: 'no such container',                                                                                      // 635\n      500: 'server error'                                                                                            // 636\n    },                                                                                                               // 637\n    options: args.opts                                                                                               // 638\n  };                                                                                                                 // 639\n                                                                                                                     // 640\n  this.modem.dial(optsf, function(err, data) {                                                                       // 641\n    args.callback(err, data);                                                                                        // 642\n  });                                                                                                                // 643\n};                                                                                                                   // 644\n                                                                                                                     // 645\nmodule.exports = Container;                                                                                          // 646\n                                                                                                                     // 647\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"util.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/util.js                                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// https://github.com/HenrikJoreteg/extend-object/blob/v0.1.0/extend-object.js                                       // 1\n                                                                                                                     // 2\nvar arr = [];                                                                                                        // 3\nvar each = arr.forEach;                                                                                              // 4\nvar slice = arr.slice;                                                                                               // 5\n                                                                                                                     // 6\nmodule.exports.extend = function(obj) {                                                                              // 7\n  each.call(slice.call(arguments, 1), function(source) {                                                             // 8\n    if (source) {                                                                                                    // 9\n      for (var prop in source) {                                                                                     // 10\n        obj[prop] = source[prop];                                                                                    // 11\n      }                                                                                                              // 12\n    }                                                                                                                // 13\n  });                                                                                                                // 14\n  return obj;                                                                                                        // 15\n};                                                                                                                   // 16\n                                                                                                                     // 17\nmodule.exports.processArgs = function(opts, callback, defaultOpts) {                                                 // 18\n  if (!callback && typeof opts === 'function') {                                                                     // 19\n    callback = opts;                                                                                                 // 20\n    opts = null;                                                                                                     // 21\n  }                                                                                                                  // 22\n  return {                                                                                                           // 23\n    callback: callback,                                                                                              // 24\n    opts: module.exports.extend({}, defaultOpts, opts)                                                               // 25\n  };                                                                                                                 // 26\n};                                                                                                                   // 27\n                                                                                                                     // 28\n/**                                                                                                                  // 29\n * Parse the given repo tag name (as a string) and break it out into repo/tag pair.                                  // 30\n * // if given the input http://localhost:8080/woot:latest                                                           // 31\n * {                                                                                                                 // 32\n *   repository: 'http://localhost:8080/woot',                                                                       // 33\n *   tag: 'latest'                                                                                                   // 34\n * }                                                                                                                 // 35\n * @param {String} input Input e.g: 'repo/foo', 'ubuntu', 'ubuntu:latest'                                            // 36\n * @return {Object} input parsed into the repo and tag.                                                              // 37\n */                                                                                                                  // 38\nmodule.exports.parseRepositoryTag = function(input) {                                                                // 39\n  var separatorPos;                                                                                                  // 40\n  var digestPos = input.indexOf('@');                                                                                // 41\n  var colonPos = input.lastIndexOf(':');                                                                             // 42\n  // @ symbol is more important                                                                                      // 43\n  if (digestPos >= 0) {                                                                                              // 44\n    separatorPos = digestPos;                                                                                        // 45\n  } else if (colonPos >= 0) {                                                                                        // 46\n    separatorPos = colonPos;                                                                                         // 47\n  } else {                                                                                                           // 48\n    // no colon nor @                                                                                                // 49\n    return {                                                                                                         // 50\n      repository: input                                                                                              // 51\n    };                                                                                                               // 52\n  }                                                                                                                  // 53\n                                                                                                                     // 54\n  // last colon is either the tag (or part of a port designation)                                                    // 55\n  var tag = input.slice(separatorPos + 1);                                                                           // 56\n                                                                                                                     // 57\n  // if it contains a / its not a tag and is part of the url                                                         // 58\n  if (tag.indexOf('/') === -1) {                                                                                     // 59\n    return {                                                                                                         // 60\n      repository: input.slice(0, separatorPos),                                                                      // 61\n      tag: tag                                                                                                       // 62\n    };                                                                                                               // 63\n  }                                                                                                                  // 64\n                                                                                                                     // 65\n  return {                                                                                                           // 66\n    repository: input                                                                                                // 67\n  };                                                                                                                 // 68\n};                                                                                                                   // 69\n                                                                                                                     // 70\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"exec.js\":[\"./util\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/exec.js                                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar util = require('./util');                                                                                        // 1\n                                                                                                                     // 2\n/**                                                                                                                  // 3\n * Represents an Exec                                                                                                // 4\n * @param {Object} modem docker-modem                                                                                // 5\n * @param {String} id    Exec's ID                                                                                   // 6\n */                                                                                                                  // 7\nvar Exec = function(modem, id) {                                                                                     // 8\n  this.modem = modem;                                                                                                // 9\n  this.id = id;                                                                                                      // 10\n};                                                                                                                   // 11\n                                                                                                                     // 12\n/**                                                                                                                  // 13\n * Start the exec call that was setup.                                                                               // 14\n *                                                                                                                   // 15\n * @param {object} options                                                                                           // 16\n * @param {function} callback                                                                                        // 17\n */                                                                                                                  // 18\nExec.prototype.start = function(opts, callback) {                                                                    // 19\n  var args = util.processArgs(opts, callback);                                                                       // 20\n                                                                                                                     // 21\n  var optsf = {                                                                                                      // 22\n    path: '/exec/' + this.id + '/start',                                                                             // 23\n    method: 'POST',                                                                                                  // 24\n    isStream: true,                                                                                                  // 25\n    hijack: args.opts.hijack,                                                                                        // 26\n    openStdin: args.opts.stdin,                                                                                      // 27\n    statusCodes: {                                                                                                   // 28\n      200: true,                                                                                                     // 29\n      204: true,                                                                                                     // 30\n      404: 'no such exec',                                                                                           // 31\n      409: 'container stopped/paused',                                                                               // 32\n      500: 'container not running'                                                                                   // 33\n    },                                                                                                               // 34\n    options: args.opts                                                                                               // 35\n  };                                                                                                                 // 36\n                                                                                                                     // 37\n  this.modem.dial(optsf, function(err, data) {                                                                       // 38\n    args.callback(err, data);                                                                                        // 39\n  });                                                                                                                // 40\n};                                                                                                                   // 41\n                                                                                                                     // 42\n/**                                                                                                                  // 43\n * Resize the exec call that was setup.                                                                              // 44\n *                                                                                                                   // 45\n * @param {object} options                                                                                           // 46\n * @param {function} callback                                                                                        // 47\n */                                                                                                                  // 48\nExec.prototype.resize = function(opts, callback) {                                                                   // 49\n  var args = util.processArgs(opts, callback);                                                                       // 50\n                                                                                                                     // 51\n  var optsf = {                                                                                                      // 52\n    path: '/exec/' + this.id + '/resize?',                                                                           // 53\n    method: 'POST',                                                                                                  // 54\n    statusCodes: {                                                                                                   // 55\n      200: true,                                                                                                     // 56\n      404: 'no such exec',                                                                                           // 57\n      500: 'container not running'                                                                                   // 58\n    },                                                                                                               // 59\n    options: args.opts                                                                                               // 60\n  };                                                                                                                 // 61\n                                                                                                                     // 62\n  this.modem.dial(optsf, function(err, data) {                                                                       // 63\n    args.callback(err, data);                                                                                        // 64\n  });                                                                                                                // 65\n};                                                                                                                   // 66\n                                                                                                                     // 67\n/**                                                                                                                  // 68\n * Get low-level information about the exec call.                                                                    // 69\n *                                                                                                                   // 70\n * @param {function} callback                                                                                        // 71\n */                                                                                                                  // 72\nExec.prototype.inspect = function(callback) {                                                                        // 73\n  var optsf = {                                                                                                      // 74\n    path: '/exec/' + this.id + '/json',                                                                              // 75\n    method: 'GET',                                                                                                   // 76\n    statusCodes: {                                                                                                   // 77\n      200: true,                                                                                                     // 78\n      404: 'no such exec',                                                                                           // 79\n      500: 'server error'                                                                                            // 80\n    }                                                                                                                // 81\n  };                                                                                                                 // 82\n                                                                                                                     // 83\n  this.modem.dial(optsf, function(err, data) {                                                                       // 84\n    callback(err, data);                                                                                             // 85\n  });                                                                                                                // 86\n};                                                                                                                   // 87\n                                                                                                                     // 88\n                                                                                                                     // 89\nmodule.exports = Exec;                                                                                               // 90\n                                                                                                                     // 91\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"image.js\":[\"./util\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/image.js                                                                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar util = require('./util');                                                                                        // 1\n                                                                                                                     // 2\n/**                                                                                                                  // 3\n * Represents an image                                                                                               // 4\n * @param {Object} modem docker-modem                                                                                // 5\n * @param {String} name  Image's name                                                                                // 6\n */                                                                                                                  // 7\nvar Image = function(modem, name) {                                                                                  // 8\n  this.modem = modem;                                                                                                // 9\n  this.name = name;                                                                                                  // 10\n};                                                                                                                   // 11\n                                                                                                                     // 12\n/**                                                                                                                  // 13\n * Inspect                                                                                                           // 14\n * @param  {Function} callback Callback, if specified Docker will be queried.                                        // 15\n * @return {Object}            Name only if callback isn't specified.                                                // 16\n */                                                                                                                  // 17\nImage.prototype.inspect = function(callback) {                                                                       // 18\n  if (typeof callback === 'function') {                                                                              // 19\n    var opts = {                                                                                                     // 20\n      path: '/images/' + this.name + '/json',                                                                        // 21\n      method: 'GET',                                                                                                 // 22\n      statusCodes: {                                                                                                 // 23\n        200: true,                                                                                                   // 24\n        404: 'no such image',                                                                                        // 25\n        500: 'server error'                                                                                          // 26\n      }                                                                                                              // 27\n    };                                                                                                               // 28\n                                                                                                                     // 29\n    this.modem.dial(opts, function(err, data) {                                                                      // 30\n      callback(err, data);                                                                                           // 31\n    });                                                                                                              // 32\n  } else {                                                                                                           // 33\n    return JSON.stringify({name: this.name});                                                                        // 34\n  }                                                                                                                  // 35\n};                                                                                                                   // 36\n                                                                                                                     // 37\n/**                                                                                                                  // 38\n * History                                                                                                           // 39\n * @param  {Function} callback Callback                                                                              // 40\n */                                                                                                                  // 41\nImage.prototype.history = function(callback) {                                                                       // 42\n  var opts = {                                                                                                       // 43\n    path: '/images/' + this.name + '/history',                                                                       // 44\n    method: 'GET',                                                                                                   // 45\n    statusCodes: {                                                                                                   // 46\n      200: true,                                                                                                     // 47\n      404: 'no such image',                                                                                          // 48\n      500: 'server error'                                                                                            // 49\n    }                                                                                                                // 50\n  };                                                                                                                 // 51\n                                                                                                                     // 52\n  this.modem.dial(opts, function(err, data) {                                                                        // 53\n    callback(err, data);                                                                                             // 54\n  });                                                                                                                // 55\n};                                                                                                                   // 56\n                                                                                                                     // 57\n/**                                                                                                                  // 58\n * Get                                                                                                               // 59\n * @param  {Function} callback Callback with data stream.                                                            // 60\n */                                                                                                                  // 61\nImage.prototype.get = function(callback) {                                                                           // 62\n  var opts = {                                                                                                       // 63\n    path: '/images/' + this.name + '/get',                                                                           // 64\n    method: 'GET',                                                                                                   // 65\n    isStream: true,                                                                                                  // 66\n    statusCodes: {                                                                                                   // 67\n      200: true,                                                                                                     // 68\n      500: 'server error'                                                                                            // 69\n    }                                                                                                                // 70\n  };                                                                                                                 // 71\n                                                                                                                     // 72\n  this.modem.dial(opts, function(err, data) {                                                                        // 73\n    callback(err, data);                                                                                             // 74\n  });                                                                                                                // 75\n};                                                                                                                   // 76\n                                                                                                                     // 77\n/**                                                                                                                  // 78\n * Push                                                                                                              // 79\n * @param  {Object}   opts     Push options, like 'registry' (optional)                                              // 80\n * @param  {Function} callback Callback with stream.                                                                 // 81\n * @param  {Object}   auth     Registry authentication                                                               // 82\n */                                                                                                                  // 83\nImage.prototype.push = function(opts, callback, auth) {                                                              // 84\n  var self = this;                                                                                                   // 85\n  var optsf = {                                                                                                      // 86\n    path: '/images/' + this.name + '/push?',                                                                         // 87\n    method: 'POST',                                                                                                  // 88\n    options: opts,                                                                                                   // 89\n    authconfig: opts.authconfig || auth,                                                                             // 90\n    isStream: true,                                                                                                  // 91\n    statusCodes: {                                                                                                   // 92\n      200: true,                                                                                                     // 93\n      404: 'no such image',                                                                                          // 94\n      500: 'server error'                                                                                            // 95\n    }                                                                                                                // 96\n  };                                                                                                                 // 97\n                                                                                                                     // 98\n  delete optsf.options.authconfig;                                                                                   // 99\n                                                                                                                     // 100\n  this.modem.dial(optsf, function(err, data) {                                                                       // 101\n    callback(err, data);                                                                                             // 102\n  });                                                                                                                // 103\n};                                                                                                                   // 104\n                                                                                                                     // 105\n/**                                                                                                                  // 106\n * Tag                                                                                                               // 107\n * @param  {Object}   opts     Tag options, like 'repo' (optional)                                                   // 108\n * @param  {Function} callback Callback                                                                              // 109\n */                                                                                                                  // 110\nImage.prototype.tag = function(opts, callback) {                                                                     // 111\n  var self = this;                                                                                                   // 112\n  var optsf = {                                                                                                      // 113\n    path: '/images/' + this.name + '/tag?',                                                                          // 114\n    method: 'POST',                                                                                                  // 115\n    options: opts,                                                                                                   // 116\n    statusCodes: {                                                                                                   // 117\n      200: true, // unofficial, but proxies may return it                                                            // 118\n      201: true,                                                                                                     // 119\n      400: 'bad parameter',                                                                                          // 120\n      404: 'no such image',                                                                                          // 121\n      409: 'conflict',                                                                                               // 122\n      500: 'server error'                                                                                            // 123\n    }                                                                                                                // 124\n  };                                                                                                                 // 125\n                                                                                                                     // 126\n  this.modem.dial(optsf, function(err, data) {                                                                       // 127\n    callback(err, data);                                                                                             // 128\n  });                                                                                                                // 129\n};                                                                                                                   // 130\n                                                                                                                     // 131\n/**                                                                                                                  // 132\n * Removes the image                                                                                                 // 133\n * @param  {[Object]}   opts     Remove options (optional)                                                           // 134\n * @param  {Function} callback Callback                                                                              // 135\n */                                                                                                                  // 136\nImage.prototype.remove = function(opts, callback) {                                                                  // 137\n  var args = util.processArgs(opts, callback);                                                                       // 138\n                                                                                                                     // 139\n                                                                                                                     // 140\n  var optsf = {                                                                                                      // 141\n    path: '/images/' + this.name + '?',                                                                              // 142\n    method: 'DELETE',                                                                                                // 143\n    statusCodes: {                                                                                                   // 144\n      200: true,                                                                                                     // 145\n      404: 'no such image',                                                                                          // 146\n      409: 'conflict',                                                                                               // 147\n      500: 'server error'                                                                                            // 148\n    },                                                                                                               // 149\n    options: args.opts                                                                                               // 150\n  };                                                                                                                 // 151\n                                                                                                                     // 152\n  this.modem.dial(optsf, function(err, data) {                                                                       // 153\n    args.callback(err, data);                                                                                        // 154\n  });                                                                                                                // 155\n};                                                                                                                   // 156\n                                                                                                                     // 157\nmodule.exports = Image;                                                                                              // 158\n                                                                                                                     // 159\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"volume.js\":[\"./util\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/volume.js                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar util = require('./util');                                                                                        // 1\n                                                                                                                     // 2\n/**                                                                                                                  // 3\n * Represents an volume                                                                                              // 4\n * @param {Object} modem docker-modem                                                                                // 5\n * @param {String} name  Volume's name                                                                               // 6\n */                                                                                                                  // 7\nvar Volume = function(modem, name) {                                                                                 // 8\n  this.modem = modem;                                                                                                // 9\n  this.name = name;                                                                                                  // 10\n};                                                                                                                   // 11\n                                                                                                                     // 12\n/**                                                                                                                  // 13\n * Inspect                                                                                                           // 14\n * @param  {Function} callback Callback, if specified Docker will be queried.                                        // 15\n * @return {Object}            Name only if callback isn't specified.                                                // 16\n */                                                                                                                  // 17\nVolume.prototype.inspect = function(callback) {                                                                      // 18\n  if (typeof callback === 'function') {                                                                              // 19\n    var opts = {                                                                                                     // 20\n      path: '/volumes/' + this.name,                                                                                 // 21\n      method: 'GET',                                                                                                 // 22\n      statusCodes: {                                                                                                 // 23\n        200: true,                                                                                                   // 24\n        404: 'no such volume',                                                                                       // 25\n        500: 'server error'                                                                                          // 26\n      }                                                                                                              // 27\n    };                                                                                                               // 28\n                                                                                                                     // 29\n    this.modem.dial(opts, function(err, data) {                                                                      // 30\n      callback(err, data);                                                                                           // 31\n    });                                                                                                              // 32\n  } else {                                                                                                           // 33\n    return JSON.stringify({name: this.name});                                                                        // 34\n  }                                                                                                                  // 35\n};                                                                                                                   // 36\n                                                                                                                     // 37\n/**                                                                                                                  // 38\n * Removes the volume                                                                                                // 39\n * @param  {[Object]}   opts     Remove options (optional)                                                           // 40\n * @param  {Function} callback Callback                                                                              // 41\n */                                                                                                                  // 42\nVolume.prototype.remove = function(opts, callback) {                                                                 // 43\n  var args = util.processArgs(opts, callback);                                                                       // 44\n                                                                                                                     // 45\n  var optsf = {                                                                                                      // 46\n    path: '/volumes/' + this.name,                                                                                   // 47\n    method: 'DELETE',                                                                                                // 48\n    statusCodes: {                                                                                                   // 49\n      204: true,                                                                                                     // 50\n      404: 'no such volume',                                                                                         // 51\n      409: 'conflict',                                                                                               // 52\n      500: 'server error'                                                                                            // 53\n    },                                                                                                               // 54\n    options: args.opts                                                                                               // 55\n  };                                                                                                                 // 56\n                                                                                                                     // 57\n  this.modem.dial(optsf, function(err, data) {                                                                       // 58\n    args.callback(err, data);                                                                                        // 59\n  });                                                                                                                // 60\n};                                                                                                                   // 61\n                                                                                                                     // 62\nmodule.exports = Volume;                                                                                             // 63\n                                                                                                                     // 64\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"network.js\":[\"./util\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/dockerode/lib/network.js                                                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar util = require('./util');                                                                                        // 1\n                                                                                                                     // 2\n/**                                                                                                                  // 3\n * Represents an network                                                                                             // 4\n * @param {Object} modem docker-modem                                                                                // 5\n * @param {String} id  Network's id                                                                                  // 6\n */                                                                                                                  // 7\nvar Network = function(modem, id) {                                                                                  // 8\n  this.modem = modem;                                                                                                // 9\n  this.id = id;                                                                                                      // 10\n};                                                                                                                   // 11\n                                                                                                                     // 12\n/**                                                                                                                  // 13\n * Inspect                                                                                                           // 14\n * @param  {Function} callback Callback, if specified Docker will be queried.                                        // 15\n * @return {Object}            Id only if callback isn't specified.                                                  // 16\n */                                                                                                                  // 17\nNetwork.prototype.inspect = function(callback) {                                                                     // 18\n  if (typeof callback === 'function') {                                                                              // 19\n    var opts = {                                                                                                     // 20\n      path: '/networks/' + this.id,                                                                                  // 21\n      method: 'GET',                                                                                                 // 22\n      statusCodes: {                                                                                                 // 23\n        200: true,                                                                                                   // 24\n        404: 'no such network',                                                                                      // 25\n        500: 'server error'                                                                                          // 26\n      }                                                                                                              // 27\n    };                                                                                                               // 28\n                                                                                                                     // 29\n    this.modem.dial(opts, function(err, data) {                                                                      // 30\n      callback(err, data);                                                                                           // 31\n    });                                                                                                              // 32\n  } else {                                                                                                           // 33\n    return JSON.stringify({Id: this.id});                                                                            // 34\n  }                                                                                                                  // 35\n};                                                                                                                   // 36\n                                                                                                                     // 37\n/**                                                                                                                  // 38\n * Removes the network                                                                                               // 39\n * @param  {[Object]}   opts     Remove options (optional)                                                           // 40\n * @param  {Function} callback Callback                                                                              // 41\n */                                                                                                                  // 42\nNetwork.prototype.remove = function(opts, callback) {                                                                // 43\n  var args = util.processArgs(opts, callback);                                                                       // 44\n                                                                                                                     // 45\n  var optsf = {                                                                                                      // 46\n    path: '/networks/' + this.id,                                                                                    // 47\n    method: 'DELETE',                                                                                                // 48\n    statusCodes: {                                                                                                   // 49\n      200: true,                                                                                                     // 50\n      204: true,                                                                                                     // 51\n      404: 'no such network',                                                                                        // 52\n      409: 'conflict',                                                                                               // 53\n      500: 'server error'                                                                                            // 54\n    },                                                                                                               // 55\n    options: args.opts                                                                                               // 56\n  };                                                                                                                 // 57\n                                                                                                                     // 58\n  this.modem.dial(optsf, function(err, data) {                                                                       // 59\n    args.callback(err, data);                                                                                        // 60\n  });                                                                                                                // 61\n};                                                                                                                   // 62\n                                                                                                                     // 63\n/**                                                                                                                  // 64\n * Connects a container to a network                                                                                 // 65\n * @param  {[Object]}   opts     Connect options (optional)                                                          // 66\n * @param  {Function} callback Callback                                                                              // 67\n */                                                                                                                  // 68\nNetwork.prototype.connect = function(opts, callback) {                                                               // 69\n  var args = util.processArgs(opts, callback);                                                                       // 70\n                                                                                                                     // 71\n  var optsf = {                                                                                                      // 72\n    path: '/networks/' + this.id + '/connect',                                                                       // 73\n    method: 'POST',                                                                                                  // 74\n    statusCodes: {                                                                                                   // 75\n      200: true,                                                                                                     // 76\n      201: true,                                                                                                     // 77\n      404: 'network or container is not found',                                                                      // 78\n      500: 'server error'                                                                                            // 79\n    },                                                                                                               // 80\n    options: args.opts                                                                                               // 81\n  };                                                                                                                 // 82\n                                                                                                                     // 83\n  this.modem.dial(optsf, function(err, data) {                                                                       // 84\n    args.callback(err, data);                                                                                        // 85\n  });                                                                                                                // 86\n};                                                                                                                   // 87\n                                                                                                                     // 88\n                                                                                                                     // 89\n/**                                                                                                                  // 90\n * Disconnects a container from a network                                                                            // 91\n * @param  {[Object]}   opts     Disconnect options (optional)                                                       // 92\n * @param  {Function} callback Callback                                                                              // 93\n */                                                                                                                  // 94\nNetwork.prototype.disconnect = function(opts, callback) {                                                            // 95\n  var args = util.processArgs(opts, callback);                                                                       // 96\n                                                                                                                     // 97\n  var optsf = {                                                                                                      // 98\n    path: '/networks/' + this.id + '/disconnect',                                                                    // 99\n    method: 'POST',                                                                                                  // 100\n    statusCodes: {                                                                                                   // 101\n      200: true,                                                                                                     // 102\n      201: true,                                                                                                     // 103\n      404: 'network or container is not found',                                                                      // 104\n      500: 'server error'                                                                                            // 105\n    },                                                                                                               // 106\n    options: args.opts                                                                                               // 107\n  };                                                                                                                 // 108\n                                                                                                                     // 109\n  this.modem.dial(optsf, function(err, data) {                                                                       // 110\n    args.callback(err, data);                                                                                        // 111\n  });                                                                                                                // 112\n};                                                                                                                   // 113\n                                                                                                                     // 114\n                                                                                                                     // 115\n                                                                                                                     // 116\n                                                                                                                     // 117\nmodule.exports = Network;                                                                                            // 118\n                                                                                                                     // 119\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}},\"docker-modem\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/docker-modem/package.json                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"docker-modem\";                                                                                       // 1\nexports.version = \"0.3.1\";                                                                                           // 2\nexports.main = \"./lib/modem\";                                                                                        // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lib\":{\"modem.js\":[\"querystring\",\"follow-redirects\",\"fs\",\"path\",\"url\",\"readable-stream\",\"./http_duplex\",\"debug\",\"util\",\"split-ca\",\"JSONStream\",\"meteor-node-stubs/deps/querystring\",\"meteor-node-stubs/deps/fs\",\"meteor-node-stubs/deps/path\",\"meteor-node-stubs/deps/url\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/docker-modem/lib/modem.js                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar querystring = require('querystring'),                                                                            // 1\n  http = require('follow-redirects'),                                                                                // 2\n  fs = require('fs'),                                                                                                // 3\n  path = require('path'),                                                                                            // 4\n  url = require('url'),                                                                                              // 5\n  stream = require('readable-stream'),                                                                               // 6\n  HttpDuplex = require('./http_duplex'),                                                                             // 7\n  debug = require('debug')('modem'),                                                                                 // 8\n  util = require('util'),                                                                                            // 9\n  splitca = require('split-ca'),                                                                                     // 10\n  JSONStream = require('JSONStream');                                                                                // 11\n                                                                                                                     // 12\nvar defaultOpts = function() {                                                                                       // 13\n  var split;                                                                                                         // 14\n  var opts = {};                                                                                                     // 15\n                                                                                                                     // 16\n  if (!process.env.DOCKER_HOST) {                                                                                    // 17\n    opts.socketPath = '/var/run/docker.sock';                                                                        // 18\n  } else if (process.env.DOCKER_HOST.indexOf('unix://') === 0) {                                                     // 19\n    // Strip off unix://, fall back to default of /var/run/docker.sock if                                            // 20\n    // unix:// was passed without a path                                                                             // 21\n    opts.socketPath = process.env.DOCKER_HOST.substring(7) || '/var/run/docker.sock';                                // 22\n  } else {                                                                                                           // 23\n    split = /(?:tcp:\\/\\/)?(.*?):([0-9]+)/g.exec(process.env.DOCKER_HOST);                                            // 24\n                                                                                                                     // 25\n    if (!split || split.length !== 3) {                                                                              // 26\n      throw new Error('DOCKER_HOST env variable should be something like tcp://localhost:1234');                     // 27\n    }                                                                                                                // 28\n                                                                                                                     // 29\n    opts.port = split[2];                                                                                            // 30\n                                                                                                                     // 31\n    if (process.env.DOCKER_TLS_VERIFY === '1' || opts.port === '2376') {                                             // 32\n      opts.protocol = 'https';                                                                                       // 33\n    } else {                                                                                                         // 34\n      opts.protocol = 'http';                                                                                        // 35\n    }                                                                                                                // 36\n                                                                                                                     // 37\n    opts.host = split[1];                                                                                            // 38\n                                                                                                                     // 39\n    if (process.env.DOCKER_CERT_PATH) {                                                                              // 40\n      opts.ca = splitca(path.join(process.env.DOCKER_CERT_PATH, 'ca.pem'));                                          // 41\n      opts.cert = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'cert.pem'));                              // 42\n      opts.key = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'key.pem'));                                // 43\n    }                                                                                                                // 44\n  }                                                                                                                  // 45\n                                                                                                                     // 46\n  return opts;                                                                                                       // 47\n};                                                                                                                   // 48\n                                                                                                                     // 49\nvar Modem = function(opts) {                                                                                         // 50\n  if (!opts) {                                                                                                       // 51\n    opts = defaultOpts();                                                                                            // 52\n  }                                                                                                                  // 53\n                                                                                                                     // 54\n  this.socketPath = opts.socketPath;                                                                                 // 55\n  this.host = opts.host;                                                                                             // 56\n  this.port = opts.port;                                                                                             // 57\n  this.version = opts.version;                                                                                       // 58\n  this.key = opts.key;                                                                                               // 59\n  this.cert = opts.cert;                                                                                             // 60\n  this.ca = opts.ca;                                                                                                 // 61\n  this.timeout = opts.timeout;                                                                                       // 62\n  this.checkServerIdentity = opts.checkServerIdentity;                                                               // 63\n                                                                                                                     // 64\n  if (this.key && this.cert && this.ca) {                                                                            // 65\n    this.protocol = 'https';                                                                                         // 66\n  }                                                                                                                  // 67\n  this.protocol = opts.protocol || this.protocol || 'http';                                                          // 68\n};                                                                                                                   // 69\n                                                                                                                     // 70\nModem.prototype.dial = function(options, callback) {                                                                 // 71\n  var opts, address, data;                                                                                           // 72\n  var self = this;                                                                                                   // 73\n                                                                                                                     // 74\n  if (options.options) {                                                                                             // 75\n    opts = options.options;                                                                                          // 76\n  }                                                                                                                  // 77\n                                                                                                                     // 78\n  if (this.version) {                                                                                                // 79\n    options.path = '/' + this.version + options.path;                                                                // 80\n  }                                                                                                                  // 81\n                                                                                                                     // 82\n  if (this.host) {                                                                                                   // 83\n    var parsed = url.parse(self.host);                                                                               // 84\n    address = url.format({                                                                                           // 85\n      'protocol': parsed.protocol || self.protocol,                                                                  // 86\n      'hostname': parsed.hostname || self.host,                                                                      // 87\n      'port': self.port                                                                                              // 88\n    });                                                                                                              // 89\n    address = url.resolve(address, options.path);                                                                    // 90\n  } else {                                                                                                           // 91\n    address = options.path;                                                                                          // 92\n  }                                                                                                                  // 93\n                                                                                                                     // 94\n  if (options.path.indexOf('?') !== -1) {                                                                            // 95\n    if (opts && Object.keys(opts).length > 0) {                                                                      // 96\n      address += this.buildQuerystring(opts);                                                                        // 97\n    } else {                                                                                                         // 98\n      address = address.substring(0, address.length - 1);                                                            // 99\n    }                                                                                                                // 100\n  }                                                                                                                  // 101\n                                                                                                                     // 102\n  var optionsf = {                                                                                                   // 103\n    path: address,                                                                                                   // 104\n    method: options.method,                                                                                          // 105\n    headers: options.headers || {},                                                                                  // 106\n    key: self.key,                                                                                                   // 107\n    cert: self.cert,                                                                                                 // 108\n    ca: self.ca                                                                                                      // 109\n  };                                                                                                                 // 110\n                                                                                                                     // 111\n  if (this.checkServerIdentity) {                                                                                    // 112\n    optionsf.checkServerIdentity = this.checkServerIdentity;                                                         // 113\n  }                                                                                                                  // 114\n                                                                                                                     // 115\n  if (options.authconfig) {                                                                                          // 116\n    optionsf.headers['X-Registry-Auth'] = options.authconfig.key || options.authconfig.base64 ||                     // 117\n      new Buffer(JSON.stringify(options.authconfig)).toString('base64');                                             // 118\n  }                                                                                                                  // 119\n                                                                                                                     // 120\n  if (options.registryconfig) {                                                                                      // 121\n    optionsf.headers['X-Registry-Config'] = options.registryconfig.base64 ||                                         // 122\n      new Buffer(JSON.stringify(options.registryconfig)).toString('base64');                                         // 123\n  }                                                                                                                  // 124\n                                                                                                                     // 125\n  if (options.file) {                                                                                                // 126\n    if (typeof options.file === 'string') {                                                                          // 127\n      data = fs.readFileSync(path.resolve(options.file));                                                            // 128\n    } else {                                                                                                         // 129\n      data = options.file;                                                                                           // 130\n    }                                                                                                                // 131\n    optionsf.headers['Content-Type'] = 'application/tar';                                                            // 132\n  } else if (opts && options.method === 'POST') {                                                                    // 133\n    data = JSON.stringify(opts);                                                                                     // 134\n    optionsf.headers['Content-Type'] = 'application/json';                                                           // 135\n  }                                                                                                                  // 136\n                                                                                                                     // 137\n  if (typeof data === \"string\") {                                                                                    // 138\n    optionsf.headers['Content-Length'] = Buffer.byteLength(data);                                                    // 139\n  } else if (Buffer.isBuffer(data) === true) {                                                                       // 140\n    optionsf.headers['Content-Length'] = data.length;                                                                // 141\n  }                                                                                                                  // 142\n                                                                                                                     // 143\n  if (options.hijack) {                                                                                              // 144\n    optionsf.headers.Connection = 'Upgrade';                                                                         // 145\n    optionsf.headers.Upgrade = 'tcp';                                                                                // 146\n  }                                                                                                                  // 147\n                                                                                                                     // 148\n  if (this.socketPath) {                                                                                             // 149\n    optionsf.socketPath = this.socketPath;                                                                           // 150\n  } else {                                                                                                           // 151\n    var urlp = url.parse(address);                                                                                   // 152\n    optionsf.hostname = urlp.hostname;                                                                               // 153\n    optionsf.port = urlp.port;                                                                                       // 154\n    optionsf.path = urlp.path;                                                                                       // 155\n  }                                                                                                                  // 156\n                                                                                                                     // 157\n  this.buildRequest(optionsf, options, data, callback);                                                              // 158\n};                                                                                                                   // 159\n                                                                                                                     // 160\nModem.prototype.buildRequest = function(options, context, data, callback) {                                          // 161\n  var self = this;                                                                                                   // 162\n  var req = http[self.protocol].request(options, function() {});                                                     // 163\n                                                                                                                     // 164\n  debug('Sending: %s', util.inspect(options, {                                                                       // 165\n    showHidden: true,                                                                                                // 166\n    depth: null                                                                                                      // 167\n  }));                                                                                                               // 168\n                                                                                                                     // 169\n  if (self.timeout) {                                                                                                // 170\n    req.on('socket', function(socket) {                                                                              // 171\n      socket.setTimeout(self.timeout);                                                                               // 172\n      socket.on('timeout', function() {                                                                              // 173\n        debug('Timeout of %s ms exceeded', self.timeout);                                                            // 174\n        req.abort();                                                                                                 // 175\n      });                                                                                                            // 176\n    });                                                                                                              // 177\n  }                                                                                                                  // 178\n                                                                                                                     // 179\n  if (context.hijack === true) {                                                                                     // 180\n    req.on('upgrade', function(res, sock, head) {                                                                    // 181\n      return callback(null, sock);                                                                                   // 182\n    });                                                                                                              // 183\n  }                                                                                                                  // 184\n                                                                                                                     // 185\n  req.on('response', function(res) {                                                                                 // 186\n    if (context.isStream === true) {                                                                                 // 187\n      self.buildPayload(null, context.isStream, context.statusCodes, context.openStdin, req, res, null, callback);   // 188\n    } else {                                                                                                         // 189\n      var chunks = '';                                                                                               // 190\n      res.on('data', function(chunk) {                                                                               // 191\n        chunks += chunk;                                                                                             // 192\n      });                                                                                                            // 193\n                                                                                                                     // 194\n      res.on('end', function() {                                                                                     // 195\n        debug('Received: %s', chunks);                                                                               // 196\n                                                                                                                     // 197\n        var json;                                                                                                    // 198\n        try {                                                                                                        // 199\n          json = JSON.parse(chunks);                                                                                 // 200\n        } catch (e) {                                                                                                // 201\n          json = chunks;                                                                                             // 202\n        }                                                                                                            // 203\n        self.buildPayload(null, context.isStream, context.statusCodes, false, req, res, json, callback);             // 204\n      });                                                                                                            // 205\n    }                                                                                                                // 206\n  });                                                                                                                // 207\n                                                                                                                     // 208\n  req.on('error', function(error) {                                                                                  // 209\n    self.buildPayload(error, context.isStream, context.statusCodes, false, {}, {}, null, callback);                  // 210\n  });                                                                                                                // 211\n                                                                                                                     // 212\n  if (typeof data === \"string\" || Buffer.isBuffer(data)) {                                                           // 213\n    req.write(data);                                                                                                 // 214\n  } else if (data) {                                                                                                 // 215\n    data.pipe(req);                                                                                                  // 216\n  }                                                                                                                  // 217\n                                                                                                                     // 218\n  if (!context.hijack && !context.openStdin && (typeof data === \"string\" || data === undefined || Buffer.isBuffer(data))) {\n    req.end();                                                                                                       // 220\n  }                                                                                                                  // 221\n};                                                                                                                   // 222\n                                                                                                                     // 223\nModem.prototype.buildPayload = function(err, isStream, statusCodes, openStdin, req, res, json, cb) {                 // 224\n  if (err) return cb(err, null);                                                                                     // 225\n                                                                                                                     // 226\n  if (statusCodes[res.statusCode] !== true) {                                                                        // 227\n    getCause(isStream, res, json, function(err, cause) {                                                             // 228\n      var msg = new Error(                                                                                           // 229\n        '(HTTP code ' + res.statusCode + ') ' +                                                                      // 230\n        (statusCodes[res.statusCode] || 'unexpected') + ' - ' +                                                      // 231\n        (cause.message || cause) + ' '                                                                               // 232\n      );                                                                                                             // 233\n      msg.reason = statusCodes[res.statusCode];                                                                      // 234\n      msg.statusCode = res.statusCode;                                                                               // 235\n      msg.json = json;                                                                                               // 236\n      cb(msg, null);                                                                                                 // 237\n    });                                                                                                              // 238\n  } else {                                                                                                           // 239\n    if (openStdin) {                                                                                                 // 240\n      cb(null, new HttpDuplex(req, res));                                                                            // 241\n    } else if (isStream) {                                                                                           // 242\n      cb(null, res);                                                                                                 // 243\n    } else {                                                                                                         // 244\n      cb(null, json);                                                                                                // 245\n    }                                                                                                                // 246\n  }                                                                                                                  // 247\n                                                                                                                     // 248\n  function getCause(isStream, res, json, callback) {                                                                 // 249\n    var chunks = '';                                                                                                 // 250\n    if (isStream) {                                                                                                  // 251\n      res.on('data', function(chunk) {                                                                               // 252\n        chunks += chunk;                                                                                             // 253\n      });                                                                                                            // 254\n      res.on('end', function() {                                                                                     // 255\n        callback(null, chunks);                                                                                      // 256\n      });                                                                                                            // 257\n    } else {                                                                                                         // 258\n      callback(null, json);                                                                                          // 259\n    }                                                                                                                // 260\n  }                                                                                                                  // 261\n};                                                                                                                   // 262\n                                                                                                                     // 263\nModem.prototype.demuxStream = function(stream, stdout, stderr) {                                                     // 264\n  var header = null;                                                                                                 // 265\n                                                                                                                     // 266\n  stream.on('readable', function() {                                                                                 // 267\n    header = header || stream.read(8);                                                                               // 268\n    while (header !== null) {                                                                                        // 269\n      var type = header.readUInt8(0);                                                                                // 270\n      var payload = stream.read(header.readUInt32BE(4));                                                             // 271\n      if (payload === null) break;                                                                                   // 272\n      if (type == 2) {                                                                                               // 273\n        stderr.write(payload);                                                                                       // 274\n      } else {                                                                                                       // 275\n        stdout.write(payload);                                                                                       // 276\n      }                                                                                                              // 277\n      header = stream.read(8);                                                                                       // 278\n    }                                                                                                                // 279\n  });                                                                                                                // 280\n};                                                                                                                   // 281\n                                                                                                                     // 282\nModem.prototype.followProgress = function(stream, onFinished, onProgress) {                                          // 283\n  var parser = JSONStream.parse(),                                                                                   // 284\n    output = [];                                                                                                     // 285\n                                                                                                                     // 286\n  parser.on('root', onStreamEvent);                                                                                  // 287\n  parser.on('error', onStreamError);                                                                                 // 288\n  parser.on('end', onStreamEnd);                                                                                     // 289\n                                                                                                                     // 290\n  stream.pipe(parser);                                                                                               // 291\n                                                                                                                     // 292\n  function onStreamEvent(evt) {                                                                                      // 293\n    if (!(evt instanceof Object)) {                                                                                  // 294\n      evt = {};                                                                                                      // 295\n    }                                                                                                                // 296\n                                                                                                                     // 297\n    output.push(evt);                                                                                                // 298\n                                                                                                                     // 299\n    if (evt.error) {                                                                                                 // 300\n      return onStreamError(evt.error);                                                                               // 301\n    }                                                                                                                // 302\n                                                                                                                     // 303\n    if (onProgress) {                                                                                                // 304\n      onProgress(evt);                                                                                               // 305\n    }                                                                                                                // 306\n  }                                                                                                                  // 307\n                                                                                                                     // 308\n  function onStreamError(err) {                                                                                      // 309\n    parser.removeListener('root', onStreamEvent);                                                                    // 310\n    parser.removeListener('error', onStreamError);                                                                   // 311\n    parser.removeListener('end', onStreamEnd);                                                                       // 312\n    onFinished(err, output);                                                                                         // 313\n  }                                                                                                                  // 314\n                                                                                                                     // 315\n  function onStreamEnd() {                                                                                           // 316\n    onFinished(null, output);                                                                                        // 317\n  }                                                                                                                  // 318\n};                                                                                                                   // 319\n                                                                                                                     // 320\nModem.prototype.buildQuerystring = function(opts) {                                                                  // 321\n  var clone = {};                                                                                                    // 322\n                                                                                                                     // 323\n  // serialize map values as JSON strings, else querystring truncates.                                               // 324\n  Object.keys(opts).map(function(key, i) {                                                                           // 325\n    clone[key] = (opts[key] && typeof opts[key] === 'object') ?                                                      // 326\n      JSON.stringify(opts[key]) : opts[key];                                                                         // 327\n  });                                                                                                                // 328\n                                                                                                                     // 329\n  return querystring.stringify(clone);                                                                               // 330\n};                                                                                                                   // 331\n                                                                                                                     // 332\nmodule.exports = Modem;                                                                                              // 333\n                                                                                                                     // 334\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"http_duplex.js\":[\"util\",\"readable-stream\",\"meteor-node-stubs/deps/util\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/docker-modem/lib/http_duplex.js                                                                      //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.exports = HttpDuplex;                                                                                         // 1\n                                                                                                                     // 2\nvar util = require('util'),                                                                                          // 3\n  stream = require('readable-stream');                                                                               // 4\n                                                                                                                     // 5\nutil.inherits(HttpDuplex, stream.Duplex);                                                                            // 6\n                                                                                                                     // 7\nfunction HttpDuplex(req, res, options) {                                                                             // 8\n  var self = this;                                                                                                   // 9\n                                                                                                                     // 10\n  if (!(self instanceof HttpDuplex)) return new HttpDuplex(req, res);                                                // 11\n                                                                                                                     // 12\n  stream.Duplex.call(self, options);                                                                                 // 13\n  self._output = null;                                                                                               // 14\n                                                                                                                     // 15\n  self.connect(req, res);                                                                                            // 16\n}                                                                                                                    // 17\n                                                                                                                     // 18\nHttpDuplex.prototype.connect = function(req, res) {                                                                  // 19\n  var self = this;                                                                                                   // 20\n  self.req = req;                                                                                                    // 21\n  self._output = res;                                                                                                // 22\n  self.emit('response', res);                                                                                        // 23\n                                                                                                                     // 24\n  res.on('data', function(c) {                                                                                       // 25\n    if (!self.push(c)) self._output.pause();                                                                         // 26\n  });                                                                                                                // 27\n  res.on('end', function() {                                                                                         // 28\n    self.push(null);                                                                                                 // 29\n  });                                                                                                                // 30\n};                                                                                                                   // 31\n                                                                                                                     // 32\nHttpDuplex.prototype._read = function(n) {                                                                           // 33\n  if (this._output) this._output.resume();                                                                           // 34\n};                                                                                                                   // 35\n                                                                                                                     // 36\nHttpDuplex.prototype._write = function(chunk, encoding, cb) {                                                        // 37\n  this.req.write(chunk, encoding);                                                                                   // 38\n  cb();                                                                                                              // 39\n};                                                                                                                   // 40\n                                                                                                                     // 41\nHttpDuplex.prototype.end = function(chunk, encoding, cb) {                                                           // 42\n  this._output.socket.destroy();                                                                                     // 43\n  return this.req.end(chunk, encoding, cb);                                                                          // 44\n};                                                                                                                   // 45\n                                                                                                                     // 46\nHttpDuplex.prototype.destroy = function() {                                                                          // 47\n  this.req.destroy();                                                                                                // 48\n  this._output.socket.destroy();                                                                                     // 49\n};                                                                                                                   // 50\n                                                                                                                     // 51\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}},\"follow-redirects\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/follow-redirects/package.json                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"follow-redirects\";                                                                                   // 1\nexports.version = \"0.0.3\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"https\",\"http\",\"url\",\"underscore\",\"meteor-node-stubs/deps/https\",\"meteor-node-stubs/deps/http\",\"meteor-node-stubs/deps/url\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/follow-redirects/index.js                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar nativeHttps = require('https'),                                                                                  // 1\n  nativeHttp = require('http'),                                                                                      // 2\n  url = require('url'),                                                                                              // 3\n  _ = require('underscore');                                                                                         // 4\n                                                                                                                     // 5\nvar maxRedirects = module.exports.maxRedirects = 5;                                                                  // 6\n                                                                                                                     // 7\nvar protocols = {                                                                                                    // 8\n  https: nativeHttps,                                                                                                // 9\n  http: nativeHttp                                                                                                   // 10\n};                                                                                                                   // 11\n                                                                                                                     // 12\n// Only use GETs on redirects                                                                                        // 13\nfor (var protocol in protocols) {                                                                                    // 14\n  // h is either our cloned http or https object                                                                     // 15\n  var h =  function() {};                                                                                            // 16\n  h.prototype = protocols[protocol];                                                                                 // 17\n  h = new h();                                                                                                       // 18\n                                                                                                                     // 19\n  module.exports[protocol] = h;                                                                                      // 20\n                                                                                                                     // 21\n  h.request = function (h) {                                                                                         // 22\n    return function (options, callback, redirectOptions) {                                                           // 23\n                                                                                                                     // 24\n      redirectOptions = redirectOptions || {};                                                                       // 25\n                                                                                                                     // 26\n      var max = (typeof options === 'object' && 'maxRedirects' in options) ? options.maxRedirects : exports.maxRedirects;\n                                                                                                                     // 28\n      var redirect = _.extend({                                                                                      // 29\n        count: 0,                                                                                                    // 30\n        max: max,                                                                                                    // 31\n        clientRequest: null,                                                                                         // 32\n        userCallback: callback                                                                                       // 33\n      }, redirectOptions);                                                                                           // 34\n                                                                                                                     // 35\n      //console.log(redirect.count);                                                                                 // 36\n      //console.log(redirect.max);                                                                                   // 37\n      /**                                                                                                            // 38\n       * Emit error if too many redirects                                                                            // 39\n       */                                                                                                            // 40\n      if (redirect.count > redirect.max) {                                                                           // 41\n        var err = new Error('Max redirects exceeded. To allow more redirects, pass options.maxRedirects property.');\n        redirect.clientRequest.emit('error', err);                                                                   // 43\n        return redirect.clientRequest;                                                                               // 44\n      }                                                                                                              // 45\n                                                                                                                     // 46\n      redirect.count++;                                                                                              // 47\n                                                                                                                     // 48\n      /**                                                                                                            // 49\n       * Parse URL from options                                                                                      // 50\n       */                                                                                                            // 51\n      var reqUrl;                                                                                                    // 52\n      if (typeof options === 'string') {                                                                             // 53\n        reqUrl = options;                                                                                            // 54\n      }                                                                                                              // 55\n      else {                                                                                                         // 56\n        reqUrl = url.format(_.extend({ protocol: protocol }, options));                                              // 57\n      }                                                                                                              // 58\n                                                                                                                     // 59\n      /*                                                                                                             // 60\n       * Build client request                                                                                        // 61\n       */                                                                                                            // 62\n      var clientRequest = h.__proto__.request(options, redirectCallback(reqUrl, redirect));                          // 63\n                                                                                                                     // 64\n      // Save user's clientRequest so we can emit errors later                                                       // 65\n      if (!redirect.clientRequest) redirect.clientRequest = clientRequest;                                           // 66\n                                                                                                                     // 67\n      /**                                                                                                            // 68\n       * ClientRequest callback for redirects                                                                        // 69\n       */                                                                                                            // 70\n      function redirectCallback (reqUrl, redirect) {                                                                 // 71\n        return function (res) {                                                                                      // 72\n          // status must be 300-399 for redirects                                                                    // 73\n          if (res.statusCode < 300 || res.statusCode > 399) {                                                        // 74\n            //console.log('[' + res.statusCode + '] callback user on url ' + reqUrl);                                // 75\n            return redirect.userCallback(res);                                                                       // 76\n          }                                                                                                          // 77\n                                                                                                                     // 78\n          // no `Location:` header => nowhere to redirect                                                            // 79\n          if (!('location' in res.headers)) {                                                                        // 80\n            //console.log('[no location header] callback user on url ' + reqUrl);                                    // 81\n            return redirect.userCallback(res);                                                                       // 82\n          }                                                                                                          // 83\n                                                                                                                     // 84\n          // save the original clientRequest to our redirectOptions so we can emit errors later                      // 85\n                                                                                                                     // 86\n          // need to use url.resolve() in case location is a relative URL                                            // 87\n          var redirectUrl = url.resolve(reqUrl, res.headers['location']);                                            // 88\n          // we need to call the right api (http vs https) depending on protocol                                     // 89\n          var proto = url.parse(redirectUrl).protocol;                                                               // 90\n          proto = proto.substr(0, proto.length - 1);                                                                 // 91\n          //console.log('Redirecting from ' + reqUrl + ' to ' + redirectUrl);                                        // 92\n          return module.exports[proto].get(redirectUrl, redirectCallback(reqUrl, redirect), redirect);               // 93\n        };                                                                                                           // 94\n      }                                                                                                              // 95\n                                                                                                                     // 96\n      return clientRequest;                                                                                          // 97\n    }                                                                                                                // 98\n  }(h);                                                                                                              // 99\n                                                                                                                     // 100\n  // see https://github.com/joyent/node/blob/master/lib/http.js#L1623                                                // 101\n  h.get = function (h) {                                                                                             // 102\n    return function (options, cb, redirectOptions) {                                                                 // 103\n      var req = h.request(options, cb, redirectOptions);                                                             // 104\n      req.end();                                                                                                     // 105\n      return req;                                                                                                    // 106\n    };                                                                                                               // 107\n  }(h);                                                                                                              // 108\n}                                                                                                                    // 109\n                                                                                                                     // 110\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"underscore\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/underscore/package.json                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"underscore\";                                                                                         // 1\nexports.version = \"1.8.3\";                                                                                           // 2\nexports.main = \"underscore.js\";                                                                                      // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"underscore.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/underscore/underscore.js                                                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n//     Underscore.js 1.8.3                                                                                           // 1\n//     http://underscorejs.org                                                                                       // 2\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors                            // 3\n//     Underscore may be freely distributed under the MIT license.                                                   // 4\n                                                                                                                     // 5\n(function() {                                                                                                        // 6\n                                                                                                                     // 7\n  // Baseline setup                                                                                                  // 8\n  // --------------                                                                                                  // 9\n                                                                                                                     // 10\n  // Establish the root object, `window` in the browser, or `exports` on the server.                                 // 11\n  var root = this;                                                                                                   // 12\n                                                                                                                     // 13\n  // Save the previous value of the `_` variable.                                                                    // 14\n  var previousUnderscore = root._;                                                                                   // 15\n                                                                                                                     // 16\n  // Save bytes in the minified (but not gzipped) version:                                                           // 17\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;                     // 18\n                                                                                                                     // 19\n  // Create quick reference variables for speed access to core prototypes.                                           // 20\n  var                                                                                                                // 21\n    push             = ArrayProto.push,                                                                              // 22\n    slice            = ArrayProto.slice,                                                                             // 23\n    toString         = ObjProto.toString,                                                                            // 24\n    hasOwnProperty   = ObjProto.hasOwnProperty;                                                                      // 25\n                                                                                                                     // 26\n  // All **ECMAScript 5** native function implementations that we hope to use                                        // 27\n  // are declared here.                                                                                              // 28\n  var                                                                                                                // 29\n    nativeIsArray      = Array.isArray,                                                                              // 30\n    nativeKeys         = Object.keys,                                                                                // 31\n    nativeBind         = FuncProto.bind,                                                                             // 32\n    nativeCreate       = Object.create;                                                                              // 33\n                                                                                                                     // 34\n  // Naked function reference for surrogate-prototype-swapping.                                                      // 35\n  var Ctor = function(){};                                                                                           // 36\n                                                                                                                     // 37\n  // Create a safe reference to the Underscore object for use below.                                                 // 38\n  var _ = function(obj) {                                                                                            // 39\n    if (obj instanceof _) return obj;                                                                                // 40\n    if (!(this instanceof _)) return new _(obj);                                                                     // 41\n    this._wrapped = obj;                                                                                             // 42\n  };                                                                                                                 // 43\n                                                                                                                     // 44\n  // Export the Underscore object for **Node.js**, with                                                              // 45\n  // backwards-compatibility for the old `require()` API. If we're in                                                // 46\n  // the browser, add `_` as a global object.                                                                        // 47\n  if (typeof exports !== 'undefined') {                                                                              // 48\n    if (typeof module !== 'undefined' && module.exports) {                                                           // 49\n      exports = module.exports = _;                                                                                  // 50\n    }                                                                                                                // 51\n    exports._ = _;                                                                                                   // 52\n  } else {                                                                                                           // 53\n    root._ = _;                                                                                                      // 54\n  }                                                                                                                  // 55\n                                                                                                                     // 56\n  // Current version.                                                                                                // 57\n  _.VERSION = '1.8.3';                                                                                               // 58\n                                                                                                                     // 59\n  // Internal function that returns an efficient (for current engines) version                                       // 60\n  // of the passed-in callback, to be repeatedly applied in other Underscore                                         // 61\n  // functions.                                                                                                      // 62\n  var optimizeCb = function(func, context, argCount) {                                                               // 63\n    if (context === void 0) return func;                                                                             // 64\n    switch (argCount == null ? 3 : argCount) {                                                                       // 65\n      case 1: return function(value) {                                                                               // 66\n        return func.call(context, value);                                                                            // 67\n      };                                                                                                             // 68\n      case 2: return function(value, other) {                                                                        // 69\n        return func.call(context, value, other);                                                                     // 70\n      };                                                                                                             // 71\n      case 3: return function(value, index, collection) {                                                            // 72\n        return func.call(context, value, index, collection);                                                         // 73\n      };                                                                                                             // 74\n      case 4: return function(accumulator, value, index, collection) {                                               // 75\n        return func.call(context, accumulator, value, index, collection);                                            // 76\n      };                                                                                                             // 77\n    }                                                                                                                // 78\n    return function() {                                                                                              // 79\n      return func.apply(context, arguments);                                                                         // 80\n    };                                                                                                               // 81\n  };                                                                                                                 // 82\n                                                                                                                     // 83\n  // A mostly-internal function to generate callbacks that can be applied                                            // 84\n  // to each element in a collection, returning the desired result — either                                          // 85\n  // identity, an arbitrary callback, a property matcher, or a property accessor.                                    // 86\n  var cb = function(value, context, argCount) {                                                                      // 87\n    if (value == null) return _.identity;                                                                            // 88\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);                                            // 89\n    if (_.isObject(value)) return _.matcher(value);                                                                  // 90\n    return _.property(value);                                                                                        // 91\n  };                                                                                                                 // 92\n  _.iteratee = function(value, context) {                                                                            // 93\n    return cb(value, context, Infinity);                                                                             // 94\n  };                                                                                                                 // 95\n                                                                                                                     // 96\n  // An internal function for creating assigner functions.                                                           // 97\n  var createAssigner = function(keysFunc, undefinedOnly) {                                                           // 98\n    return function(obj) {                                                                                           // 99\n      var length = arguments.length;                                                                                 // 100\n      if (length < 2 || obj == null) return obj;                                                                     // 101\n      for (var index = 1; index < length; index++) {                                                                 // 102\n        var source = arguments[index],                                                                               // 103\n            keys = keysFunc(source),                                                                                 // 104\n            l = keys.length;                                                                                         // 105\n        for (var i = 0; i < l; i++) {                                                                                // 106\n          var key = keys[i];                                                                                         // 107\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];                                         // 108\n        }                                                                                                            // 109\n      }                                                                                                              // 110\n      return obj;                                                                                                    // 111\n    };                                                                                                               // 112\n  };                                                                                                                 // 113\n                                                                                                                     // 114\n  // An internal function for creating a new object that inherits from another.                                      // 115\n  var baseCreate = function(prototype) {                                                                             // 116\n    if (!_.isObject(prototype)) return {};                                                                           // 117\n    if (nativeCreate) return nativeCreate(prototype);                                                                // 118\n    Ctor.prototype = prototype;                                                                                      // 119\n    var result = new Ctor;                                                                                           // 120\n    Ctor.prototype = null;                                                                                           // 121\n    return result;                                                                                                   // 122\n  };                                                                                                                 // 123\n                                                                                                                     // 124\n  var property = function(key) {                                                                                     // 125\n    return function(obj) {                                                                                           // 126\n      return obj == null ? void 0 : obj[key];                                                                        // 127\n    };                                                                                                               // 128\n  };                                                                                                                 // 129\n                                                                                                                     // 130\n  // Helper for collection methods to determine whether a collection                                                 // 131\n  // should be iterated as an array or as an object                                                                  // 132\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength                                      // 133\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094                                                              // 134\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;                                                                         // 135\n  var getLength = property('length');                                                                                // 136\n  var isArrayLike = function(collection) {                                                                           // 137\n    var length = getLength(collection);                                                                              // 138\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;                                    // 139\n  };                                                                                                                 // 140\n                                                                                                                     // 141\n  // Collection Functions                                                                                            // 142\n  // --------------------                                                                                            // 143\n                                                                                                                     // 144\n  // The cornerstone, an `each` implementation, aka `forEach`.                                                       // 145\n  // Handles raw objects in addition to array-likes. Treats all                                                      // 146\n  // sparse array-likes as if they were dense.                                                                       // 147\n  _.each = _.forEach = function(obj, iteratee, context) {                                                            // 148\n    iteratee = optimizeCb(iteratee, context);                                                                        // 149\n    var i, length;                                                                                                   // 150\n    if (isArrayLike(obj)) {                                                                                          // 151\n      for (i = 0, length = obj.length; i < length; i++) {                                                            // 152\n        iteratee(obj[i], i, obj);                                                                                    // 153\n      }                                                                                                              // 154\n    } else {                                                                                                         // 155\n      var keys = _.keys(obj);                                                                                        // 156\n      for (i = 0, length = keys.length; i < length; i++) {                                                           // 157\n        iteratee(obj[keys[i]], keys[i], obj);                                                                        // 158\n      }                                                                                                              // 159\n    }                                                                                                                // 160\n    return obj;                                                                                                      // 161\n  };                                                                                                                 // 162\n                                                                                                                     // 163\n  // Return the results of applying the iteratee to each element.                                                    // 164\n  _.map = _.collect = function(obj, iteratee, context) {                                                             // 165\n    iteratee = cb(iteratee, context);                                                                                // 166\n    var keys = !isArrayLike(obj) && _.keys(obj),                                                                     // 167\n        length = (keys || obj).length,                                                                               // 168\n        results = Array(length);                                                                                     // 169\n    for (var index = 0; index < length; index++) {                                                                   // 170\n      var currentKey = keys ? keys[index] : index;                                                                   // 171\n      results[index] = iteratee(obj[currentKey], currentKey, obj);                                                   // 172\n    }                                                                                                                // 173\n    return results;                                                                                                  // 174\n  };                                                                                                                 // 175\n                                                                                                                     // 176\n  // Create a reducing function iterating left or right.                                                             // 177\n  function createReduce(dir) {                                                                                       // 178\n    // Optimized iterator function as using arguments.length                                                         // 179\n    // in the main function will deoptimize the, see #1991.                                                          // 180\n    function iterator(obj, iteratee, memo, keys, index, length) {                                                    // 181\n      for (; index >= 0 && index < length; index += dir) {                                                           // 182\n        var currentKey = keys ? keys[index] : index;                                                                 // 183\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);                                                     // 184\n      }                                                                                                              // 185\n      return memo;                                                                                                   // 186\n    }                                                                                                                // 187\n                                                                                                                     // 188\n    return function(obj, iteratee, memo, context) {                                                                  // 189\n      iteratee = optimizeCb(iteratee, context, 4);                                                                   // 190\n      var keys = !isArrayLike(obj) && _.keys(obj),                                                                   // 191\n          length = (keys || obj).length,                                                                             // 192\n          index = dir > 0 ? 0 : length - 1;                                                                          // 193\n      // Determine the initial value if none is provided.                                                            // 194\n      if (arguments.length < 3) {                                                                                    // 195\n        memo = obj[keys ? keys[index] : index];                                                                      // 196\n        index += dir;                                                                                                // 197\n      }                                                                                                              // 198\n      return iterator(obj, iteratee, memo, keys, index, length);                                                     // 199\n    };                                                                                                               // 200\n  }                                                                                                                  // 201\n                                                                                                                     // 202\n  // **Reduce** builds up a single result from a list of values, aka `inject`,                                       // 203\n  // or `foldl`.                                                                                                     // 204\n  _.reduce = _.foldl = _.inject = createReduce(1);                                                                   // 205\n                                                                                                                     // 206\n  // The right-associative version of reduce, also known as `foldr`.                                                 // 207\n  _.reduceRight = _.foldr = createReduce(-1);                                                                        // 208\n                                                                                                                     // 209\n  // Return the first value which passes a truth test. Aliased as `detect`.                                          // 210\n  _.find = _.detect = function(obj, predicate, context) {                                                            // 211\n    var key;                                                                                                         // 212\n    if (isArrayLike(obj)) {                                                                                          // 213\n      key = _.findIndex(obj, predicate, context);                                                                    // 214\n    } else {                                                                                                         // 215\n      key = _.findKey(obj, predicate, context);                                                                      // 216\n    }                                                                                                                // 217\n    if (key !== void 0 && key !== -1) return obj[key];                                                               // 218\n  };                                                                                                                 // 219\n                                                                                                                     // 220\n  // Return all the elements that pass a truth test.                                                                 // 221\n  // Aliased as `select`.                                                                                            // 222\n  _.filter = _.select = function(obj, predicate, context) {                                                          // 223\n    var results = [];                                                                                                // 224\n    predicate = cb(predicate, context);                                                                              // 225\n    _.each(obj, function(value, index, list) {                                                                       // 226\n      if (predicate(value, index, list)) results.push(value);                                                        // 227\n    });                                                                                                              // 228\n    return results;                                                                                                  // 229\n  };                                                                                                                 // 230\n                                                                                                                     // 231\n  // Return all the elements for which a truth test fails.                                                           // 232\n  _.reject = function(obj, predicate, context) {                                                                     // 233\n    return _.filter(obj, _.negate(cb(predicate)), context);                                                          // 234\n  };                                                                                                                 // 235\n                                                                                                                     // 236\n  // Determine whether all of the elements match a truth test.                                                       // 237\n  // Aliased as `all`.                                                                                               // 238\n  _.every = _.all = function(obj, predicate, context) {                                                              // 239\n    predicate = cb(predicate, context);                                                                              // 240\n    var keys = !isArrayLike(obj) && _.keys(obj),                                                                     // 241\n        length = (keys || obj).length;                                                                               // 242\n    for (var index = 0; index < length; index++) {                                                                   // 243\n      var currentKey = keys ? keys[index] : index;                                                                   // 244\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;                                                // 245\n    }                                                                                                                // 246\n    return true;                                                                                                     // 247\n  };                                                                                                                 // 248\n                                                                                                                     // 249\n  // Determine if at least one element in the object matches a truth test.                                           // 250\n  // Aliased as `any`.                                                                                               // 251\n  _.some = _.any = function(obj, predicate, context) {                                                               // 252\n    predicate = cb(predicate, context);                                                                              // 253\n    var keys = !isArrayLike(obj) && _.keys(obj),                                                                     // 254\n        length = (keys || obj).length;                                                                               // 255\n    for (var index = 0; index < length; index++) {                                                                   // 256\n      var currentKey = keys ? keys[index] : index;                                                                   // 257\n      if (predicate(obj[currentKey], currentKey, obj)) return true;                                                  // 258\n    }                                                                                                                // 259\n    return false;                                                                                                    // 260\n  };                                                                                                                 // 261\n                                                                                                                     // 262\n  // Determine if the array or object contains a given item (using `===`).                                           // 263\n  // Aliased as `includes` and `include`.                                                                            // 264\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {                                      // 265\n    if (!isArrayLike(obj)) obj = _.values(obj);                                                                      // 266\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;                                                        // 267\n    return _.indexOf(obj, item, fromIndex) >= 0;                                                                     // 268\n  };                                                                                                                 // 269\n                                                                                                                     // 270\n  // Invoke a method (with arguments) on every item in a collection.                                                 // 271\n  _.invoke = function(obj, method) {                                                                                 // 272\n    var args = slice.call(arguments, 2);                                                                             // 273\n    var isFunc = _.isFunction(method);                                                                               // 274\n    return _.map(obj, function(value) {                                                                              // 275\n      var func = isFunc ? method : value[method];                                                                    // 276\n      return func == null ? func : func.apply(value, args);                                                          // 277\n    });                                                                                                              // 278\n  };                                                                                                                 // 279\n                                                                                                                     // 280\n  // Convenience version of a common use case of `map`: fetching a property.                                         // 281\n  _.pluck = function(obj, key) {                                                                                     // 282\n    return _.map(obj, _.property(key));                                                                              // 283\n  };                                                                                                                 // 284\n                                                                                                                     // 285\n  // Convenience version of a common use case of `filter`: selecting only objects                                    // 286\n  // containing specific `key:value` pairs.                                                                          // 287\n  _.where = function(obj, attrs) {                                                                                   // 288\n    return _.filter(obj, _.matcher(attrs));                                                                          // 289\n  };                                                                                                                 // 290\n                                                                                                                     // 291\n  // Convenience version of a common use case of `find`: getting the first object                                    // 292\n  // containing specific `key:value` pairs.                                                                          // 293\n  _.findWhere = function(obj, attrs) {                                                                               // 294\n    return _.find(obj, _.matcher(attrs));                                                                            // 295\n  };                                                                                                                 // 296\n                                                                                                                     // 297\n  // Return the maximum element (or element-based computation).                                                      // 298\n  _.max = function(obj, iteratee, context) {                                                                         // 299\n    var result = -Infinity, lastComputed = -Infinity,                                                                // 300\n        value, computed;                                                                                             // 301\n    if (iteratee == null && obj != null) {                                                                           // 302\n      obj = isArrayLike(obj) ? obj : _.values(obj);                                                                  // 303\n      for (var i = 0, length = obj.length; i < length; i++) {                                                        // 304\n        value = obj[i];                                                                                              // 305\n        if (value > result) {                                                                                        // 306\n          result = value;                                                                                            // 307\n        }                                                                                                            // 308\n      }                                                                                                              // 309\n    } else {                                                                                                         // 310\n      iteratee = cb(iteratee, context);                                                                              // 311\n      _.each(obj, function(value, index, list) {                                                                     // 312\n        computed = iteratee(value, index, list);                                                                     // 313\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {                             // 314\n          result = value;                                                                                            // 315\n          lastComputed = computed;                                                                                   // 316\n        }                                                                                                            // 317\n      });                                                                                                            // 318\n    }                                                                                                                // 319\n    return result;                                                                                                   // 320\n  };                                                                                                                 // 321\n                                                                                                                     // 322\n  // Return the minimum element (or element-based computation).                                                      // 323\n  _.min = function(obj, iteratee, context) {                                                                         // 324\n    var result = Infinity, lastComputed = Infinity,                                                                  // 325\n        value, computed;                                                                                             // 326\n    if (iteratee == null && obj != null) {                                                                           // 327\n      obj = isArrayLike(obj) ? obj : _.values(obj);                                                                  // 328\n      for (var i = 0, length = obj.length; i < length; i++) {                                                        // 329\n        value = obj[i];                                                                                              // 330\n        if (value < result) {                                                                                        // 331\n          result = value;                                                                                            // 332\n        }                                                                                                            // 333\n      }                                                                                                              // 334\n    } else {                                                                                                         // 335\n      iteratee = cb(iteratee, context);                                                                              // 336\n      _.each(obj, function(value, index, list) {                                                                     // 337\n        computed = iteratee(value, index, list);                                                                     // 338\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {                               // 339\n          result = value;                                                                                            // 340\n          lastComputed = computed;                                                                                   // 341\n        }                                                                                                            // 342\n      });                                                                                                            // 343\n    }                                                                                                                // 344\n    return result;                                                                                                   // 345\n  };                                                                                                                 // 346\n                                                                                                                     // 347\n  // Shuffle a collection, using the modern version of the                                                           // 348\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).                                      // 349\n  _.shuffle = function(obj) {                                                                                        // 350\n    var set = isArrayLike(obj) ? obj : _.values(obj);                                                                // 351\n    var length = set.length;                                                                                         // 352\n    var shuffled = Array(length);                                                                                    // 353\n    for (var index = 0, rand; index < length; index++) {                                                             // 354\n      rand = _.random(0, index);                                                                                     // 355\n      if (rand !== index) shuffled[index] = shuffled[rand];                                                          // 356\n      shuffled[rand] = set[index];                                                                                   // 357\n    }                                                                                                                // 358\n    return shuffled;                                                                                                 // 359\n  };                                                                                                                 // 360\n                                                                                                                     // 361\n  // Sample **n** random values from a collection.                                                                   // 362\n  // If **n** is not specified, returns a single random element.                                                     // 363\n  // The internal `guard` argument allows it to work with `map`.                                                     // 364\n  _.sample = function(obj, n, guard) {                                                                               // 365\n    if (n == null || guard) {                                                                                        // 366\n      if (!isArrayLike(obj)) obj = _.values(obj);                                                                    // 367\n      return obj[_.random(obj.length - 1)];                                                                          // 368\n    }                                                                                                                // 369\n    return _.shuffle(obj).slice(0, Math.max(0, n));                                                                  // 370\n  };                                                                                                                 // 371\n                                                                                                                     // 372\n  // Sort the object's values by a criterion produced by an iteratee.                                                // 373\n  _.sortBy = function(obj, iteratee, context) {                                                                      // 374\n    iteratee = cb(iteratee, context);                                                                                // 375\n    return _.pluck(_.map(obj, function(value, index, list) {                                                         // 376\n      return {                                                                                                       // 377\n        value: value,                                                                                                // 378\n        index: index,                                                                                                // 379\n        criteria: iteratee(value, index, list)                                                                       // 380\n      };                                                                                                             // 381\n    }).sort(function(left, right) {                                                                                  // 382\n      var a = left.criteria;                                                                                         // 383\n      var b = right.criteria;                                                                                        // 384\n      if (a !== b) {                                                                                                 // 385\n        if (a > b || a === void 0) return 1;                                                                         // 386\n        if (a < b || b === void 0) return -1;                                                                        // 387\n      }                                                                                                              // 388\n      return left.index - right.index;                                                                               // 389\n    }), 'value');                                                                                                    // 390\n  };                                                                                                                 // 391\n                                                                                                                     // 392\n  // An internal function used for aggregate \"group by\" operations.                                                  // 393\n  var group = function(behavior) {                                                                                   // 394\n    return function(obj, iteratee, context) {                                                                        // 395\n      var result = {};                                                                                               // 396\n      iteratee = cb(iteratee, context);                                                                              // 397\n      _.each(obj, function(value, index) {                                                                           // 398\n        var key = iteratee(value, index, obj);                                                                       // 399\n        behavior(result, value, key);                                                                                // 400\n      });                                                                                                            // 401\n      return result;                                                                                                 // 402\n    };                                                                                                               // 403\n  };                                                                                                                 // 404\n                                                                                                                     // 405\n  // Groups the object's values by a criterion. Pass either a string attribute                                       // 406\n  // to group by, or a function that returns the criterion.                                                          // 407\n  _.groupBy = group(function(result, value, key) {                                                                   // 408\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];                                     // 409\n  });                                                                                                                // 410\n                                                                                                                     // 411\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for                                       // 412\n  // when you know that your index values will be unique.                                                            // 413\n  _.indexBy = group(function(result, value, key) {                                                                   // 414\n    result[key] = value;                                                                                             // 415\n  });                                                                                                                // 416\n                                                                                                                     // 417\n  // Counts instances of an object that group by a certain criterion. Pass                                           // 418\n  // either a string attribute to count by, or a function that returns the                                           // 419\n  // criterion.                                                                                                      // 420\n  _.countBy = group(function(result, value, key) {                                                                   // 421\n    if (_.has(result, key)) result[key]++; else result[key] = 1;                                                     // 422\n  });                                                                                                                // 423\n                                                                                                                     // 424\n  // Safely create a real, live array from anything iterable.                                                        // 425\n  _.toArray = function(obj) {                                                                                        // 426\n    if (!obj) return [];                                                                                             // 427\n    if (_.isArray(obj)) return slice.call(obj);                                                                      // 428\n    if (isArrayLike(obj)) return _.map(obj, _.identity);                                                             // 429\n    return _.values(obj);                                                                                            // 430\n  };                                                                                                                 // 431\n                                                                                                                     // 432\n  // Return the number of elements in an object.                                                                     // 433\n  _.size = function(obj) {                                                                                           // 434\n    if (obj == null) return 0;                                                                                       // 435\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;                                                       // 436\n  };                                                                                                                 // 437\n                                                                                                                     // 438\n  // Split a collection into two arrays: one whose elements all satisfy the given                                    // 439\n  // predicate, and one whose elements all do not satisfy the predicate.                                             // 440\n  _.partition = function(obj, predicate, context) {                                                                  // 441\n    predicate = cb(predicate, context);                                                                              // 442\n    var pass = [], fail = [];                                                                                        // 443\n    _.each(obj, function(value, key, obj) {                                                                          // 444\n      (predicate(value, key, obj) ? pass : fail).push(value);                                                        // 445\n    });                                                                                                              // 446\n    return [pass, fail];                                                                                             // 447\n  };                                                                                                                 // 448\n                                                                                                                     // 449\n  // Array Functions                                                                                                 // 450\n  // ---------------                                                                                                 // 451\n                                                                                                                     // 452\n  // Get the first element of an array. Passing **n** will return the first N                                        // 453\n  // values in the array. Aliased as `head` and `take`. The **guard** check                                          // 454\n  // allows it to work with `_.map`.                                                                                 // 455\n  _.first = _.head = _.take = function(array, n, guard) {                                                            // 456\n    if (array == null) return void 0;                                                                                // 457\n    if (n == null || guard) return array[0];                                                                         // 458\n    return _.initial(array, array.length - n);                                                                       // 459\n  };                                                                                                                 // 460\n                                                                                                                     // 461\n  // Returns everything but the last entry of the array. Especially useful on                                        // 462\n  // the arguments object. Passing **n** will return all the values in                                               // 463\n  // the array, excluding the last N.                                                                                // 464\n  _.initial = function(array, n, guard) {                                                                            // 465\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));                           // 466\n  };                                                                                                                 // 467\n                                                                                                                     // 468\n  // Get the last element of an array. Passing **n** will return the last N                                          // 469\n  // values in the array.                                                                                            // 470\n  _.last = function(array, n, guard) {                                                                               // 471\n    if (array == null) return void 0;                                                                                // 472\n    if (n == null || guard) return array[array.length - 1];                                                          // 473\n    return _.rest(array, Math.max(0, array.length - n));                                                             // 474\n  };                                                                                                                 // 475\n                                                                                                                     // 476\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.                              // 477\n  // Especially useful on the arguments object. Passing an **n** will return                                         // 478\n  // the rest N values in the array.                                                                                 // 479\n  _.rest = _.tail = _.drop = function(array, n, guard) {                                                             // 480\n    return slice.call(array, n == null || guard ? 1 : n);                                                            // 481\n  };                                                                                                                 // 482\n                                                                                                                     // 483\n  // Trim out all falsy values from an array.                                                                        // 484\n  _.compact = function(array) {                                                                                      // 485\n    return _.filter(array, _.identity);                                                                              // 486\n  };                                                                                                                 // 487\n                                                                                                                     // 488\n  // Internal implementation of a recursive `flatten` function.                                                      // 489\n  var flatten = function(input, shallow, strict, startIndex) {                                                       // 490\n    var output = [], idx = 0;                                                                                        // 491\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {                                      // 492\n      var value = input[i];                                                                                          // 493\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {                                        // 494\n        //flatten current level of array or arguments object                                                         // 495\n        if (!shallow) value = flatten(value, shallow, strict);                                                       // 496\n        var j = 0, len = value.length;                                                                               // 497\n        output.length += len;                                                                                        // 498\n        while (j < len) {                                                                                            // 499\n          output[idx++] = value[j++];                                                                                // 500\n        }                                                                                                            // 501\n      } else if (!strict) {                                                                                          // 502\n        output[idx++] = value;                                                                                       // 503\n      }                                                                                                              // 504\n    }                                                                                                                // 505\n    return output;                                                                                                   // 506\n  };                                                                                                                 // 507\n                                                                                                                     // 508\n  // Flatten out an array, either recursively (by default), or just one level.                                       // 509\n  _.flatten = function(array, shallow) {                                                                             // 510\n    return flatten(array, shallow, false);                                                                           // 511\n  };                                                                                                                 // 512\n                                                                                                                     // 513\n  // Return a version of the array that does not contain the specified value(s).                                     // 514\n  _.without = function(array) {                                                                                      // 515\n    return _.difference(array, slice.call(arguments, 1));                                                            // 516\n  };                                                                                                                 // 517\n                                                                                                                     // 518\n  // Produce a duplicate-free version of the array. If the array has already                                         // 519\n  // been sorted, you have the option of using a faster algorithm.                                                   // 520\n  // Aliased as `unique`.                                                                                            // 521\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {                                                 // 522\n    if (!_.isBoolean(isSorted)) {                                                                                    // 523\n      context = iteratee;                                                                                            // 524\n      iteratee = isSorted;                                                                                           // 525\n      isSorted = false;                                                                                              // 526\n    }                                                                                                                // 527\n    if (iteratee != null) iteratee = cb(iteratee, context);                                                          // 528\n    var result = [];                                                                                                 // 529\n    var seen = [];                                                                                                   // 530\n    for (var i = 0, length = getLength(array); i < length; i++) {                                                    // 531\n      var value = array[i],                                                                                          // 532\n          computed = iteratee ? iteratee(value, i, array) : value;                                                   // 533\n      if (isSorted) {                                                                                                // 534\n        if (!i || seen !== computed) result.push(value);                                                             // 535\n        seen = computed;                                                                                             // 536\n      } else if (iteratee) {                                                                                         // 537\n        if (!_.contains(seen, computed)) {                                                                           // 538\n          seen.push(computed);                                                                                       // 539\n          result.push(value);                                                                                        // 540\n        }                                                                                                            // 541\n      } else if (!_.contains(result, value)) {                                                                       // 542\n        result.push(value);                                                                                          // 543\n      }                                                                                                              // 544\n    }                                                                                                                // 545\n    return result;                                                                                                   // 546\n  };                                                                                                                 // 547\n                                                                                                                     // 548\n  // Produce an array that contains the union: each distinct element from all of                                     // 549\n  // the passed-in arrays.                                                                                           // 550\n  _.union = function() {                                                                                             // 551\n    return _.uniq(flatten(arguments, true, true));                                                                   // 552\n  };                                                                                                                 // 553\n                                                                                                                     // 554\n  // Produce an array that contains every item shared between all the                                                // 555\n  // passed-in arrays.                                                                                               // 556\n  _.intersection = function(array) {                                                                                 // 557\n    var result = [];                                                                                                 // 558\n    var argsLength = arguments.length;                                                                               // 559\n    for (var i = 0, length = getLength(array); i < length; i++) {                                                    // 560\n      var item = array[i];                                                                                           // 561\n      if (_.contains(result, item)) continue;                                                                        // 562\n      for (var j = 1; j < argsLength; j++) {                                                                         // 563\n        if (!_.contains(arguments[j], item)) break;                                                                  // 564\n      }                                                                                                              // 565\n      if (j === argsLength) result.push(item);                                                                       // 566\n    }                                                                                                                // 567\n    return result;                                                                                                   // 568\n  };                                                                                                                 // 569\n                                                                                                                     // 570\n  // Take the difference between one array and a number of other arrays.                                             // 571\n  // Only the elements present in just the first array will remain.                                                  // 572\n  _.difference = function(array) {                                                                                   // 573\n    var rest = flatten(arguments, true, true, 1);                                                                    // 574\n    return _.filter(array, function(value){                                                                          // 575\n      return !_.contains(rest, value);                                                                               // 576\n    });                                                                                                              // 577\n  };                                                                                                                 // 578\n                                                                                                                     // 579\n  // Zip together multiple lists into a single array -- elements that share                                          // 580\n  // an index go together.                                                                                           // 581\n  _.zip = function() {                                                                                               // 582\n    return _.unzip(arguments);                                                                                       // 583\n  };                                                                                                                 // 584\n                                                                                                                     // 585\n  // Complement of _.zip. Unzip accepts an array of arrays and groups                                                // 586\n  // each array's elements on shared indices                                                                         // 587\n  _.unzip = function(array) {                                                                                        // 588\n    var length = array && _.max(array, getLength).length || 0;                                                       // 589\n    var result = Array(length);                                                                                      // 590\n                                                                                                                     // 591\n    for (var index = 0; index < length; index++) {                                                                   // 592\n      result[index] = _.pluck(array, index);                                                                         // 593\n    }                                                                                                                // 594\n    return result;                                                                                                   // 595\n  };                                                                                                                 // 596\n                                                                                                                     // 597\n  // Converts lists into objects. Pass either a single array of `[key, value]`                                       // 598\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of                                     // 599\n  // the corresponding values.                                                                                       // 600\n  _.object = function(list, values) {                                                                                // 601\n    var result = {};                                                                                                 // 602\n    for (var i = 0, length = getLength(list); i < length; i++) {                                                     // 603\n      if (values) {                                                                                                  // 604\n        result[list[i]] = values[i];                                                                                 // 605\n      } else {                                                                                                       // 606\n        result[list[i][0]] = list[i][1];                                                                             // 607\n      }                                                                                                              // 608\n    }                                                                                                                // 609\n    return result;                                                                                                   // 610\n  };                                                                                                                 // 611\n                                                                                                                     // 612\n  // Generator function to create the findIndex and findLastIndex functions                                          // 613\n  function createPredicateIndexFinder(dir) {                                                                         // 614\n    return function(array, predicate, context) {                                                                     // 615\n      predicate = cb(predicate, context);                                                                            // 616\n      var length = getLength(array);                                                                                 // 617\n      var index = dir > 0 ? 0 : length - 1;                                                                          // 618\n      for (; index >= 0 && index < length; index += dir) {                                                           // 619\n        if (predicate(array[index], index, array)) return index;                                                     // 620\n      }                                                                                                              // 621\n      return -1;                                                                                                     // 622\n    };                                                                                                               // 623\n  }                                                                                                                  // 624\n                                                                                                                     // 625\n  // Returns the first index on an array-like that passes a predicate test                                           // 626\n  _.findIndex = createPredicateIndexFinder(1);                                                                       // 627\n  _.findLastIndex = createPredicateIndexFinder(-1);                                                                  // 628\n                                                                                                                     // 629\n  // Use a comparator function to figure out the smallest index at which                                             // 630\n  // an object should be inserted so as to maintain order. Uses binary search.                                       // 631\n  _.sortedIndex = function(array, obj, iteratee, context) {                                                          // 632\n    iteratee = cb(iteratee, context, 1);                                                                             // 633\n    var value = iteratee(obj);                                                                                       // 634\n    var low = 0, high = getLength(array);                                                                            // 635\n    while (low < high) {                                                                                             // 636\n      var mid = Math.floor((low + high) / 2);                                                                        // 637\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;                                              // 638\n    }                                                                                                                // 639\n    return low;                                                                                                      // 640\n  };                                                                                                                 // 641\n                                                                                                                     // 642\n  // Generator function to create the indexOf and lastIndexOf functions                                              // 643\n  function createIndexFinder(dir, predicateFind, sortedIndex) {                                                      // 644\n    return function(array, item, idx) {                                                                              // 645\n      var i = 0, length = getLength(array);                                                                          // 646\n      if (typeof idx == 'number') {                                                                                  // 647\n        if (dir > 0) {                                                                                               // 648\n            i = idx >= 0 ? idx : Math.max(idx + length, i);                                                          // 649\n        } else {                                                                                                     // 650\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;                                        // 651\n        }                                                                                                            // 652\n      } else if (sortedIndex && idx && length) {                                                                     // 653\n        idx = sortedIndex(array, item);                                                                              // 654\n        return array[idx] === item ? idx : -1;                                                                       // 655\n      }                                                                                                              // 656\n      if (item !== item) {                                                                                           // 657\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);                                                  // 658\n        return idx >= 0 ? idx + i : -1;                                                                              // 659\n      }                                                                                                              // 660\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {                                   // 661\n        if (array[idx] === item) return idx;                                                                         // 662\n      }                                                                                                              // 663\n      return -1;                                                                                                     // 664\n    };                                                                                                               // 665\n  }                                                                                                                  // 666\n                                                                                                                     // 667\n  // Return the position of the first occurrence of an item in an array,                                             // 668\n  // or -1 if the item is not included in the array.                                                                 // 669\n  // If the array is large and already in sort order, pass `true`                                                    // 670\n  // for **isSorted** to use binary search.                                                                          // 671\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);                                                      // 672\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);                                                            // 673\n                                                                                                                     // 674\n  // Generate an integer Array containing an arithmetic progression. A port of                                       // 675\n  // the native Python `range()` function. See                                                                       // 676\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).                                // 677\n  _.range = function(start, stop, step) {                                                                            // 678\n    if (stop == null) {                                                                                              // 679\n      stop = start || 0;                                                                                             // 680\n      start = 0;                                                                                                     // 681\n    }                                                                                                                // 682\n    step = step || 1;                                                                                                // 683\n                                                                                                                     // 684\n    var length = Math.max(Math.ceil((stop - start) / step), 0);                                                      // 685\n    var range = Array(length);                                                                                       // 686\n                                                                                                                     // 687\n    for (var idx = 0; idx < length; idx++, start += step) {                                                          // 688\n      range[idx] = start;                                                                                            // 689\n    }                                                                                                                // 690\n                                                                                                                     // 691\n    return range;                                                                                                    // 692\n  };                                                                                                                 // 693\n                                                                                                                     // 694\n  // Function (ahem) Functions                                                                                       // 695\n  // ------------------                                                                                              // 696\n                                                                                                                     // 697\n  // Determines whether to execute a function as a constructor                                                       // 698\n  // or a normal function with the provided arguments                                                                // 699\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {                                // 700\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);                              // 701\n    var self = baseCreate(sourceFunc.prototype);                                                                     // 702\n    var result = sourceFunc.apply(self, args);                                                                       // 703\n    if (_.isObject(result)) return result;                                                                           // 704\n    return self;                                                                                                     // 705\n  };                                                                                                                 // 706\n                                                                                                                     // 707\n  // Create a function bound to a given object (assigning `this`, and arguments,                                     // 708\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if                                          // 709\n  // available.                                                                                                      // 710\n  _.bind = function(func, context) {                                                                                 // 711\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));             // 712\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');                               // 713\n    var args = slice.call(arguments, 2);                                                                             // 714\n    var bound = function() {                                                                                         // 715\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));                           // 716\n    };                                                                                                               // 717\n    return bound;                                                                                                    // 718\n  };                                                                                                                 // 719\n                                                                                                                     // 720\n  // Partially apply a function by creating a version that has had some of its                                       // 721\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts                                       // 722\n  // as a placeholder, allowing any combination of arguments to be pre-filled.                                       // 723\n  _.partial = function(func) {                                                                                       // 724\n    var boundArgs = slice.call(arguments, 1);                                                                        // 725\n    var bound = function() {                                                                                         // 726\n      var position = 0, length = boundArgs.length;                                                                   // 727\n      var args = Array(length);                                                                                      // 728\n      for (var i = 0; i < length; i++) {                                                                             // 729\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];                                         // 730\n      }                                                                                                              // 731\n      while (position < arguments.length) args.push(arguments[position++]);                                          // 732\n      return executeBound(func, bound, this, this, args);                                                            // 733\n    };                                                                                                               // 734\n    return bound;                                                                                                    // 735\n  };                                                                                                                 // 736\n                                                                                                                     // 737\n  // Bind a number of an object's methods to that object. Remaining arguments                                        // 738\n  // are the method names to be bound. Useful for ensuring that all callbacks                                        // 739\n  // defined on an object belong to it.                                                                              // 740\n  _.bindAll = function(obj) {                                                                                        // 741\n    var i, length = arguments.length, key;                                                                           // 742\n    if (length <= 1) throw new Error('bindAll must be passed function names');                                       // 743\n    for (i = 1; i < length; i++) {                                                                                   // 744\n      key = arguments[i];                                                                                            // 745\n      obj[key] = _.bind(obj[key], obj);                                                                              // 746\n    }                                                                                                                // 747\n    return obj;                                                                                                      // 748\n  };                                                                                                                 // 749\n                                                                                                                     // 750\n  // Memoize an expensive function by storing its results.                                                           // 751\n  _.memoize = function(func, hasher) {                                                                               // 752\n    var memoize = function(key) {                                                                                    // 753\n      var cache = memoize.cache;                                                                                     // 754\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);                                             // 755\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);                                      // 756\n      return cache[address];                                                                                         // 757\n    };                                                                                                               // 758\n    memoize.cache = {};                                                                                              // 759\n    return memoize;                                                                                                  // 760\n  };                                                                                                                 // 761\n                                                                                                                     // 762\n  // Delays a function for the given number of milliseconds, and then calls                                          // 763\n  // it with the arguments supplied.                                                                                 // 764\n  _.delay = function(func, wait) {                                                                                   // 765\n    var args = slice.call(arguments, 2);                                                                             // 766\n    return setTimeout(function(){                                                                                    // 767\n      return func.apply(null, args);                                                                                 // 768\n    }, wait);                                                                                                        // 769\n  };                                                                                                                 // 770\n                                                                                                                     // 771\n  // Defers a function, scheduling it to run after the current call stack has                                        // 772\n  // cleared.                                                                                                        // 773\n  _.defer = _.partial(_.delay, _, 1);                                                                                // 774\n                                                                                                                     // 775\n  // Returns a function, that, when invoked, will only be triggered at most once                                     // 776\n  // during a given window of time. Normally, the throttled function will run                                        // 777\n  // as much as it can, without ever going more than once per `wait` duration;                                       // 778\n  // but if you'd like to disable the execution on the leading edge, pass                                            // 779\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.                                           // 780\n  _.throttle = function(func, wait, options) {                                                                       // 781\n    var context, args, result;                                                                                       // 782\n    var timeout = null;                                                                                              // 783\n    var previous = 0;                                                                                                // 784\n    if (!options) options = {};                                                                                      // 785\n    var later = function() {                                                                                         // 786\n      previous = options.leading === false ? 0 : _.now();                                                            // 787\n      timeout = null;                                                                                                // 788\n      result = func.apply(context, args);                                                                            // 789\n      if (!timeout) context = args = null;                                                                           // 790\n    };                                                                                                               // 791\n    return function() {                                                                                              // 792\n      var now = _.now();                                                                                             // 793\n      if (!previous && options.leading === false) previous = now;                                                    // 794\n      var remaining = wait - (now - previous);                                                                       // 795\n      context = this;                                                                                                // 796\n      args = arguments;                                                                                              // 797\n      if (remaining <= 0 || remaining > wait) {                                                                      // 798\n        if (timeout) {                                                                                               // 799\n          clearTimeout(timeout);                                                                                     // 800\n          timeout = null;                                                                                            // 801\n        }                                                                                                            // 802\n        previous = now;                                                                                              // 803\n        result = func.apply(context, args);                                                                          // 804\n        if (!timeout) context = args = null;                                                                         // 805\n      } else if (!timeout && options.trailing !== false) {                                                           // 806\n        timeout = setTimeout(later, remaining);                                                                      // 807\n      }                                                                                                              // 808\n      return result;                                                                                                 // 809\n    };                                                                                                               // 810\n  };                                                                                                                 // 811\n                                                                                                                     // 812\n  // Returns a function, that, as long as it continues to be invoked, will not                                       // 813\n  // be triggered. The function will be called after it stops being called for                                       // 814\n  // N milliseconds. If `immediate` is passed, trigger the function on the                                           // 815\n  // leading edge, instead of the trailing.                                                                          // 816\n  _.debounce = function(func, wait, immediate) {                                                                     // 817\n    var timeout, args, context, timestamp, result;                                                                   // 818\n                                                                                                                     // 819\n    var later = function() {                                                                                         // 820\n      var last = _.now() - timestamp;                                                                                // 821\n                                                                                                                     // 822\n      if (last < wait && last >= 0) {                                                                                // 823\n        timeout = setTimeout(later, wait - last);                                                                    // 824\n      } else {                                                                                                       // 825\n        timeout = null;                                                                                              // 826\n        if (!immediate) {                                                                                            // 827\n          result = func.apply(context, args);                                                                        // 828\n          if (!timeout) context = args = null;                                                                       // 829\n        }                                                                                                            // 830\n      }                                                                                                              // 831\n    };                                                                                                               // 832\n                                                                                                                     // 833\n    return function() {                                                                                              // 834\n      context = this;                                                                                                // 835\n      args = arguments;                                                                                              // 836\n      timestamp = _.now();                                                                                           // 837\n      var callNow = immediate && !timeout;                                                                           // 838\n      if (!timeout) timeout = setTimeout(later, wait);                                                               // 839\n      if (callNow) {                                                                                                 // 840\n        result = func.apply(context, args);                                                                          // 841\n        context = args = null;                                                                                       // 842\n      }                                                                                                              // 843\n                                                                                                                     // 844\n      return result;                                                                                                 // 845\n    };                                                                                                               // 846\n  };                                                                                                                 // 847\n                                                                                                                     // 848\n  // Returns the first function passed as an argument to the second,                                                 // 849\n  // allowing you to adjust arguments, run code before and after, and                                                // 850\n  // conditionally execute the original function.                                                                    // 851\n  _.wrap = function(func, wrapper) {                                                                                 // 852\n    return _.partial(wrapper, func);                                                                                 // 853\n  };                                                                                                                 // 854\n                                                                                                                     // 855\n  // Returns a negated version of the passed-in predicate.                                                           // 856\n  _.negate = function(predicate) {                                                                                   // 857\n    return function() {                                                                                              // 858\n      return !predicate.apply(this, arguments);                                                                      // 859\n    };                                                                                                               // 860\n  };                                                                                                                 // 861\n                                                                                                                     // 862\n  // Returns a function that is the composition of a list of functions, each                                         // 863\n  // consuming the return value of the function that follows.                                                        // 864\n  _.compose = function() {                                                                                           // 865\n    var args = arguments;                                                                                            // 866\n    var start = args.length - 1;                                                                                     // 867\n    return function() {                                                                                              // 868\n      var i = start;                                                                                                 // 869\n      var result = args[start].apply(this, arguments);                                                               // 870\n      while (i--) result = args[i].call(this, result);                                                               // 871\n      return result;                                                                                                 // 872\n    };                                                                                                               // 873\n  };                                                                                                                 // 874\n                                                                                                                     // 875\n  // Returns a function that will only be executed on and after the Nth call.                                        // 876\n  _.after = function(times, func) {                                                                                  // 877\n    return function() {                                                                                              // 878\n      if (--times < 1) {                                                                                             // 879\n        return func.apply(this, arguments);                                                                          // 880\n      }                                                                                                              // 881\n    };                                                                                                               // 882\n  };                                                                                                                 // 883\n                                                                                                                     // 884\n  // Returns a function that will only be executed up to (but not including) the Nth call.                           // 885\n  _.before = function(times, func) {                                                                                 // 886\n    var memo;                                                                                                        // 887\n    return function() {                                                                                              // 888\n      if (--times > 0) {                                                                                             // 889\n        memo = func.apply(this, arguments);                                                                          // 890\n      }                                                                                                              // 891\n      if (times <= 1) func = null;                                                                                   // 892\n      return memo;                                                                                                   // 893\n    };                                                                                                               // 894\n  };                                                                                                                 // 895\n                                                                                                                     // 896\n  // Returns a function that will be executed at most one time, no matter how                                        // 897\n  // often you call it. Useful for lazy initialization.                                                              // 898\n  _.once = _.partial(_.before, 2);                                                                                   // 899\n                                                                                                                     // 900\n  // Object Functions                                                                                                // 901\n  // ----------------                                                                                                // 902\n                                                                                                                     // 903\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.                                      // 904\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');                                               // 905\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',                                                  // 906\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];                                   // 907\n                                                                                                                     // 908\n  function collectNonEnumProps(obj, keys) {                                                                          // 909\n    var nonEnumIdx = nonEnumerableProps.length;                                                                      // 910\n    var constructor = obj.constructor;                                                                               // 911\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;                                    // 912\n                                                                                                                     // 913\n    // Constructor is a special case.                                                                                // 914\n    var prop = 'constructor';                                                                                        // 915\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);                                                // 916\n                                                                                                                     // 917\n    while (nonEnumIdx--) {                                                                                           // 918\n      prop = nonEnumerableProps[nonEnumIdx];                                                                         // 919\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {                                     // 920\n        keys.push(prop);                                                                                             // 921\n      }                                                                                                              // 922\n    }                                                                                                                // 923\n  }                                                                                                                  // 924\n                                                                                                                     // 925\n  // Retrieve the names of an object's own properties.                                                               // 926\n  // Delegates to **ECMAScript 5**'s native `Object.keys`                                                            // 927\n  _.keys = function(obj) {                                                                                           // 928\n    if (!_.isObject(obj)) return [];                                                                                 // 929\n    if (nativeKeys) return nativeKeys(obj);                                                                          // 930\n    var keys = [];                                                                                                   // 931\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);                                                        // 932\n    // Ahem, IE < 9.                                                                                                 // 933\n    if (hasEnumBug) collectNonEnumProps(obj, keys);                                                                  // 934\n    return keys;                                                                                                     // 935\n  };                                                                                                                 // 936\n                                                                                                                     // 937\n  // Retrieve all the property names of an object.                                                                   // 938\n  _.allKeys = function(obj) {                                                                                        // 939\n    if (!_.isObject(obj)) return [];                                                                                 // 940\n    var keys = [];                                                                                                   // 941\n    for (var key in obj) keys.push(key);                                                                             // 942\n    // Ahem, IE < 9.                                                                                                 // 943\n    if (hasEnumBug) collectNonEnumProps(obj, keys);                                                                  // 944\n    return keys;                                                                                                     // 945\n  };                                                                                                                 // 946\n                                                                                                                     // 947\n  // Retrieve the values of an object's properties.                                                                  // 948\n  _.values = function(obj) {                                                                                         // 949\n    var keys = _.keys(obj);                                                                                          // 950\n    var length = keys.length;                                                                                        // 951\n    var values = Array(length);                                                                                      // 952\n    for (var i = 0; i < length; i++) {                                                                               // 953\n      values[i] = obj[keys[i]];                                                                                      // 954\n    }                                                                                                                // 955\n    return values;                                                                                                   // 956\n  };                                                                                                                 // 957\n                                                                                                                     // 958\n  // Returns the results of applying the iteratee to each element of the object                                      // 959\n  // In contrast to _.map it returns an object                                                                       // 960\n  _.mapObject = function(obj, iteratee, context) {                                                                   // 961\n    iteratee = cb(iteratee, context);                                                                                // 962\n    var keys =  _.keys(obj),                                                                                         // 963\n          length = keys.length,                                                                                      // 964\n          results = {},                                                                                              // 965\n          currentKey;                                                                                                // 966\n      for (var index = 0; index < length; index++) {                                                                 // 967\n        currentKey = keys[index];                                                                                    // 968\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);                                            // 969\n      }                                                                                                              // 970\n      return results;                                                                                                // 971\n  };                                                                                                                 // 972\n                                                                                                                     // 973\n  // Convert an object into a list of `[key, value]` pairs.                                                          // 974\n  _.pairs = function(obj) {                                                                                          // 975\n    var keys = _.keys(obj);                                                                                          // 976\n    var length = keys.length;                                                                                        // 977\n    var pairs = Array(length);                                                                                       // 978\n    for (var i = 0; i < length; i++) {                                                                               // 979\n      pairs[i] = [keys[i], obj[keys[i]]];                                                                            // 980\n    }                                                                                                                // 981\n    return pairs;                                                                                                    // 982\n  };                                                                                                                 // 983\n                                                                                                                     // 984\n  // Invert the keys and values of an object. The values must be serializable.                                       // 985\n  _.invert = function(obj) {                                                                                         // 986\n    var result = {};                                                                                                 // 987\n    var keys = _.keys(obj);                                                                                          // 988\n    for (var i = 0, length = keys.length; i < length; i++) {                                                         // 989\n      result[obj[keys[i]]] = keys[i];                                                                                // 990\n    }                                                                                                                // 991\n    return result;                                                                                                   // 992\n  };                                                                                                                 // 993\n                                                                                                                     // 994\n  // Return a sorted list of the function names available on the object.                                             // 995\n  // Aliased as `methods`                                                                                            // 996\n  _.functions = _.methods = function(obj) {                                                                          // 997\n    var names = [];                                                                                                  // 998\n    for (var key in obj) {                                                                                           // 999\n      if (_.isFunction(obj[key])) names.push(key);                                                                   // 1000\n    }                                                                                                                // 1001\n    return names.sort();                                                                                             // 1002\n  };                                                                                                                 // 1003\n                                                                                                                     // 1004\n  // Extend a given object with all the properties in passed-in object(s).                                           // 1005\n  _.extend = createAssigner(_.allKeys);                                                                              // 1006\n                                                                                                                     // 1007\n  // Assigns a given object with all the own properties in the passed-in object(s)                                   // 1008\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)                      // 1009\n  _.extendOwn = _.assign = createAssigner(_.keys);                                                                   // 1010\n                                                                                                                     // 1011\n  // Returns the first key on an object that passes a predicate test                                                 // 1012\n  _.findKey = function(obj, predicate, context) {                                                                    // 1013\n    predicate = cb(predicate, context);                                                                              // 1014\n    var keys = _.keys(obj), key;                                                                                     // 1015\n    for (var i = 0, length = keys.length; i < length; i++) {                                                         // 1016\n      key = keys[i];                                                                                                 // 1017\n      if (predicate(obj[key], key, obj)) return key;                                                                 // 1018\n    }                                                                                                                // 1019\n  };                                                                                                                 // 1020\n                                                                                                                     // 1021\n  // Return a copy of the object only containing the whitelisted properties.                                         // 1022\n  _.pick = function(object, oiteratee, context) {                                                                    // 1023\n    var result = {}, obj = object, iteratee, keys;                                                                   // 1024\n    if (obj == null) return result;                                                                                  // 1025\n    if (_.isFunction(oiteratee)) {                                                                                   // 1026\n      keys = _.allKeys(obj);                                                                                         // 1027\n      iteratee = optimizeCb(oiteratee, context);                                                                     // 1028\n    } else {                                                                                                         // 1029\n      keys = flatten(arguments, false, false, 1);                                                                    // 1030\n      iteratee = function(value, key, obj) { return key in obj; };                                                   // 1031\n      obj = Object(obj);                                                                                             // 1032\n    }                                                                                                                // 1033\n    for (var i = 0, length = keys.length; i < length; i++) {                                                         // 1034\n      var key = keys[i];                                                                                             // 1035\n      var value = obj[key];                                                                                          // 1036\n      if (iteratee(value, key, obj)) result[key] = value;                                                            // 1037\n    }                                                                                                                // 1038\n    return result;                                                                                                   // 1039\n  };                                                                                                                 // 1040\n                                                                                                                     // 1041\n   // Return a copy of the object without the blacklisted properties.                                                // 1042\n  _.omit = function(obj, iteratee, context) {                                                                        // 1043\n    if (_.isFunction(iteratee)) {                                                                                    // 1044\n      iteratee = _.negate(iteratee);                                                                                 // 1045\n    } else {                                                                                                         // 1046\n      var keys = _.map(flatten(arguments, false, false, 1), String);                                                 // 1047\n      iteratee = function(value, key) {                                                                              // 1048\n        return !_.contains(keys, key);                                                                               // 1049\n      };                                                                                                             // 1050\n    }                                                                                                                // 1051\n    return _.pick(obj, iteratee, context);                                                                           // 1052\n  };                                                                                                                 // 1053\n                                                                                                                     // 1054\n  // Fill in a given object with default properties.                                                                 // 1055\n  _.defaults = createAssigner(_.allKeys, true);                                                                      // 1056\n                                                                                                                     // 1057\n  // Creates an object that inherits from the given prototype object.                                                // 1058\n  // If additional properties are provided then they will be added to the                                            // 1059\n  // created object.                                                                                                 // 1060\n  _.create = function(prototype, props) {                                                                            // 1061\n    var result = baseCreate(prototype);                                                                              // 1062\n    if (props) _.extendOwn(result, props);                                                                           // 1063\n    return result;                                                                                                   // 1064\n  };                                                                                                                 // 1065\n                                                                                                                     // 1066\n  // Create a (shallow-cloned) duplicate of an object.                                                               // 1067\n  _.clone = function(obj) {                                                                                          // 1068\n    if (!_.isObject(obj)) return obj;                                                                                // 1069\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);                                                         // 1070\n  };                                                                                                                 // 1071\n                                                                                                                     // 1072\n  // Invokes interceptor with the obj, and then returns obj.                                                         // 1073\n  // The primary purpose of this method is to \"tap into\" a method chain, in                                          // 1074\n  // order to perform operations on intermediate results within the chain.                                           // 1075\n  _.tap = function(obj, interceptor) {                                                                               // 1076\n    interceptor(obj);                                                                                                // 1077\n    return obj;                                                                                                      // 1078\n  };                                                                                                                 // 1079\n                                                                                                                     // 1080\n  // Returns whether an object has a given set of `key:value` pairs.                                                 // 1081\n  _.isMatch = function(object, attrs) {                                                                              // 1082\n    var keys = _.keys(attrs), length = keys.length;                                                                  // 1083\n    if (object == null) return !length;                                                                              // 1084\n    var obj = Object(object);                                                                                        // 1085\n    for (var i = 0; i < length; i++) {                                                                               // 1086\n      var key = keys[i];                                                                                             // 1087\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;                                                    // 1088\n    }                                                                                                                // 1089\n    return true;                                                                                                     // 1090\n  };                                                                                                                 // 1091\n                                                                                                                     // 1092\n                                                                                                                     // 1093\n  // Internal recursive comparison function for `isEqual`.                                                           // 1094\n  var eq = function(a, b, aStack, bStack) {                                                                          // 1095\n    // Identical objects are equal. `0 === -0`, but they aren't identical.                                           // 1096\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).                       // 1097\n    if (a === b) return a !== 0 || 1 / a === 1 / b;                                                                  // 1098\n    // A strict comparison is necessary because `null == undefined`.                                                 // 1099\n    if (a == null || b == null) return a === b;                                                                      // 1100\n    // Unwrap any wrapped objects.                                                                                   // 1101\n    if (a instanceof _) a = a._wrapped;                                                                              // 1102\n    if (b instanceof _) b = b._wrapped;                                                                              // 1103\n    // Compare `[[Class]]` names.                                                                                    // 1104\n    var className = toString.call(a);                                                                                // 1105\n    if (className !== toString.call(b)) return false;                                                                // 1106\n    switch (className) {                                                                                             // 1107\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.                           // 1108\n      case '[object RegExp]':                                                                                        // 1109\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')                                  // 1110\n      case '[object String]':                                                                                        // 1111\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is                         // 1112\n        // equivalent to `new String(\"5\")`.                                                                          // 1113\n        return '' + a === '' + b;                                                                                    // 1114\n      case '[object Number]':                                                                                        // 1115\n        // `NaN`s are equivalent, but non-reflexive.                                                                 // 1116\n        // Object(NaN) is equivalent to NaN                                                                          // 1117\n        if (+a !== +a) return +b !== +b;                                                                             // 1118\n        // An `egal` comparison is performed for other numeric values.                                               // 1119\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;                                                              // 1120\n      case '[object Date]':                                                                                          // 1121\n      case '[object Boolean]':                                                                                       // 1122\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their                        // 1123\n        // millisecond representations. Note that invalid dates with millisecond representations                     // 1124\n        // of `NaN` are not equivalent.                                                                              // 1125\n        return +a === +b;                                                                                            // 1126\n    }                                                                                                                // 1127\n                                                                                                                     // 1128\n    var areArrays = className === '[object Array]';                                                                  // 1129\n    if (!areArrays) {                                                                                                // 1130\n      if (typeof a != 'object' || typeof b != 'object') return false;                                                // 1131\n                                                                                                                     // 1132\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s                           // 1133\n      // from different frames are.                                                                                  // 1134\n      var aCtor = a.constructor, bCtor = b.constructor;                                                              // 1135\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&                                      // 1136\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)                                        // 1137\n                          && ('constructor' in a && 'constructor' in b)) {                                           // 1138\n        return false;                                                                                                // 1139\n      }                                                                                                              // 1140\n    }                                                                                                                // 1141\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic                                     // 1142\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.                                   // 1143\n                                                                                                                     // 1144\n    // Initializing stack of traversed objects.                                                                      // 1145\n    // It's done here since we only need them for objects and arrays comparison.                                     // 1146\n    aStack = aStack || [];                                                                                           // 1147\n    bStack = bStack || [];                                                                                           // 1148\n    var length = aStack.length;                                                                                      // 1149\n    while (length--) {                                                                                               // 1150\n      // Linear search. Performance is inversely proportional to the number of                                       // 1151\n      // unique nested structures.                                                                                   // 1152\n      if (aStack[length] === a) return bStack[length] === b;                                                         // 1153\n    }                                                                                                                // 1154\n                                                                                                                     // 1155\n    // Add the first object to the stack of traversed objects.                                                       // 1156\n    aStack.push(a);                                                                                                  // 1157\n    bStack.push(b);                                                                                                  // 1158\n                                                                                                                     // 1159\n    // Recursively compare objects and arrays.                                                                       // 1160\n    if (areArrays) {                                                                                                 // 1161\n      // Compare array lengths to determine if a deep comparison is necessary.                                       // 1162\n      length = a.length;                                                                                             // 1163\n      if (length !== b.length) return false;                                                                         // 1164\n      // Deep compare the contents, ignoring non-numeric properties.                                                 // 1165\n      while (length--) {                                                                                             // 1166\n        if (!eq(a[length], b[length], aStack, bStack)) return false;                                                 // 1167\n      }                                                                                                              // 1168\n    } else {                                                                                                         // 1169\n      // Deep compare objects.                                                                                       // 1170\n      var keys = _.keys(a), key;                                                                                     // 1171\n      length = keys.length;                                                                                          // 1172\n      // Ensure that both objects contain the same number of properties before comparing deep equality.              // 1173\n      if (_.keys(b).length !== length) return false;                                                                 // 1174\n      while (length--) {                                                                                             // 1175\n        // Deep compare each member                                                                                  // 1176\n        key = keys[length];                                                                                          // 1177\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;                                    // 1178\n      }                                                                                                              // 1179\n    }                                                                                                                // 1180\n    // Remove the first object from the stack of traversed objects.                                                  // 1181\n    aStack.pop();                                                                                                    // 1182\n    bStack.pop();                                                                                                    // 1183\n    return true;                                                                                                     // 1184\n  };                                                                                                                 // 1185\n                                                                                                                     // 1186\n  // Perform a deep comparison to check if two objects are equal.                                                    // 1187\n  _.isEqual = function(a, b) {                                                                                       // 1188\n    return eq(a, b);                                                                                                 // 1189\n  };                                                                                                                 // 1190\n                                                                                                                     // 1191\n  // Is a given array, string, or object empty?                                                                      // 1192\n  // An \"empty\" object has no enumerable own-properties.                                                             // 1193\n  _.isEmpty = function(obj) {                                                                                        // 1194\n    if (obj == null) return true;                                                                                    // 1195\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;      // 1196\n    return _.keys(obj).length === 0;                                                                                 // 1197\n  };                                                                                                                 // 1198\n                                                                                                                     // 1199\n  // Is a given value a DOM element?                                                                                 // 1200\n  _.isElement = function(obj) {                                                                                      // 1201\n    return !!(obj && obj.nodeType === 1);                                                                            // 1202\n  };                                                                                                                 // 1203\n                                                                                                                     // 1204\n  // Is a given value an array?                                                                                      // 1205\n  // Delegates to ECMA5's native Array.isArray                                                                       // 1206\n  _.isArray = nativeIsArray || function(obj) {                                                                       // 1207\n    return toString.call(obj) === '[object Array]';                                                                  // 1208\n  };                                                                                                                 // 1209\n                                                                                                                     // 1210\n  // Is a given variable an object?                                                                                  // 1211\n  _.isObject = function(obj) {                                                                                       // 1212\n    var type = typeof obj;                                                                                           // 1213\n    return type === 'function' || type === 'object' && !!obj;                                                        // 1214\n  };                                                                                                                 // 1215\n                                                                                                                     // 1216\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.                // 1217\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {                  // 1218\n    _['is' + name] = function(obj) {                                                                                 // 1219\n      return toString.call(obj) === '[object ' + name + ']';                                                         // 1220\n    };                                                                                                               // 1221\n  });                                                                                                                // 1222\n                                                                                                                     // 1223\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where                                       // 1224\n  // there isn't any inspectable \"Arguments\" type.                                                                   // 1225\n  if (!_.isArguments(arguments)) {                                                                                   // 1226\n    _.isArguments = function(obj) {                                                                                  // 1227\n      return _.has(obj, 'callee');                                                                                   // 1228\n    };                                                                                                               // 1229\n  }                                                                                                                  // 1230\n                                                                                                                     // 1231\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,                                   // 1232\n  // IE 11 (#1621), and in Safari 8 (#1929).                                                                         // 1233\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {                                                    // 1234\n    _.isFunction = function(obj) {                                                                                   // 1235\n      return typeof obj == 'function' || false;                                                                      // 1236\n    };                                                                                                               // 1237\n  }                                                                                                                  // 1238\n                                                                                                                     // 1239\n  // Is a given object a finite number?                                                                              // 1240\n  _.isFinite = function(obj) {                                                                                       // 1241\n    return isFinite(obj) && !isNaN(parseFloat(obj));                                                                 // 1242\n  };                                                                                                                 // 1243\n                                                                                                                     // 1244\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).                                 // 1245\n  _.isNaN = function(obj) {                                                                                          // 1246\n    return _.isNumber(obj) && obj !== +obj;                                                                          // 1247\n  };                                                                                                                 // 1248\n                                                                                                                     // 1249\n  // Is a given value a boolean?                                                                                     // 1250\n  _.isBoolean = function(obj) {                                                                                      // 1251\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';                               // 1252\n  };                                                                                                                 // 1253\n                                                                                                                     // 1254\n  // Is a given value equal to null?                                                                                 // 1255\n  _.isNull = function(obj) {                                                                                         // 1256\n    return obj === null;                                                                                             // 1257\n  };                                                                                                                 // 1258\n                                                                                                                     // 1259\n  // Is a given variable undefined?                                                                                  // 1260\n  _.isUndefined = function(obj) {                                                                                    // 1261\n    return obj === void 0;                                                                                           // 1262\n  };                                                                                                                 // 1263\n                                                                                                                     // 1264\n  // Shortcut function for checking if an object has a given property directly                                       // 1265\n  // on itself (in other words, not on a prototype).                                                                 // 1266\n  _.has = function(obj, key) {                                                                                       // 1267\n    return obj != null && hasOwnProperty.call(obj, key);                                                             // 1268\n  };                                                                                                                 // 1269\n                                                                                                                     // 1270\n  // Utility Functions                                                                                               // 1271\n  // -----------------                                                                                               // 1272\n                                                                                                                     // 1273\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its                                       // 1274\n  // previous owner. Returns a reference to the Underscore object.                                                   // 1275\n  _.noConflict = function() {                                                                                        // 1276\n    root._ = previousUnderscore;                                                                                     // 1277\n    return this;                                                                                                     // 1278\n  };                                                                                                                 // 1279\n                                                                                                                     // 1280\n  // Keep the identity function around for default iteratees.                                                        // 1281\n  _.identity = function(value) {                                                                                     // 1282\n    return value;                                                                                                    // 1283\n  };                                                                                                                 // 1284\n                                                                                                                     // 1285\n  // Predicate-generating functions. Often useful outside of Underscore.                                             // 1286\n  _.constant = function(value) {                                                                                     // 1287\n    return function() {                                                                                              // 1288\n      return value;                                                                                                  // 1289\n    };                                                                                                               // 1290\n  };                                                                                                                 // 1291\n                                                                                                                     // 1292\n  _.noop = function(){};                                                                                             // 1293\n                                                                                                                     // 1294\n  _.property = property;                                                                                             // 1295\n                                                                                                                     // 1296\n  // Generates a function for a given object that returns a given property.                                          // 1297\n  _.propertyOf = function(obj) {                                                                                     // 1298\n    return obj == null ? function(){} : function(key) {                                                              // 1299\n      return obj[key];                                                                                               // 1300\n    };                                                                                                               // 1301\n  };                                                                                                                 // 1302\n                                                                                                                     // 1303\n  // Returns a predicate for checking whether an object has a given set of                                           // 1304\n  // `key:value` pairs.                                                                                              // 1305\n  _.matcher = _.matches = function(attrs) {                                                                          // 1306\n    attrs = _.extendOwn({}, attrs);                                                                                  // 1307\n    return function(obj) {                                                                                           // 1308\n      return _.isMatch(obj, attrs);                                                                                  // 1309\n    };                                                                                                               // 1310\n  };                                                                                                                 // 1311\n                                                                                                                     // 1312\n  // Run a function **n** times.                                                                                     // 1313\n  _.times = function(n, iteratee, context) {                                                                         // 1314\n    var accum = Array(Math.max(0, n));                                                                               // 1315\n    iteratee = optimizeCb(iteratee, context, 1);                                                                     // 1316\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);                                                              // 1317\n    return accum;                                                                                                    // 1318\n  };                                                                                                                 // 1319\n                                                                                                                     // 1320\n  // Return a random integer between min and max (inclusive).                                                        // 1321\n  _.random = function(min, max) {                                                                                    // 1322\n    if (max == null) {                                                                                               // 1323\n      max = min;                                                                                                     // 1324\n      min = 0;                                                                                                       // 1325\n    }                                                                                                                // 1326\n    return min + Math.floor(Math.random() * (max - min + 1));                                                        // 1327\n  };                                                                                                                 // 1328\n                                                                                                                     // 1329\n  // A (possibly faster) way to get the current timestamp as an integer.                                             // 1330\n  _.now = Date.now || function() {                                                                                   // 1331\n    return new Date().getTime();                                                                                     // 1332\n  };                                                                                                                 // 1333\n                                                                                                                     // 1334\n   // List of HTML entities for escaping.                                                                            // 1335\n  var escapeMap = {                                                                                                  // 1336\n    '&': '&amp;',                                                                                                    // 1337\n    '<': '&lt;',                                                                                                     // 1338\n    '>': '&gt;',                                                                                                     // 1339\n    '\"': '&quot;',                                                                                                   // 1340\n    \"'\": '&#x27;',                                                                                                   // 1341\n    '`': '&#x60;'                                                                                                    // 1342\n  };                                                                                                                 // 1343\n  var unescapeMap = _.invert(escapeMap);                                                                             // 1344\n                                                                                                                     // 1345\n  // Functions for escaping and unescaping strings to/from HTML interpolation.                                       // 1346\n  var createEscaper = function(map) {                                                                                // 1347\n    var escaper = function(match) {                                                                                  // 1348\n      return map[match];                                                                                             // 1349\n    };                                                                                                               // 1350\n    // Regexes for identifying a key that needs to be escaped                                                        // 1351\n    var source = '(?:' + _.keys(map).join('|') + ')';                                                                // 1352\n    var testRegexp = RegExp(source);                                                                                 // 1353\n    var replaceRegexp = RegExp(source, 'g');                                                                         // 1354\n    return function(string) {                                                                                        // 1355\n      string = string == null ? '' : '' + string;                                                                    // 1356\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;                              // 1357\n    };                                                                                                               // 1358\n  };                                                                                                                 // 1359\n  _.escape = createEscaper(escapeMap);                                                                               // 1360\n  _.unescape = createEscaper(unescapeMap);                                                                           // 1361\n                                                                                                                     // 1362\n  // If the value of the named `property` is a function then invoke it with the                                      // 1363\n  // `object` as context; otherwise, return it.                                                                      // 1364\n  _.result = function(object, property, fallback) {                                                                  // 1365\n    var value = object == null ? void 0 : object[property];                                                          // 1366\n    if (value === void 0) {                                                                                          // 1367\n      value = fallback;                                                                                              // 1368\n    }                                                                                                                // 1369\n    return _.isFunction(value) ? value.call(object) : value;                                                         // 1370\n  };                                                                                                                 // 1371\n                                                                                                                     // 1372\n  // Generate a unique integer id (unique within the entire client session).                                         // 1373\n  // Useful for temporary DOM ids.                                                                                   // 1374\n  var idCounter = 0;                                                                                                 // 1375\n  _.uniqueId = function(prefix) {                                                                                    // 1376\n    var id = ++idCounter + '';                                                                                       // 1377\n    return prefix ? prefix + id : id;                                                                                // 1378\n  };                                                                                                                 // 1379\n                                                                                                                     // 1380\n  // By default, Underscore uses ERB-style template delimiters, change the                                           // 1381\n  // following template settings to use alternative delimiters.                                                      // 1382\n  _.templateSettings = {                                                                                             // 1383\n    evaluate    : /<%([\\s\\S]+?)%>/g,                                                                                 // 1384\n    interpolate : /<%=([\\s\\S]+?)%>/g,                                                                                // 1385\n    escape      : /<%-([\\s\\S]+?)%>/g                                                                                 // 1386\n  };                                                                                                                 // 1387\n                                                                                                                     // 1388\n  // When customizing `templateSettings`, if you don't want to define an                                             // 1389\n  // interpolation, evaluation or escaping regex, we need one that is                                                // 1390\n  // guaranteed not to match.                                                                                        // 1391\n  var noMatch = /(.)^/;                                                                                              // 1392\n                                                                                                                     // 1393\n  // Certain characters need to be escaped so that they can be put into a                                            // 1394\n  // string literal.                                                                                                 // 1395\n  var escapes = {                                                                                                    // 1396\n    \"'\":      \"'\",                                                                                                   // 1397\n    '\\\\':     '\\\\',                                                                                                  // 1398\n    '\\r':     'r',                                                                                                   // 1399\n    '\\n':     'n',                                                                                                   // 1400\n    '\\u2028': 'u2028',                                                                                               // 1401\n    '\\u2029': 'u2029'                                                                                                // 1402\n  };                                                                                                                 // 1403\n                                                                                                                     // 1404\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;                                                                         // 1405\n                                                                                                                     // 1406\n  var escapeChar = function(match) {                                                                                 // 1407\n    return '\\\\' + escapes[match];                                                                                    // 1408\n  };                                                                                                                 // 1409\n                                                                                                                     // 1410\n  // JavaScript micro-templating, similar to John Resig's implementation.                                            // 1411\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,                                       // 1412\n  // and correctly escapes quotes within interpolated code.                                                          // 1413\n  // NB: `oldSettings` only exists for backwards compatibility.                                                      // 1414\n  _.template = function(text, settings, oldSettings) {                                                               // 1415\n    if (!settings && oldSettings) settings = oldSettings;                                                            // 1416\n    settings = _.defaults({}, settings, _.templateSettings);                                                         // 1417\n                                                                                                                     // 1418\n    // Combine delimiters into one regular expression via alternation.                                               // 1419\n    var matcher = RegExp([                                                                                           // 1420\n      (settings.escape || noMatch).source,                                                                           // 1421\n      (settings.interpolate || noMatch).source,                                                                      // 1422\n      (settings.evaluate || noMatch).source                                                                          // 1423\n    ].join('|') + '|$', 'g');                                                                                        // 1424\n                                                                                                                     // 1425\n    // Compile the template source, escaping string literals appropriately.                                          // 1426\n    var index = 0;                                                                                                   // 1427\n    var source = \"__p+='\";                                                                                           // 1428\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {                                   // 1429\n      source += text.slice(index, offset).replace(escaper, escapeChar);                                              // 1430\n      index = offset + match.length;                                                                                 // 1431\n                                                                                                                     // 1432\n      if (escape) {                                                                                                  // 1433\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";                                         // 1434\n      } else if (interpolate) {                                                                                      // 1435\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";                                              // 1436\n      } else if (evaluate) {                                                                                         // 1437\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";                                                                    // 1438\n      }                                                                                                              // 1439\n                                                                                                                     // 1440\n      // Adobe VMs need the match returned to produce the correct offest.                                            // 1441\n      return match;                                                                                                  // 1442\n    });                                                                                                              // 1443\n    source += \"';\\n\";                                                                                                // 1444\n                                                                                                                     // 1445\n    // If a variable is not specified, place data values in local scope.                                             // 1446\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';                                            // 1447\n                                                                                                                     // 1448\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +                                                            // 1449\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +                                                          // 1450\n      source + 'return __p;\\n';                                                                                      // 1451\n                                                                                                                     // 1452\n    try {                                                                                                            // 1453\n      var render = new Function(settings.variable || 'obj', '_', source);                                            // 1454\n    } catch (e) {                                                                                                    // 1455\n      e.source = source;                                                                                             // 1456\n      throw e;                                                                                                       // 1457\n    }                                                                                                                // 1458\n                                                                                                                     // 1459\n    var template = function(data) {                                                                                  // 1460\n      return render.call(this, data, _);                                                                             // 1461\n    };                                                                                                               // 1462\n                                                                                                                     // 1463\n    // Provide the compiled source as a convenience for precompilation.                                              // 1464\n    var argument = settings.variable || 'obj';                                                                       // 1465\n    template.source = 'function(' + argument + '){\\n' + source + '}';                                                // 1466\n                                                                                                                     // 1467\n    return template;                                                                                                 // 1468\n  };                                                                                                                 // 1469\n                                                                                                                     // 1470\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.                                             // 1471\n  _.chain = function(obj) {                                                                                          // 1472\n    var instance = _(obj);                                                                                           // 1473\n    instance._chain = true;                                                                                          // 1474\n    return instance;                                                                                                 // 1475\n  };                                                                                                                 // 1476\n                                                                                                                     // 1477\n  // OOP                                                                                                             // 1478\n  // ---------------                                                                                                 // 1479\n  // If Underscore is called as a function, it returns a wrapped object that                                         // 1480\n  // can be used OO-style. This wrapper holds altered versions of all the                                            // 1481\n  // underscore functions. Wrapped objects may be chained.                                                           // 1482\n                                                                                                                     // 1483\n  // Helper function to continue chaining intermediate results.                                                      // 1484\n  var result = function(instance, obj) {                                                                             // 1485\n    return instance._chain ? _(obj).chain() : obj;                                                                   // 1486\n  };                                                                                                                 // 1487\n                                                                                                                     // 1488\n  // Add your own custom functions to the Underscore object.                                                         // 1489\n  _.mixin = function(obj) {                                                                                          // 1490\n    _.each(_.functions(obj), function(name) {                                                                        // 1491\n      var func = _[name] = obj[name];                                                                                // 1492\n      _.prototype[name] = function() {                                                                               // 1493\n        var args = [this._wrapped];                                                                                  // 1494\n        push.apply(args, arguments);                                                                                 // 1495\n        return result(this, func.apply(_, args));                                                                    // 1496\n      };                                                                                                             // 1497\n    });                                                                                                              // 1498\n  };                                                                                                                 // 1499\n                                                                                                                     // 1500\n  // Add all of the Underscore functions to the wrapper object.                                                      // 1501\n  _.mixin(_);                                                                                                        // 1502\n                                                                                                                     // 1503\n  // Add all mutator Array functions to the wrapper.                                                                 // 1504\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {                          // 1505\n    var method = ArrayProto[name];                                                                                   // 1506\n    _.prototype[name] = function() {                                                                                 // 1507\n      var obj = this._wrapped;                                                                                       // 1508\n      method.apply(obj, arguments);                                                                                  // 1509\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];                                // 1510\n      return result(this, obj);                                                                                      // 1511\n    };                                                                                                               // 1512\n  });                                                                                                                // 1513\n                                                                                                                     // 1514\n  // Add all accessor Array functions to the wrapper.                                                                // 1515\n  _.each(['concat', 'join', 'slice'], function(name) {                                                               // 1516\n    var method = ArrayProto[name];                                                                                   // 1517\n    _.prototype[name] = function() {                                                                                 // 1518\n      return result(this, method.apply(this._wrapped, arguments));                                                   // 1519\n    };                                                                                                               // 1520\n  });                                                                                                                // 1521\n                                                                                                                     // 1522\n  // Extracts the result from a wrapped and chained object.                                                          // 1523\n  _.prototype.value = function() {                                                                                   // 1524\n    return this._wrapped;                                                                                            // 1525\n  };                                                                                                                 // 1526\n                                                                                                                     // 1527\n  // Provide unwrapping proxy for some methods used in engine operations                                             // 1528\n  // such as arithmetic and JSON stringification.                                                                    // 1529\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;                                                      // 1530\n                                                                                                                     // 1531\n  _.prototype.toString = function() {                                                                                // 1532\n    return '' + this._wrapped;                                                                                       // 1533\n  };                                                                                                                 // 1534\n                                                                                                                     // 1535\n  // AMD registration happens at the end for compatibility with AMD loaders                                          // 1536\n  // that may not enforce next-turn semantics on modules. Even though general                                        // 1537\n  // practice for AMD registration is to be anonymous, underscore registers                                          // 1538\n  // as a named module because, like jQuery, it is a base library that is                                            // 1539\n  // popular enough to be bundled in a third party lib, but not be part of                                           // 1540\n  // an AMD load request. Those cases could generate an error when an                                                // 1541\n  // anonymous define() is called outside of a loader request.                                                       // 1542\n  if (typeof define === 'function' && define.amd) {                                                                  // 1543\n    define('underscore', [], function() {                                                                            // 1544\n      return _;                                                                                                      // 1545\n    });                                                                                                              // 1546\n  }                                                                                                                  // 1547\n}.call(this));                                                                                                       // 1548\n                                                                                                                     // 1549\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"readable-stream\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/package.json                                                                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"readable-stream\";                                                                                    // 1\nexports.version = \"1.0.34\";                                                                                          // 2\nexports.main = \"readable.js\";                                                                                        // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"readable.js\":[\"stream\",\"./lib/_stream_readable.js\",\"./lib/_stream_writable.js\",\"./lib/_stream_duplex.js\",\"./lib/_stream_transform.js\",\"./lib/_stream_passthrough.js\",\"meteor-node-stubs/deps/stream\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/readable.js                                                                          //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify                 // 1\nexports = module.exports = require('./lib/_stream_readable.js');                                                     // 2\nexports.Stream = Stream;                                                                                             // 3\nexports.Readable = exports;                                                                                          // 4\nexports.Writable = require('./lib/_stream_writable.js');                                                             // 5\nexports.Duplex = require('./lib/_stream_duplex.js');                                                                 // 6\nexports.Transform = require('./lib/_stream_transform.js');                                                           // 7\nexports.PassThrough = require('./lib/_stream_passthrough.js');                                                       // 8\nif (!process.browser && process.env.READABLE_STREAM === 'disable') {                                                 // 9\n  module.exports = require('stream');                                                                                // 10\n}                                                                                                                    // 11\n                                                                                                                     // 12\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"lib\":{\"_stream_readable.js\":[\"isarray\",\"buffer\",\"events\",\"stream\",\"core-util-is\",\"inherits\",\"string_decoder/\",\"meteor-node-stubs/deps/buffer\",\"meteor-node-stubs/deps/events\",\"meteor-node-stubs/deps/stream\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/lib/_stream_readable.js                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\nmodule.exports = Readable;                                                                                           // 22\n                                                                                                                     // 23\n/*<replacement>*/                                                                                                    // 24\nvar isArray = require('isarray');                                                                                    // 25\n/*</replacement>*/                                                                                                   // 26\n                                                                                                                     // 27\n                                                                                                                     // 28\n/*<replacement>*/                                                                                                    // 29\nvar Buffer = require('buffer').Buffer;                                                                               // 30\n/*</replacement>*/                                                                                                   // 31\n                                                                                                                     // 32\nReadable.ReadableState = ReadableState;                                                                              // 33\n                                                                                                                     // 34\nvar EE = require('events').EventEmitter;                                                                             // 35\n                                                                                                                     // 36\n/*<replacement>*/                                                                                                    // 37\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {                                                  // 38\n  return emitter.listeners(type).length;                                                                             // 39\n};                                                                                                                   // 40\n/*</replacement>*/                                                                                                   // 41\n                                                                                                                     // 42\nvar Stream = require('stream');                                                                                      // 43\n                                                                                                                     // 44\n/*<replacement>*/                                                                                                    // 45\nvar util = require('core-util-is');                                                                                  // 46\nutil.inherits = require('inherits');                                                                                 // 47\n/*</replacement>*/                                                                                                   // 48\n                                                                                                                     // 49\nvar StringDecoder;                                                                                                   // 50\n                                                                                                                     // 51\nutil.inherits(Readable, Stream);                                                                                     // 52\n                                                                                                                     // 53\nfunction ReadableState(options, stream) {                                                                            // 54\n  options = options || {};                                                                                           // 55\n                                                                                                                     // 56\n  // the point at which it stops calling _read() to fill the buffer                                                  // 57\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"                                            // 58\n  var hwm = options.highWaterMark;                                                                                   // 59\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;                                                         // 60\n                                                                                                                     // 61\n  // cast to ints.                                                                                                   // 62\n  this.highWaterMark = ~~this.highWaterMark;                                                                         // 63\n                                                                                                                     // 64\n  this.buffer = [];                                                                                                  // 65\n  this.length = 0;                                                                                                   // 66\n  this.pipes = null;                                                                                                 // 67\n  this.pipesCount = 0;                                                                                               // 68\n  this.flowing = false;                                                                                              // 69\n  this.ended = false;                                                                                                // 70\n  this.endEmitted = false;                                                                                           // 71\n  this.reading = false;                                                                                              // 72\n                                                                                                                     // 73\n  // In streams that never have any data, and do push(null) right away,                                              // 74\n  // the consumer can miss the 'end' event if they do some I/O before                                                // 75\n  // consuming the stream.  So, we don't emit('end') until some reading                                              // 76\n  // happens.                                                                                                        // 77\n  this.calledRead = false;                                                                                           // 78\n                                                                                                                     // 79\n  // a flag to be able to tell if the onwrite cb is called immediately,                                              // 80\n  // or on a later tick.  We set this to true at first, becuase any                                                  // 81\n  // actions that shouldn't happen until \"later\" should generally also                                               // 82\n  // not happen before the first write call.                                                                         // 83\n  this.sync = true;                                                                                                  // 84\n                                                                                                                     // 85\n  // whenever we return null, then we set a flag to say                                                              // 86\n  // that we're awaiting a 'readable' event emission.                                                                // 87\n  this.needReadable = false;                                                                                         // 88\n  this.emittedReadable = false;                                                                                      // 89\n  this.readableListening = false;                                                                                    // 90\n                                                                                                                     // 91\n                                                                                                                     // 92\n  // object stream flag. Used to make read(n) ignore n and to                                                        // 93\n  // make all the buffer merging and length checks go away                                                           // 94\n  this.objectMode = !!options.objectMode;                                                                            // 95\n                                                                                                                     // 96\n  // Crypto is kind of old and crusty.  Historically, its default string                                             // 97\n  // encoding is 'binary' so we have to make this configurable.                                                      // 98\n  // Everything else in the universe uses 'utf8', though.                                                            // 99\n  this.defaultEncoding = options.defaultEncoding || 'utf8';                                                          // 100\n                                                                                                                     // 101\n  // when piping, we only care about 'readable' events that happen                                                   // 102\n  // after read()ing all the bytes and not getting any pushback.                                                     // 103\n  this.ranOut = false;                                                                                               // 104\n                                                                                                                     // 105\n  // the number of writers that are awaiting a drain event in .pipe()s                                               // 106\n  this.awaitDrain = 0;                                                                                               // 107\n                                                                                                                     // 108\n  // if true, a maybeReadMore has been scheduled                                                                     // 109\n  this.readingMore = false;                                                                                          // 110\n                                                                                                                     // 111\n  this.decoder = null;                                                                                               // 112\n  this.encoding = null;                                                                                              // 113\n  if (options.encoding) {                                                                                            // 114\n    if (!StringDecoder)                                                                                              // 115\n      StringDecoder = require('string_decoder/').StringDecoder;                                                      // 116\n    this.decoder = new StringDecoder(options.encoding);                                                              // 117\n    this.encoding = options.encoding;                                                                                // 118\n  }                                                                                                                  // 119\n}                                                                                                                    // 120\n                                                                                                                     // 121\nfunction Readable(options) {                                                                                         // 122\n  if (!(this instanceof Readable))                                                                                   // 123\n    return new Readable(options);                                                                                    // 124\n                                                                                                                     // 125\n  this._readableState = new ReadableState(options, this);                                                            // 126\n                                                                                                                     // 127\n  // legacy                                                                                                          // 128\n  this.readable = true;                                                                                              // 129\n                                                                                                                     // 130\n  Stream.call(this);                                                                                                 // 131\n}                                                                                                                    // 132\n                                                                                                                     // 133\n// Manually shove something into the read() buffer.                                                                  // 134\n// This returns true if the highWaterMark has not been hit yet,                                                      // 135\n// similar to how Writable.write() returns true if you should                                                        // 136\n// write() some more.                                                                                                // 137\nReadable.prototype.push = function(chunk, encoding) {                                                                // 138\n  var state = this._readableState;                                                                                   // 139\n                                                                                                                     // 140\n  if (typeof chunk === 'string' && !state.objectMode) {                                                              // 141\n    encoding = encoding || state.defaultEncoding;                                                                    // 142\n    if (encoding !== state.encoding) {                                                                               // 143\n      chunk = new Buffer(chunk, encoding);                                                                           // 144\n      encoding = '';                                                                                                 // 145\n    }                                                                                                                // 146\n  }                                                                                                                  // 147\n                                                                                                                     // 148\n  return readableAddChunk(this, state, chunk, encoding, false);                                                      // 149\n};                                                                                                                   // 150\n                                                                                                                     // 151\n// Unshift should *always* be something directly out of read()                                                       // 152\nReadable.prototype.unshift = function(chunk) {                                                                       // 153\n  var state = this._readableState;                                                                                   // 154\n  return readableAddChunk(this, state, chunk, '', true);                                                             // 155\n};                                                                                                                   // 156\n                                                                                                                     // 157\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {                                              // 158\n  var er = chunkInvalid(state, chunk);                                                                               // 159\n  if (er) {                                                                                                          // 160\n    stream.emit('error', er);                                                                                        // 161\n  } else if (chunk === null || chunk === undefined) {                                                                // 162\n    state.reading = false;                                                                                           // 163\n    if (!state.ended)                                                                                                // 164\n      onEofChunk(stream, state);                                                                                     // 165\n  } else if (state.objectMode || chunk && chunk.length > 0) {                                                        // 166\n    if (state.ended && !addToFront) {                                                                                // 167\n      var e = new Error('stream.push() after EOF');                                                                  // 168\n      stream.emit('error', e);                                                                                       // 169\n    } else if (state.endEmitted && addToFront) {                                                                     // 170\n      var e = new Error('stream.unshift() after end event');                                                         // 171\n      stream.emit('error', e);                                                                                       // 172\n    } else {                                                                                                         // 173\n      if (state.decoder && !addToFront && !encoding)                                                                 // 174\n        chunk = state.decoder.write(chunk);                                                                          // 175\n                                                                                                                     // 176\n      // update the buffer info.                                                                                     // 177\n      state.length += state.objectMode ? 1 : chunk.length;                                                           // 178\n      if (addToFront) {                                                                                              // 179\n        state.buffer.unshift(chunk);                                                                                 // 180\n      } else {                                                                                                       // 181\n        state.reading = false;                                                                                       // 182\n        state.buffer.push(chunk);                                                                                    // 183\n      }                                                                                                              // 184\n                                                                                                                     // 185\n      if (state.needReadable)                                                                                        // 186\n        emitReadable(stream);                                                                                        // 187\n                                                                                                                     // 188\n      maybeReadMore(stream, state);                                                                                  // 189\n    }                                                                                                                // 190\n  } else if (!addToFront) {                                                                                          // 191\n    state.reading = false;                                                                                           // 192\n  }                                                                                                                  // 193\n                                                                                                                     // 194\n  return needMoreData(state);                                                                                        // 195\n}                                                                                                                    // 196\n                                                                                                                     // 197\n                                                                                                                     // 198\n                                                                                                                     // 199\n// if it's past the high water mark, we can push in some more.                                                       // 200\n// Also, if we have no data yet, we can stand some                                                                   // 201\n// more bytes.  This is to work around cases where hwm=0,                                                            // 202\n// such as the repl.  Also, if the push() triggered a                                                                // 203\n// readable event, and the user called read(largeNumber) such that                                                   // 204\n// needReadable was set, then we ought to push more, so that another                                                 // 205\n// 'readable' event will be triggered.                                                                               // 206\nfunction needMoreData(state) {                                                                                       // 207\n  return !state.ended &&                                                                                             // 208\n         (state.needReadable ||                                                                                      // 209\n          state.length < state.highWaterMark ||                                                                      // 210\n          state.length === 0);                                                                                       // 211\n}                                                                                                                    // 212\n                                                                                                                     // 213\n// backwards compatibility.                                                                                          // 214\nReadable.prototype.setEncoding = function(enc) {                                                                     // 215\n  if (!StringDecoder)                                                                                                // 216\n    StringDecoder = require('string_decoder/').StringDecoder;                                                        // 217\n  this._readableState.decoder = new StringDecoder(enc);                                                              // 218\n  this._readableState.encoding = enc;                                                                                // 219\n};                                                                                                                   // 220\n                                                                                                                     // 221\n// Don't raise the hwm > 128MB                                                                                       // 222\nvar MAX_HWM = 0x800000;                                                                                              // 223\nfunction roundUpToNextPowerOf2(n) {                                                                                  // 224\n  if (n >= MAX_HWM) {                                                                                                // 225\n    n = MAX_HWM;                                                                                                     // 226\n  } else {                                                                                                           // 227\n    // Get the next highest power of 2                                                                               // 228\n    n--;                                                                                                             // 229\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;                                                                    // 230\n    n++;                                                                                                             // 231\n  }                                                                                                                  // 232\n  return n;                                                                                                          // 233\n}                                                                                                                    // 234\n                                                                                                                     // 235\nfunction howMuchToRead(n, state) {                                                                                   // 236\n  if (state.length === 0 && state.ended)                                                                             // 237\n    return 0;                                                                                                        // 238\n                                                                                                                     // 239\n  if (state.objectMode)                                                                                              // 240\n    return n === 0 ? 0 : 1;                                                                                          // 241\n                                                                                                                     // 242\n  if (n === null || isNaN(n)) {                                                                                      // 243\n    // only flow one buffer at a time                                                                                // 244\n    if (state.flowing && state.buffer.length)                                                                        // 245\n      return state.buffer[0].length;                                                                                 // 246\n    else                                                                                                             // 247\n      return state.length;                                                                                           // 248\n  }                                                                                                                  // 249\n                                                                                                                     // 250\n  if (n <= 0)                                                                                                        // 251\n    return 0;                                                                                                        // 252\n                                                                                                                     // 253\n  // If we're asking for more than the target buffer level,                                                          // 254\n  // then raise the water mark.  Bump up to the next highest                                                         // 255\n  // power of 2, to prevent increasing it excessively in tiny                                                        // 256\n  // amounts.                                                                                                        // 257\n  if (n > state.highWaterMark)                                                                                       // 258\n    state.highWaterMark = roundUpToNextPowerOf2(n);                                                                  // 259\n                                                                                                                     // 260\n  // don't have that much.  return null, unless we've ended.                                                         // 261\n  if (n > state.length) {                                                                                            // 262\n    if (!state.ended) {                                                                                              // 263\n      state.needReadable = true;                                                                                     // 264\n      return 0;                                                                                                      // 265\n    } else                                                                                                           // 266\n      return state.length;                                                                                           // 267\n  }                                                                                                                  // 268\n                                                                                                                     // 269\n  return n;                                                                                                          // 270\n}                                                                                                                    // 271\n                                                                                                                     // 272\n// you can override either this method, or the async _read(n) below.                                                 // 273\nReadable.prototype.read = function(n) {                                                                              // 274\n  var state = this._readableState;                                                                                   // 275\n  state.calledRead = true;                                                                                           // 276\n  var nOrig = n;                                                                                                     // 277\n  var ret;                                                                                                           // 278\n                                                                                                                     // 279\n  if (typeof n !== 'number' || n > 0)                                                                                // 280\n    state.emittedReadable = false;                                                                                   // 281\n                                                                                                                     // 282\n  // if we're doing read(0) to trigger a readable event, but we                                                      // 283\n  // already have a bunch of data in the buffer, then just trigger                                                   // 284\n  // the 'readable' event and move on.                                                                               // 285\n  if (n === 0 &&                                                                                                     // 286\n      state.needReadable &&                                                                                          // 287\n      (state.length >= state.highWaterMark || state.ended)) {                                                        // 288\n    emitReadable(this);                                                                                              // 289\n    return null;                                                                                                     // 290\n  }                                                                                                                  // 291\n                                                                                                                     // 292\n  n = howMuchToRead(n, state);                                                                                       // 293\n                                                                                                                     // 294\n  // if we've ended, and we're now clear, then finish it up.                                                         // 295\n  if (n === 0 && state.ended) {                                                                                      // 296\n    ret = null;                                                                                                      // 297\n                                                                                                                     // 298\n    // In cases where the decoder did not receive enough data                                                        // 299\n    // to produce a full chunk, then immediately received an                                                         // 300\n    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].                                                  // 301\n    // howMuchToRead will see this and coerce the amount to                                                          // 302\n    // read to zero (because it's looking at the length of the                                                       // 303\n    // first <Buffer > in state.buffer), and we'll end up here.                                                      // 304\n    //                                                                                                               // 305\n    // This can only happen via state.decoder -- no other venue                                                      // 306\n    // exists for pushing a zero-length chunk into state.buffer                                                      // 307\n    // and triggering this behavior. In this case, we return our                                                     // 308\n    // remaining data and end the stream, if appropriate.                                                            // 309\n    if (state.length > 0 && state.decoder) {                                                                         // 310\n      ret = fromList(n, state);                                                                                      // 311\n      state.length -= ret.length;                                                                                    // 312\n    }                                                                                                                // 313\n                                                                                                                     // 314\n    if (state.length === 0)                                                                                          // 315\n      endReadable(this);                                                                                             // 316\n                                                                                                                     // 317\n    return ret;                                                                                                      // 318\n  }                                                                                                                  // 319\n                                                                                                                     // 320\n  // All the actual chunk generation logic needs to be                                                               // 321\n  // *below* the call to _read.  The reason is that in certain                                                       // 322\n  // synthetic stream cases, such as passthrough streams, _read                                                      // 323\n  // may be a completely synchronous operation which may change                                                      // 324\n  // the state of the read buffer, providing enough data when                                                        // 325\n  // before there was *not* enough.                                                                                  // 326\n  //                                                                                                                 // 327\n  // So, the steps are:                                                                                              // 328\n  // 1. Figure out what the state of things will be after we do                                                      // 329\n  // a read from the buffer.                                                                                         // 330\n  //                                                                                                                 // 331\n  // 2. If that resulting state will trigger a _read, then call _read.                                               // 332\n  // Note that this may be asynchronous, or synchronous.  Yes, it is                                                 // 333\n  // deeply ugly to write APIs this way, but that still doesn't mean                                                 // 334\n  // that the Readable class should behave improperly, as streams are                                                // 335\n  // designed to be sync/async agnostic.                                                                             // 336\n  // Take note if the _read call is sync or async (ie, if the read call                                              // 337\n  // has returned yet), so that we know whether or not it's safe to emit                                             // 338\n  // 'readable' etc.                                                                                                 // 339\n  //                                                                                                                 // 340\n  // 3. Actually pull the requested chunks out of the buffer and return.                                             // 341\n                                                                                                                     // 342\n  // if we need a readable event, then we need to do some reading.                                                   // 343\n  var doRead = state.needReadable;                                                                                   // 344\n                                                                                                                     // 345\n  // if we currently have less than the highWaterMark, then also read some                                           // 346\n  if (state.length - n <= state.highWaterMark)                                                                       // 347\n    doRead = true;                                                                                                   // 348\n                                                                                                                     // 349\n  // however, if we've ended, then there's no point, and if we're already                                            // 350\n  // reading, then it's unnecessary.                                                                                 // 351\n  if (state.ended || state.reading)                                                                                  // 352\n    doRead = false;                                                                                                  // 353\n                                                                                                                     // 354\n  if (doRead) {                                                                                                      // 355\n    state.reading = true;                                                                                            // 356\n    state.sync = true;                                                                                               // 357\n    // if the length is currently zero, then we *need* a readable event.                                             // 358\n    if (state.length === 0)                                                                                          // 359\n      state.needReadable = true;                                                                                     // 360\n    // call internal read method                                                                                     // 361\n    this._read(state.highWaterMark);                                                                                 // 362\n    state.sync = false;                                                                                              // 363\n  }                                                                                                                  // 364\n                                                                                                                     // 365\n  // If _read called its callback synchronously, then `reading`                                                      // 366\n  // will be false, and we need to re-evaluate how much data we                                                      // 367\n  // can return to the user.                                                                                         // 368\n  if (doRead && !state.reading)                                                                                      // 369\n    n = howMuchToRead(nOrig, state);                                                                                 // 370\n                                                                                                                     // 371\n  if (n > 0)                                                                                                         // 372\n    ret = fromList(n, state);                                                                                        // 373\n  else                                                                                                               // 374\n    ret = null;                                                                                                      // 375\n                                                                                                                     // 376\n  if (ret === null) {                                                                                                // 377\n    state.needReadable = true;                                                                                       // 378\n    n = 0;                                                                                                           // 379\n  }                                                                                                                  // 380\n                                                                                                                     // 381\n  state.length -= n;                                                                                                 // 382\n                                                                                                                     // 383\n  // If we have nothing in the buffer, then we want to know                                                          // 384\n  // as soon as we *do* get something into the buffer.                                                               // 385\n  if (state.length === 0 && !state.ended)                                                                            // 386\n    state.needReadable = true;                                                                                       // 387\n                                                                                                                     // 388\n  // If we happened to read() exactly the remaining amount in the                                                    // 389\n  // buffer, and the EOF has been seen at this point, then make sure                                                 // 390\n  // that we emit 'end' on the very next tick.                                                                       // 391\n  if (state.ended && !state.endEmitted && state.length === 0)                                                        // 392\n    endReadable(this);                                                                                               // 393\n                                                                                                                     // 394\n  return ret;                                                                                                        // 395\n};                                                                                                                   // 396\n                                                                                                                     // 397\nfunction chunkInvalid(state, chunk) {                                                                                // 398\n  var er = null;                                                                                                     // 399\n  if (!Buffer.isBuffer(chunk) &&                                                                                     // 400\n      'string' !== typeof chunk &&                                                                                   // 401\n      chunk !== null &&                                                                                              // 402\n      chunk !== undefined &&                                                                                         // 403\n      !state.objectMode) {                                                                                           // 404\n    er = new TypeError('Invalid non-string/buffer chunk');                                                           // 405\n  }                                                                                                                  // 406\n  return er;                                                                                                         // 407\n}                                                                                                                    // 408\n                                                                                                                     // 409\n                                                                                                                     // 410\nfunction onEofChunk(stream, state) {                                                                                 // 411\n  if (state.decoder && !state.ended) {                                                                               // 412\n    var chunk = state.decoder.end();                                                                                 // 413\n    if (chunk && chunk.length) {                                                                                     // 414\n      state.buffer.push(chunk);                                                                                      // 415\n      state.length += state.objectMode ? 1 : chunk.length;                                                           // 416\n    }                                                                                                                // 417\n  }                                                                                                                  // 418\n  state.ended = true;                                                                                                // 419\n                                                                                                                     // 420\n  // if we've ended and we have some data left, then emit                                                            // 421\n  // 'readable' now to make sure it gets picked up.                                                                  // 422\n  if (state.length > 0)                                                                                              // 423\n    emitReadable(stream);                                                                                            // 424\n  else                                                                                                               // 425\n    endReadable(stream);                                                                                             // 426\n}                                                                                                                    // 427\n                                                                                                                     // 428\n// Don't emit readable right away in sync mode, because this can trigger                                             // 429\n// another read() call => stack overflow.  This way, it might trigger                                                // 430\n// a nextTick recursion warning, but that's not so bad.                                                              // 431\nfunction emitReadable(stream) {                                                                                      // 432\n  var state = stream._readableState;                                                                                 // 433\n  state.needReadable = false;                                                                                        // 434\n  if (state.emittedReadable)                                                                                         // 435\n    return;                                                                                                          // 436\n                                                                                                                     // 437\n  state.emittedReadable = true;                                                                                      // 438\n  if (state.sync)                                                                                                    // 439\n    process.nextTick(function() {                                                                                    // 440\n      emitReadable_(stream);                                                                                         // 441\n    });                                                                                                              // 442\n  else                                                                                                               // 443\n    emitReadable_(stream);                                                                                           // 444\n}                                                                                                                    // 445\n                                                                                                                     // 446\nfunction emitReadable_(stream) {                                                                                     // 447\n  stream.emit('readable');                                                                                           // 448\n}                                                                                                                    // 449\n                                                                                                                     // 450\n                                                                                                                     // 451\n// at this point, the user has presumably seen the 'readable' event,                                                 // 452\n// and called read() to consume some data.  that may have triggered                                                  // 453\n// in turn another _read(n) call, in which case reading = true if                                                    // 454\n// it's in progress.                                                                                                 // 455\n// However, if we're not ended, or reading, and the length < hwm,                                                    // 456\n// then go ahead and try to read some more preemptively.                                                             // 457\nfunction maybeReadMore(stream, state) {                                                                              // 458\n  if (!state.readingMore) {                                                                                          // 459\n    state.readingMore = true;                                                                                        // 460\n    process.nextTick(function() {                                                                                    // 461\n      maybeReadMore_(stream, state);                                                                                 // 462\n    });                                                                                                              // 463\n  }                                                                                                                  // 464\n}                                                                                                                    // 465\n                                                                                                                     // 466\nfunction maybeReadMore_(stream, state) {                                                                             // 467\n  var len = state.length;                                                                                            // 468\n  while (!state.reading && !state.flowing && !state.ended &&                                                         // 469\n         state.length < state.highWaterMark) {                                                                       // 470\n    stream.read(0);                                                                                                  // 471\n    if (len === state.length)                                                                                        // 472\n      // didn't get any data, stop spinning.                                                                         // 473\n      break;                                                                                                         // 474\n    else                                                                                                             // 475\n      len = state.length;                                                                                            // 476\n  }                                                                                                                  // 477\n  state.readingMore = false;                                                                                         // 478\n}                                                                                                                    // 479\n                                                                                                                     // 480\n// abstract method.  to be overridden in specific implementation classes.                                            // 481\n// call cb(er, data) where data is <= n in length.                                                                   // 482\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat                                                // 483\n// arbitrary, and perhaps not very meaningful.                                                                       // 484\nReadable.prototype._read = function(n) {                                                                             // 485\n  this.emit('error', new Error('not implemented'));                                                                  // 486\n};                                                                                                                   // 487\n                                                                                                                     // 488\nReadable.prototype.pipe = function(dest, pipeOpts) {                                                                 // 489\n  var src = this;                                                                                                    // 490\n  var state = this._readableState;                                                                                   // 491\n                                                                                                                     // 492\n  switch (state.pipesCount) {                                                                                        // 493\n    case 0:                                                                                                          // 494\n      state.pipes = dest;                                                                                            // 495\n      break;                                                                                                         // 496\n    case 1:                                                                                                          // 497\n      state.pipes = [state.pipes, dest];                                                                             // 498\n      break;                                                                                                         // 499\n    default:                                                                                                         // 500\n      state.pipes.push(dest);                                                                                        // 501\n      break;                                                                                                         // 502\n  }                                                                                                                  // 503\n  state.pipesCount += 1;                                                                                             // 504\n                                                                                                                     // 505\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&                                                               // 506\n              dest !== process.stdout &&                                                                             // 507\n              dest !== process.stderr;                                                                               // 508\n                                                                                                                     // 509\n  var endFn = doEnd ? onend : cleanup;                                                                               // 510\n  if (state.endEmitted)                                                                                              // 511\n    process.nextTick(endFn);                                                                                         // 512\n  else                                                                                                               // 513\n    src.once('end', endFn);                                                                                          // 514\n                                                                                                                     // 515\n  dest.on('unpipe', onunpipe);                                                                                       // 516\n  function onunpipe(readable) {                                                                                      // 517\n    if (readable !== src) return;                                                                                    // 518\n    cleanup();                                                                                                       // 519\n  }                                                                                                                  // 520\n                                                                                                                     // 521\n  function onend() {                                                                                                 // 522\n    dest.end();                                                                                                      // 523\n  }                                                                                                                  // 524\n                                                                                                                     // 525\n  // when the dest drains, it reduces the awaitDrain counter                                                         // 526\n  // on the source.  This would be more elegant with a .once()                                                       // 527\n  // handler in flow(), but adding and removing repeatedly is                                                        // 528\n  // too slow.                                                                                                       // 529\n  var ondrain = pipeOnDrain(src);                                                                                    // 530\n  dest.on('drain', ondrain);                                                                                         // 531\n                                                                                                                     // 532\n  function cleanup() {                                                                                               // 533\n    // cleanup event handlers once the pipe is broken                                                                // 534\n    dest.removeListener('close', onclose);                                                                           // 535\n    dest.removeListener('finish', onfinish);                                                                         // 536\n    dest.removeListener('drain', ondrain);                                                                           // 537\n    dest.removeListener('error', onerror);                                                                           // 538\n    dest.removeListener('unpipe', onunpipe);                                                                         // 539\n    src.removeListener('end', onend);                                                                                // 540\n    src.removeListener('end', cleanup);                                                                              // 541\n                                                                                                                     // 542\n    // if the reader is waiting for a drain event from this                                                          // 543\n    // specific writer, then it would cause it to never start                                                        // 544\n    // flowing again.                                                                                                // 545\n    // So, if this is awaiting a drain, then we just call it now.                                                    // 546\n    // If we don't know, then assume that we are waiting for one.                                                    // 547\n    if (!dest._writableState || dest._writableState.needDrain)                                                       // 548\n      ondrain();                                                                                                     // 549\n  }                                                                                                                  // 550\n                                                                                                                     // 551\n  // if the dest has an error, then stop piping into it.                                                             // 552\n  // however, don't suppress the throwing behavior for this.                                                         // 553\n  function onerror(er) {                                                                                             // 554\n    unpipe();                                                                                                        // 555\n    dest.removeListener('error', onerror);                                                                           // 556\n    if (EE.listenerCount(dest, 'error') === 0)                                                                       // 557\n      dest.emit('error', er);                                                                                        // 558\n  }                                                                                                                  // 559\n  // This is a brutally ugly hack to make sure that our error handler                                                // 560\n  // is attached before any userland ones.  NEVER DO THIS.                                                           // 561\n  if (!dest._events || !dest._events.error)                                                                          // 562\n    dest.on('error', onerror);                                                                                       // 563\n  else if (isArray(dest._events.error))                                                                              // 564\n    dest._events.error.unshift(onerror);                                                                             // 565\n  else                                                                                                               // 566\n    dest._events.error = [onerror, dest._events.error];                                                              // 567\n                                                                                                                     // 568\n                                                                                                                     // 569\n                                                                                                                     // 570\n  // Both close and finish should trigger unpipe, but only once.                                                     // 571\n  function onclose() {                                                                                               // 572\n    dest.removeListener('finish', onfinish);                                                                         // 573\n    unpipe();                                                                                                        // 574\n  }                                                                                                                  // 575\n  dest.once('close', onclose);                                                                                       // 576\n  function onfinish() {                                                                                              // 577\n    dest.removeListener('close', onclose);                                                                           // 578\n    unpipe();                                                                                                        // 579\n  }                                                                                                                  // 580\n  dest.once('finish', onfinish);                                                                                     // 581\n                                                                                                                     // 582\n  function unpipe() {                                                                                                // 583\n    src.unpipe(dest);                                                                                                // 584\n  }                                                                                                                  // 585\n                                                                                                                     // 586\n  // tell the dest that it's being piped to                                                                          // 587\n  dest.emit('pipe', src);                                                                                            // 588\n                                                                                                                     // 589\n  // start the flow if it hasn't been started already.                                                               // 590\n  if (!state.flowing) {                                                                                              // 591\n    // the handler that waits for readable events after all                                                          // 592\n    // the data gets sucked out in flow.                                                                             // 593\n    // This would be easier to follow with a .once() handler                                                         // 594\n    // in flow(), but that is too slow.                                                                              // 595\n    this.on('readable', pipeOnReadable);                                                                             // 596\n                                                                                                                     // 597\n    state.flowing = true;                                                                                            // 598\n    process.nextTick(function() {                                                                                    // 599\n      flow(src);                                                                                                     // 600\n    });                                                                                                              // 601\n  }                                                                                                                  // 602\n                                                                                                                     // 603\n  return dest;                                                                                                       // 604\n};                                                                                                                   // 605\n                                                                                                                     // 606\nfunction pipeOnDrain(src) {                                                                                          // 607\n  return function() {                                                                                                // 608\n    var dest = this;                                                                                                 // 609\n    var state = src._readableState;                                                                                  // 610\n    state.awaitDrain--;                                                                                              // 611\n    if (state.awaitDrain === 0)                                                                                      // 612\n      flow(src);                                                                                                     // 613\n  };                                                                                                                 // 614\n}                                                                                                                    // 615\n                                                                                                                     // 616\nfunction flow(src) {                                                                                                 // 617\n  var state = src._readableState;                                                                                    // 618\n  var chunk;                                                                                                         // 619\n  state.awaitDrain = 0;                                                                                              // 620\n                                                                                                                     // 621\n  function write(dest, i, list) {                                                                                    // 622\n    var written = dest.write(chunk);                                                                                 // 623\n    if (false === written) {                                                                                         // 624\n      state.awaitDrain++;                                                                                            // 625\n    }                                                                                                                // 626\n  }                                                                                                                  // 627\n                                                                                                                     // 628\n  while (state.pipesCount && null !== (chunk = src.read())) {                                                        // 629\n                                                                                                                     // 630\n    if (state.pipesCount === 1)                                                                                      // 631\n      write(state.pipes, 0, null);                                                                                   // 632\n    else                                                                                                             // 633\n      forEach(state.pipes, write);                                                                                   // 634\n                                                                                                                     // 635\n    src.emit('data', chunk);                                                                                         // 636\n                                                                                                                     // 637\n    // if anyone needs a drain, then we have to wait for that.                                                       // 638\n    if (state.awaitDrain > 0)                                                                                        // 639\n      return;                                                                                                        // 640\n  }                                                                                                                  // 641\n                                                                                                                     // 642\n  // if every destination was unpiped, either before entering this                                                   // 643\n  // function, or in the while loop, then stop flowing.                                                              // 644\n  //                                                                                                                 // 645\n  // NB: This is a pretty rare edge case.                                                                            // 646\n  if (state.pipesCount === 0) {                                                                                      // 647\n    state.flowing = false;                                                                                           // 648\n                                                                                                                     // 649\n    // if there were data event listeners added, then switch to old mode.                                            // 650\n    if (EE.listenerCount(src, 'data') > 0)                                                                           // 651\n      emitDataEvents(src);                                                                                           // 652\n    return;                                                                                                          // 653\n  }                                                                                                                  // 654\n                                                                                                                     // 655\n  // at this point, no one needed a drain, so we just ran out of data                                                // 656\n  // on the next readable event, start it over again.                                                                // 657\n  state.ranOut = true;                                                                                               // 658\n}                                                                                                                    // 659\n                                                                                                                     // 660\nfunction pipeOnReadable() {                                                                                          // 661\n  if (this._readableState.ranOut) {                                                                                  // 662\n    this._readableState.ranOut = false;                                                                              // 663\n    flow(this);                                                                                                      // 664\n  }                                                                                                                  // 665\n}                                                                                                                    // 666\n                                                                                                                     // 667\n                                                                                                                     // 668\nReadable.prototype.unpipe = function(dest) {                                                                         // 669\n  var state = this._readableState;                                                                                   // 670\n                                                                                                                     // 671\n  // if we're not piping anywhere, then do nothing.                                                                  // 672\n  if (state.pipesCount === 0)                                                                                        // 673\n    return this;                                                                                                     // 674\n                                                                                                                     // 675\n  // just one destination.  most common case.                                                                        // 676\n  if (state.pipesCount === 1) {                                                                                      // 677\n    // passed in one, but it's not the right one.                                                                    // 678\n    if (dest && dest !== state.pipes)                                                                                // 679\n      return this;                                                                                                   // 680\n                                                                                                                     // 681\n    if (!dest)                                                                                                       // 682\n      dest = state.pipes;                                                                                            // 683\n                                                                                                                     // 684\n    // got a match.                                                                                                  // 685\n    state.pipes = null;                                                                                              // 686\n    state.pipesCount = 0;                                                                                            // 687\n    this.removeListener('readable', pipeOnReadable);                                                                 // 688\n    state.flowing = false;                                                                                           // 689\n    if (dest)                                                                                                        // 690\n      dest.emit('unpipe', this);                                                                                     // 691\n    return this;                                                                                                     // 692\n  }                                                                                                                  // 693\n                                                                                                                     // 694\n  // slow case. multiple pipe destinations.                                                                          // 695\n                                                                                                                     // 696\n  if (!dest) {                                                                                                       // 697\n    // remove all.                                                                                                   // 698\n    var dests = state.pipes;                                                                                         // 699\n    var len = state.pipesCount;                                                                                      // 700\n    state.pipes = null;                                                                                              // 701\n    state.pipesCount = 0;                                                                                            // 702\n    this.removeListener('readable', pipeOnReadable);                                                                 // 703\n    state.flowing = false;                                                                                           // 704\n                                                                                                                     // 705\n    for (var i = 0; i < len; i++)                                                                                    // 706\n      dests[i].emit('unpipe', this);                                                                                 // 707\n    return this;                                                                                                     // 708\n  }                                                                                                                  // 709\n                                                                                                                     // 710\n  // try to find the right one.                                                                                      // 711\n  var i = indexOf(state.pipes, dest);                                                                                // 712\n  if (i === -1)                                                                                                      // 713\n    return this;                                                                                                     // 714\n                                                                                                                     // 715\n  state.pipes.splice(i, 1);                                                                                          // 716\n  state.pipesCount -= 1;                                                                                             // 717\n  if (state.pipesCount === 1)                                                                                        // 718\n    state.pipes = state.pipes[0];                                                                                    // 719\n                                                                                                                     // 720\n  dest.emit('unpipe', this);                                                                                         // 721\n                                                                                                                     // 722\n  return this;                                                                                                       // 723\n};                                                                                                                   // 724\n                                                                                                                     // 725\n// set up data events if they are asked for                                                                          // 726\n// Ensure readable listeners eventually get something                                                                // 727\nReadable.prototype.on = function(ev, fn) {                                                                           // 728\n  var res = Stream.prototype.on.call(this, ev, fn);                                                                  // 729\n                                                                                                                     // 730\n  if (ev === 'data' && !this._readableState.flowing)                                                                 // 731\n    emitDataEvents(this);                                                                                            // 732\n                                                                                                                     // 733\n  if (ev === 'readable' && this.readable) {                                                                          // 734\n    var state = this._readableState;                                                                                 // 735\n    if (!state.readableListening) {                                                                                  // 736\n      state.readableListening = true;                                                                                // 737\n      state.emittedReadable = false;                                                                                 // 738\n      state.needReadable = true;                                                                                     // 739\n      if (!state.reading) {                                                                                          // 740\n        this.read(0);                                                                                                // 741\n      } else if (state.length) {                                                                                     // 742\n        emitReadable(this, state);                                                                                   // 743\n      }                                                                                                              // 744\n    }                                                                                                                // 745\n  }                                                                                                                  // 746\n                                                                                                                     // 747\n  return res;                                                                                                        // 748\n};                                                                                                                   // 749\nReadable.prototype.addListener = Readable.prototype.on;                                                              // 750\n                                                                                                                     // 751\n// pause() and resume() are remnants of the legacy readable stream API                                               // 752\n// If the user uses them, then switch into old mode.                                                                 // 753\nReadable.prototype.resume = function() {                                                                             // 754\n  emitDataEvents(this);                                                                                              // 755\n  this.read(0);                                                                                                      // 756\n  this.emit('resume');                                                                                               // 757\n};                                                                                                                   // 758\n                                                                                                                     // 759\nReadable.prototype.pause = function() {                                                                              // 760\n  emitDataEvents(this, true);                                                                                        // 761\n  this.emit('pause');                                                                                                // 762\n};                                                                                                                   // 763\n                                                                                                                     // 764\nfunction emitDataEvents(stream, startPaused) {                                                                       // 765\n  var state = stream._readableState;                                                                                 // 766\n                                                                                                                     // 767\n  if (state.flowing) {                                                                                               // 768\n    // https://github.com/isaacs/readable-stream/issues/16                                                           // 769\n    throw new Error('Cannot switch to old mode now.');                                                               // 770\n  }                                                                                                                  // 771\n                                                                                                                     // 772\n  var paused = startPaused || false;                                                                                 // 773\n  var readable = false;                                                                                              // 774\n                                                                                                                     // 775\n  // convert to an old-style stream.                                                                                 // 776\n  stream.readable = true;                                                                                            // 777\n  stream.pipe = Stream.prototype.pipe;                                                                               // 778\n  stream.on = stream.addListener = Stream.prototype.on;                                                              // 779\n                                                                                                                     // 780\n  stream.on('readable', function() {                                                                                 // 781\n    readable = true;                                                                                                 // 782\n                                                                                                                     // 783\n    var c;                                                                                                           // 784\n    while (!paused && (null !== (c = stream.read())))                                                                // 785\n      stream.emit('data', c);                                                                                        // 786\n                                                                                                                     // 787\n    if (c === null) {                                                                                                // 788\n      readable = false;                                                                                              // 789\n      stream._readableState.needReadable = true;                                                                     // 790\n    }                                                                                                                // 791\n  });                                                                                                                // 792\n                                                                                                                     // 793\n  stream.pause = function() {                                                                                        // 794\n    paused = true;                                                                                                   // 795\n    this.emit('pause');                                                                                              // 796\n  };                                                                                                                 // 797\n                                                                                                                     // 798\n  stream.resume = function() {                                                                                       // 799\n    paused = false;                                                                                                  // 800\n    if (readable)                                                                                                    // 801\n      process.nextTick(function() {                                                                                  // 802\n        stream.emit('readable');                                                                                     // 803\n      });                                                                                                            // 804\n    else                                                                                                             // 805\n      this.read(0);                                                                                                  // 806\n    this.emit('resume');                                                                                             // 807\n  };                                                                                                                 // 808\n                                                                                                                     // 809\n  // now make it start, just in case it hadn't already.                                                              // 810\n  stream.emit('readable');                                                                                           // 811\n}                                                                                                                    // 812\n                                                                                                                     // 813\n// wrap an old-style stream as the async data source.                                                                // 814\n// This is *not* part of the readable stream interface.                                                              // 815\n// It is an ugly unfortunate mess of history.                                                                        // 816\nReadable.prototype.wrap = function(stream) {                                                                         // 817\n  var state = this._readableState;                                                                                   // 818\n  var paused = false;                                                                                                // 819\n                                                                                                                     // 820\n  var self = this;                                                                                                   // 821\n  stream.on('end', function() {                                                                                      // 822\n    if (state.decoder && !state.ended) {                                                                             // 823\n      var chunk = state.decoder.end();                                                                               // 824\n      if (chunk && chunk.length)                                                                                     // 825\n        self.push(chunk);                                                                                            // 826\n    }                                                                                                                // 827\n                                                                                                                     // 828\n    self.push(null);                                                                                                 // 829\n  });                                                                                                                // 830\n                                                                                                                     // 831\n  stream.on('data', function(chunk) {                                                                                // 832\n    if (state.decoder)                                                                                               // 833\n      chunk = state.decoder.write(chunk);                                                                            // 834\n                                                                                                                     // 835\n    // don't skip over falsy values in objectMode                                                                    // 836\n    //if (state.objectMode && util.isNullOrUndefined(chunk))                                                         // 837\n    if (state.objectMode && (chunk === null || chunk === undefined))                                                 // 838\n      return;                                                                                                        // 839\n    else if (!state.objectMode && (!chunk || !chunk.length))                                                         // 840\n      return;                                                                                                        // 841\n                                                                                                                     // 842\n    var ret = self.push(chunk);                                                                                      // 843\n    if (!ret) {                                                                                                      // 844\n      paused = true;                                                                                                 // 845\n      stream.pause();                                                                                                // 846\n    }                                                                                                                // 847\n  });                                                                                                                // 848\n                                                                                                                     // 849\n  // proxy all the other methods.                                                                                    // 850\n  // important when wrapping filters and duplexes.                                                                   // 851\n  for (var i in stream) {                                                                                            // 852\n    if (typeof stream[i] === 'function' &&                                                                           // 853\n        typeof this[i] === 'undefined') {                                                                            // 854\n      this[i] = function(method) { return function() {                                                               // 855\n        return stream[method].apply(stream, arguments);                                                              // 856\n      }}(i);                                                                                                         // 857\n    }                                                                                                                // 858\n  }                                                                                                                  // 859\n                                                                                                                     // 860\n  // proxy certain important events.                                                                                 // 861\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];                                                     // 862\n  forEach(events, function(ev) {                                                                                     // 863\n    stream.on(ev, self.emit.bind(self, ev));                                                                         // 864\n  });                                                                                                                // 865\n                                                                                                                     // 866\n  // when we try to consume some more bytes, simply unpause the                                                      // 867\n  // underlying stream.                                                                                              // 868\n  self._read = function(n) {                                                                                         // 869\n    if (paused) {                                                                                                    // 870\n      paused = false;                                                                                                // 871\n      stream.resume();                                                                                               // 872\n    }                                                                                                                // 873\n  };                                                                                                                 // 874\n                                                                                                                     // 875\n  return self;                                                                                                       // 876\n};                                                                                                                   // 877\n                                                                                                                     // 878\n                                                                                                                     // 879\n                                                                                                                     // 880\n// exposed for testing purposes only.                                                                                // 881\nReadable._fromList = fromList;                                                                                       // 882\n                                                                                                                     // 883\n// Pluck off n bytes from an array of buffers.                                                                       // 884\n// Length is the combined lengths of all the buffers in the list.                                                    // 885\nfunction fromList(n, state) {                                                                                        // 886\n  var list = state.buffer;                                                                                           // 887\n  var length = state.length;                                                                                         // 888\n  var stringMode = !!state.decoder;                                                                                  // 889\n  var objectMode = !!state.objectMode;                                                                               // 890\n  var ret;                                                                                                           // 891\n                                                                                                                     // 892\n  // nothing in the list, definitely empty.                                                                          // 893\n  if (list.length === 0)                                                                                             // 894\n    return null;                                                                                                     // 895\n                                                                                                                     // 896\n  if (length === 0)                                                                                                  // 897\n    ret = null;                                                                                                      // 898\n  else if (objectMode)                                                                                               // 899\n    ret = list.shift();                                                                                              // 900\n  else if (!n || n >= length) {                                                                                      // 901\n    // read it all, truncate the array.                                                                              // 902\n    if (stringMode)                                                                                                  // 903\n      ret = list.join('');                                                                                           // 904\n    else                                                                                                             // 905\n      ret = Buffer.concat(list, length);                                                                             // 906\n    list.length = 0;                                                                                                 // 907\n  } else {                                                                                                           // 908\n    // read just some of it.                                                                                         // 909\n    if (n < list[0].length) {                                                                                        // 910\n      // just take a part of the first list item.                                                                    // 911\n      // slice is the same for buffers and strings.                                                                  // 912\n      var buf = list[0];                                                                                             // 913\n      ret = buf.slice(0, n);                                                                                         // 914\n      list[0] = buf.slice(n);                                                                                        // 915\n    } else if (n === list[0].length) {                                                                               // 916\n      // first list is a perfect match                                                                               // 917\n      ret = list.shift();                                                                                            // 918\n    } else {                                                                                                         // 919\n      // complex case.                                                                                               // 920\n      // we have enough to cover it, but it spans past the first buffer.                                             // 921\n      if (stringMode)                                                                                                // 922\n        ret = '';                                                                                                    // 923\n      else                                                                                                           // 924\n        ret = new Buffer(n);                                                                                         // 925\n                                                                                                                     // 926\n      var c = 0;                                                                                                     // 927\n      for (var i = 0, l = list.length; i < l && c < n; i++) {                                                        // 928\n        var buf = list[0];                                                                                           // 929\n        var cpy = Math.min(n - c, buf.length);                                                                       // 930\n                                                                                                                     // 931\n        if (stringMode)                                                                                              // 932\n          ret += buf.slice(0, cpy);                                                                                  // 933\n        else                                                                                                         // 934\n          buf.copy(ret, c, 0, cpy);                                                                                  // 935\n                                                                                                                     // 936\n        if (cpy < buf.length)                                                                                        // 937\n          list[0] = buf.slice(cpy);                                                                                  // 938\n        else                                                                                                         // 939\n          list.shift();                                                                                              // 940\n                                                                                                                     // 941\n        c += cpy;                                                                                                    // 942\n      }                                                                                                              // 943\n    }                                                                                                                // 944\n  }                                                                                                                  // 945\n                                                                                                                     // 946\n  return ret;                                                                                                        // 947\n}                                                                                                                    // 948\n                                                                                                                     // 949\nfunction endReadable(stream) {                                                                                       // 950\n  var state = stream._readableState;                                                                                 // 951\n                                                                                                                     // 952\n  // If we get here before consuming all the bytes, then that is a                                                   // 953\n  // bug in node.  Should never happen.                                                                              // 954\n  if (state.length > 0)                                                                                              // 955\n    throw new Error('endReadable called on non-empty stream');                                                       // 956\n                                                                                                                     // 957\n  if (!state.endEmitted && state.calledRead) {                                                                       // 958\n    state.ended = true;                                                                                              // 959\n    process.nextTick(function() {                                                                                    // 960\n      // Check that we didn't get one last unshift.                                                                  // 961\n      if (!state.endEmitted && state.length === 0) {                                                                 // 962\n        state.endEmitted = true;                                                                                     // 963\n        stream.readable = false;                                                                                     // 964\n        stream.emit('end');                                                                                          // 965\n      }                                                                                                              // 966\n    });                                                                                                              // 967\n  }                                                                                                                  // 968\n}                                                                                                                    // 969\n                                                                                                                     // 970\nfunction forEach (xs, f) {                                                                                           // 971\n  for (var i = 0, l = xs.length; i < l; i++) {                                                                       // 972\n    f(xs[i], i);                                                                                                     // 973\n  }                                                                                                                  // 974\n}                                                                                                                    // 975\n                                                                                                                     // 976\nfunction indexOf (xs, x) {                                                                                           // 977\n  for (var i = 0, l = xs.length; i < l; i++) {                                                                       // 978\n    if (xs[i] === x) return i;                                                                                       // 979\n  }                                                                                                                  // 980\n  return -1;                                                                                                         // 981\n}                                                                                                                    // 982\n                                                                                                                     // 983\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_writable.js\":[\"buffer\",\"core-util-is\",\"inherits\",\"stream\",\"./_stream_duplex\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/lib/_stream_writable.js                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n// A bit simpler than readable streams.                                                                              // 22\n// Implement an async ._write(chunk, cb), and it'll handle all                                                       // 23\n// the drain event emission and buffering.                                                                           // 24\n                                                                                                                     // 25\nmodule.exports = Writable;                                                                                           // 26\n                                                                                                                     // 27\n/*<replacement>*/                                                                                                    // 28\nvar Buffer = require('buffer').Buffer;                                                                               // 29\n/*</replacement>*/                                                                                                   // 30\n                                                                                                                     // 31\nWritable.WritableState = WritableState;                                                                              // 32\n                                                                                                                     // 33\n                                                                                                                     // 34\n/*<replacement>*/                                                                                                    // 35\nvar util = require('core-util-is');                                                                                  // 36\nutil.inherits = require('inherits');                                                                                 // 37\n/*</replacement>*/                                                                                                   // 38\n                                                                                                                     // 39\nvar Stream = require('stream');                                                                                      // 40\n                                                                                                                     // 41\nutil.inherits(Writable, Stream);                                                                                     // 42\n                                                                                                                     // 43\nfunction WriteReq(chunk, encoding, cb) {                                                                             // 44\n  this.chunk = chunk;                                                                                                // 45\n  this.encoding = encoding;                                                                                          // 46\n  this.callback = cb;                                                                                                // 47\n}                                                                                                                    // 48\n                                                                                                                     // 49\nfunction WritableState(options, stream) {                                                                            // 50\n  options = options || {};                                                                                           // 51\n                                                                                                                     // 52\n  // the point at which write() starts returning false                                                               // 53\n  // Note: 0 is a valid value, means that we always return false if                                                  // 54\n  // the entire buffer is not flushed immediately on write()                                                         // 55\n  var hwm = options.highWaterMark;                                                                                   // 56\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;                                                         // 57\n                                                                                                                     // 58\n  // object stream flag to indicate whether or not this stream                                                       // 59\n  // contains buffers or objects.                                                                                    // 60\n  this.objectMode = !!options.objectMode;                                                                            // 61\n                                                                                                                     // 62\n  // cast to ints.                                                                                                   // 63\n  this.highWaterMark = ~~this.highWaterMark;                                                                         // 64\n                                                                                                                     // 65\n  this.needDrain = false;                                                                                            // 66\n  // at the start of calling end()                                                                                   // 67\n  this.ending = false;                                                                                               // 68\n  // when end() has been called, and returned                                                                        // 69\n  this.ended = false;                                                                                                // 70\n  // when 'finish' is emitted                                                                                        // 71\n  this.finished = false;                                                                                             // 72\n                                                                                                                     // 73\n  // should we decode strings into buffers before passing to _write?                                                 // 74\n  // this is here so that some node-core streams can optimize string                                                 // 75\n  // handling at a lower level.                                                                                      // 76\n  var noDecode = options.decodeStrings === false;                                                                    // 77\n  this.decodeStrings = !noDecode;                                                                                    // 78\n                                                                                                                     // 79\n  // Crypto is kind of old and crusty.  Historically, its default string                                             // 80\n  // encoding is 'binary' so we have to make this configurable.                                                      // 81\n  // Everything else in the universe uses 'utf8', though.                                                            // 82\n  this.defaultEncoding = options.defaultEncoding || 'utf8';                                                          // 83\n                                                                                                                     // 84\n  // not an actual buffer we keep track of, but a measurement                                                        // 85\n  // of how much we're waiting to get pushed to some underlying                                                      // 86\n  // socket or file.                                                                                                 // 87\n  this.length = 0;                                                                                                   // 88\n                                                                                                                     // 89\n  // a flag to see when we're in the middle of a write.                                                              // 90\n  this.writing = false;                                                                                              // 91\n                                                                                                                     // 92\n  // a flag to be able to tell if the onwrite cb is called immediately,                                              // 93\n  // or on a later tick.  We set this to true at first, becuase any                                                  // 94\n  // actions that shouldn't happen until \"later\" should generally also                                               // 95\n  // not happen before the first write call.                                                                         // 96\n  this.sync = true;                                                                                                  // 97\n                                                                                                                     // 98\n  // a flag to know if we're processing previously buffered items, which                                             // 99\n  // may call the _write() callback in the same tick, so that we don't                                               // 100\n  // end up in an overlapped onwrite situation.                                                                      // 101\n  this.bufferProcessing = false;                                                                                     // 102\n                                                                                                                     // 103\n  // the callback that's passed to _write(chunk,cb)                                                                  // 104\n  this.onwrite = function(er) {                                                                                      // 105\n    onwrite(stream, er);                                                                                             // 106\n  };                                                                                                                 // 107\n                                                                                                                     // 108\n  // the callback that the user supplies to write(chunk,encoding,cb)                                                 // 109\n  this.writecb = null;                                                                                               // 110\n                                                                                                                     // 111\n  // the amount that is being written when _write is called.                                                         // 112\n  this.writelen = 0;                                                                                                 // 113\n                                                                                                                     // 114\n  this.buffer = [];                                                                                                  // 115\n                                                                                                                     // 116\n  // True if the error was already emitted and should not be thrown again                                            // 117\n  this.errorEmitted = false;                                                                                         // 118\n}                                                                                                                    // 119\n                                                                                                                     // 120\nfunction Writable(options) {                                                                                         // 121\n  var Duplex = require('./_stream_duplex');                                                                          // 122\n                                                                                                                     // 123\n  // Writable ctor is applied to Duplexes, though they're not                                                        // 124\n  // instanceof Writable, they're instanceof Readable.                                                               // 125\n  if (!(this instanceof Writable) && !(this instanceof Duplex))                                                      // 126\n    return new Writable(options);                                                                                    // 127\n                                                                                                                     // 128\n  this._writableState = new WritableState(options, this);                                                            // 129\n                                                                                                                     // 130\n  // legacy.                                                                                                         // 131\n  this.writable = true;                                                                                              // 132\n                                                                                                                     // 133\n  Stream.call(this);                                                                                                 // 134\n}                                                                                                                    // 135\n                                                                                                                     // 136\n// Otherwise people can pipe Writable streams, which is just wrong.                                                  // 137\nWritable.prototype.pipe = function() {                                                                               // 138\n  this.emit('error', new Error('Cannot pipe. Not readable.'));                                                       // 139\n};                                                                                                                   // 140\n                                                                                                                     // 141\n                                                                                                                     // 142\nfunction writeAfterEnd(stream, state, cb) {                                                                          // 143\n  var er = new Error('write after end');                                                                             // 144\n  // TODO: defer error events consistently everywhere, not just the cb                                               // 145\n  stream.emit('error', er);                                                                                          // 146\n  process.nextTick(function() {                                                                                      // 147\n    cb(er);                                                                                                          // 148\n  });                                                                                                                // 149\n}                                                                                                                    // 150\n                                                                                                                     // 151\n// If we get something that is not a buffer, string, null, or undefined,                                             // 152\n// and we're not in objectMode, then that's an error.                                                                // 153\n// Otherwise stream chunks are all considered to be of length=1, and the                                             // 154\n// watermarks determine how many objects to keep in the buffer, rather than                                          // 155\n// how many bytes or characters.                                                                                     // 156\nfunction validChunk(stream, state, chunk, cb) {                                                                      // 157\n  var valid = true;                                                                                                  // 158\n  if (!Buffer.isBuffer(chunk) &&                                                                                     // 159\n      'string' !== typeof chunk &&                                                                                   // 160\n      chunk !== null &&                                                                                              // 161\n      chunk !== undefined &&                                                                                         // 162\n      !state.objectMode) {                                                                                           // 163\n    var er = new TypeError('Invalid non-string/buffer chunk');                                                       // 164\n    stream.emit('error', er);                                                                                        // 165\n    process.nextTick(function() {                                                                                    // 166\n      cb(er);                                                                                                        // 167\n    });                                                                                                              // 168\n    valid = false;                                                                                                   // 169\n  }                                                                                                                  // 170\n  return valid;                                                                                                      // 171\n}                                                                                                                    // 172\n                                                                                                                     // 173\nWritable.prototype.write = function(chunk, encoding, cb) {                                                           // 174\n  var state = this._writableState;                                                                                   // 175\n  var ret = false;                                                                                                   // 176\n                                                                                                                     // 177\n  if (typeof encoding === 'function') {                                                                              // 178\n    cb = encoding;                                                                                                   // 179\n    encoding = null;                                                                                                 // 180\n  }                                                                                                                  // 181\n                                                                                                                     // 182\n  if (Buffer.isBuffer(chunk))                                                                                        // 183\n    encoding = 'buffer';                                                                                             // 184\n  else if (!encoding)                                                                                                // 185\n    encoding = state.defaultEncoding;                                                                                // 186\n                                                                                                                     // 187\n  if (typeof cb !== 'function')                                                                                      // 188\n    cb = function() {};                                                                                              // 189\n                                                                                                                     // 190\n  if (state.ended)                                                                                                   // 191\n    writeAfterEnd(this, state, cb);                                                                                  // 192\n  else if (validChunk(this, state, chunk, cb))                                                                       // 193\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);                                                           // 194\n                                                                                                                     // 195\n  return ret;                                                                                                        // 196\n};                                                                                                                   // 197\n                                                                                                                     // 198\nfunction decodeChunk(state, chunk, encoding) {                                                                       // 199\n  if (!state.objectMode &&                                                                                           // 200\n      state.decodeStrings !== false &&                                                                               // 201\n      typeof chunk === 'string') {                                                                                   // 202\n    chunk = new Buffer(chunk, encoding);                                                                             // 203\n  }                                                                                                                  // 204\n  return chunk;                                                                                                      // 205\n}                                                                                                                    // 206\n                                                                                                                     // 207\n// if we're already writing something, then just put this                                                            // 208\n// in the queue, and wait our turn.  Otherwise, call _write                                                          // 209\n// If we return false, then we need a drain event, so set that flag.                                                 // 210\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {                                                         // 211\n  chunk = decodeChunk(state, chunk, encoding);                                                                       // 212\n  if (Buffer.isBuffer(chunk))                                                                                        // 213\n    encoding = 'buffer';                                                                                             // 214\n  var len = state.objectMode ? 1 : chunk.length;                                                                     // 215\n                                                                                                                     // 216\n  state.length += len;                                                                                               // 217\n                                                                                                                     // 218\n  var ret = state.length < state.highWaterMark;                                                                      // 219\n  // we must ensure that previous needDrain will not be reset to false.                                              // 220\n  if (!ret)                                                                                                          // 221\n    state.needDrain = true;                                                                                          // 222\n                                                                                                                     // 223\n  if (state.writing)                                                                                                 // 224\n    state.buffer.push(new WriteReq(chunk, encoding, cb));                                                            // 225\n  else                                                                                                               // 226\n    doWrite(stream, state, len, chunk, encoding, cb);                                                                // 227\n                                                                                                                     // 228\n  return ret;                                                                                                        // 229\n}                                                                                                                    // 230\n                                                                                                                     // 231\nfunction doWrite(stream, state, len, chunk, encoding, cb) {                                                          // 232\n  state.writelen = len;                                                                                              // 233\n  state.writecb = cb;                                                                                                // 234\n  state.writing = true;                                                                                              // 235\n  state.sync = true;                                                                                                 // 236\n  stream._write(chunk, encoding, state.onwrite);                                                                     // 237\n  state.sync = false;                                                                                                // 238\n}                                                                                                                    // 239\n                                                                                                                     // 240\nfunction onwriteError(stream, state, sync, er, cb) {                                                                 // 241\n  if (sync)                                                                                                          // 242\n    process.nextTick(function() {                                                                                    // 243\n      cb(er);                                                                                                        // 244\n    });                                                                                                              // 245\n  else                                                                                                               // 246\n    cb(er);                                                                                                          // 247\n                                                                                                                     // 248\n  stream._writableState.errorEmitted = true;                                                                         // 249\n  stream.emit('error', er);                                                                                          // 250\n}                                                                                                                    // 251\n                                                                                                                     // 252\nfunction onwriteStateUpdate(state) {                                                                                 // 253\n  state.writing = false;                                                                                             // 254\n  state.writecb = null;                                                                                              // 255\n  state.length -= state.writelen;                                                                                    // 256\n  state.writelen = 0;                                                                                                // 257\n}                                                                                                                    // 258\n                                                                                                                     // 259\nfunction onwrite(stream, er) {                                                                                       // 260\n  var state = stream._writableState;                                                                                 // 261\n  var sync = state.sync;                                                                                             // 262\n  var cb = state.writecb;                                                                                            // 263\n                                                                                                                     // 264\n  onwriteStateUpdate(state);                                                                                         // 265\n                                                                                                                     // 266\n  if (er)                                                                                                            // 267\n    onwriteError(stream, state, sync, er, cb);                                                                       // 268\n  else {                                                                                                             // 269\n    // Check if we're actually ready to finish, but don't emit yet                                                   // 270\n    var finished = needFinish(stream, state);                                                                        // 271\n                                                                                                                     // 272\n    if (!finished && !state.bufferProcessing && state.buffer.length)                                                 // 273\n      clearBuffer(stream, state);                                                                                    // 274\n                                                                                                                     // 275\n    if (sync) {                                                                                                      // 276\n      process.nextTick(function() {                                                                                  // 277\n        afterWrite(stream, state, finished, cb);                                                                     // 278\n      });                                                                                                            // 279\n    } else {                                                                                                         // 280\n      afterWrite(stream, state, finished, cb);                                                                       // 281\n    }                                                                                                                // 282\n  }                                                                                                                  // 283\n}                                                                                                                    // 284\n                                                                                                                     // 285\nfunction afterWrite(stream, state, finished, cb) {                                                                   // 286\n  if (!finished)                                                                                                     // 287\n    onwriteDrain(stream, state);                                                                                     // 288\n  cb();                                                                                                              // 289\n  if (finished)                                                                                                      // 290\n    finishMaybe(stream, state);                                                                                      // 291\n}                                                                                                                    // 292\n                                                                                                                     // 293\n// Must force callback to be called on nextTick, so that we don't                                                    // 294\n// emit 'drain' before the write() consumer gets the 'false' return                                                  // 295\n// value, and has a chance to attach a 'drain' listener.                                                             // 296\nfunction onwriteDrain(stream, state) {                                                                               // 297\n  if (state.length === 0 && state.needDrain) {                                                                       // 298\n    state.needDrain = false;                                                                                         // 299\n    stream.emit('drain');                                                                                            // 300\n  }                                                                                                                  // 301\n}                                                                                                                    // 302\n                                                                                                                     // 303\n                                                                                                                     // 304\n// if there's something in the buffer waiting, then process it                                                       // 305\nfunction clearBuffer(stream, state) {                                                                                // 306\n  state.bufferProcessing = true;                                                                                     // 307\n                                                                                                                     // 308\n  for (var c = 0; c < state.buffer.length; c++) {                                                                    // 309\n    var entry = state.buffer[c];                                                                                     // 310\n    var chunk = entry.chunk;                                                                                         // 311\n    var encoding = entry.encoding;                                                                                   // 312\n    var cb = entry.callback;                                                                                         // 313\n    var len = state.objectMode ? 1 : chunk.length;                                                                   // 314\n                                                                                                                     // 315\n    doWrite(stream, state, len, chunk, encoding, cb);                                                                // 316\n                                                                                                                     // 317\n    // if we didn't call the onwrite immediately, then                                                               // 318\n    // it means that we need to wait until it does.                                                                  // 319\n    // also, that means that the chunk and cb are currently                                                          // 320\n    // being processed, so move the buffer counter past them.                                                        // 321\n    if (state.writing) {                                                                                             // 322\n      c++;                                                                                                           // 323\n      break;                                                                                                         // 324\n    }                                                                                                                // 325\n  }                                                                                                                  // 326\n                                                                                                                     // 327\n  state.bufferProcessing = false;                                                                                    // 328\n  if (c < state.buffer.length)                                                                                       // 329\n    state.buffer = state.buffer.slice(c);                                                                            // 330\n  else                                                                                                               // 331\n    state.buffer.length = 0;                                                                                         // 332\n}                                                                                                                    // 333\n                                                                                                                     // 334\nWritable.prototype._write = function(chunk, encoding, cb) {                                                          // 335\n  cb(new Error('not implemented'));                                                                                  // 336\n};                                                                                                                   // 337\n                                                                                                                     // 338\nWritable.prototype.end = function(chunk, encoding, cb) {                                                             // 339\n  var state = this._writableState;                                                                                   // 340\n                                                                                                                     // 341\n  if (typeof chunk === 'function') {                                                                                 // 342\n    cb = chunk;                                                                                                      // 343\n    chunk = null;                                                                                                    // 344\n    encoding = null;                                                                                                 // 345\n  } else if (typeof encoding === 'function') {                                                                       // 346\n    cb = encoding;                                                                                                   // 347\n    encoding = null;                                                                                                 // 348\n  }                                                                                                                  // 349\n                                                                                                                     // 350\n  if (typeof chunk !== 'undefined' && chunk !== null)                                                                // 351\n    this.write(chunk, encoding);                                                                                     // 352\n                                                                                                                     // 353\n  // ignore unnecessary end() calls.                                                                                 // 354\n  if (!state.ending && !state.finished)                                                                              // 355\n    endWritable(this, state, cb);                                                                                    // 356\n};                                                                                                                   // 357\n                                                                                                                     // 358\n                                                                                                                     // 359\nfunction needFinish(stream, state) {                                                                                 // 360\n  return (state.ending &&                                                                                            // 361\n          state.length === 0 &&                                                                                      // 362\n          !state.finished &&                                                                                         // 363\n          !state.writing);                                                                                           // 364\n}                                                                                                                    // 365\n                                                                                                                     // 366\nfunction finishMaybe(stream, state) {                                                                                // 367\n  var need = needFinish(stream, state);                                                                              // 368\n  if (need) {                                                                                                        // 369\n    state.finished = true;                                                                                           // 370\n    stream.emit('finish');                                                                                           // 371\n  }                                                                                                                  // 372\n  return need;                                                                                                       // 373\n}                                                                                                                    // 374\n                                                                                                                     // 375\nfunction endWritable(stream, state, cb) {                                                                            // 376\n  state.ending = true;                                                                                               // 377\n  finishMaybe(stream, state);                                                                                        // 378\n  if (cb) {                                                                                                          // 379\n    if (state.finished)                                                                                              // 380\n      process.nextTick(cb);                                                                                          // 381\n    else                                                                                                             // 382\n      stream.once('finish', cb);                                                                                     // 383\n  }                                                                                                                  // 384\n  state.ended = true;                                                                                                // 385\n}                                                                                                                    // 386\n                                                                                                                     // 387\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_duplex.js\":[\"core-util-is\",\"inherits\",\"./_stream_readable\",\"./_stream_writable\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/lib/_stream_duplex.js                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n// a duplex stream is just a stream that is both readable and writable.                                              // 22\n// Since JS doesn't have multiple prototypal inheritance, this class                                                 // 23\n// prototypally inherits from Readable, and then parasitically from                                                  // 24\n// Writable.                                                                                                         // 25\n                                                                                                                     // 26\nmodule.exports = Duplex;                                                                                             // 27\n                                                                                                                     // 28\n/*<replacement>*/                                                                                                    // 29\nvar objectKeys = Object.keys || function (obj) {                                                                     // 30\n  var keys = [];                                                                                                     // 31\n  for (var key in obj) keys.push(key);                                                                               // 32\n  return keys;                                                                                                       // 33\n}                                                                                                                    // 34\n/*</replacement>*/                                                                                                   // 35\n                                                                                                                     // 36\n                                                                                                                     // 37\n/*<replacement>*/                                                                                                    // 38\nvar util = require('core-util-is');                                                                                  // 39\nutil.inherits = require('inherits');                                                                                 // 40\n/*</replacement>*/                                                                                                   // 41\n                                                                                                                     // 42\nvar Readable = require('./_stream_readable');                                                                        // 43\nvar Writable = require('./_stream_writable');                                                                        // 44\n                                                                                                                     // 45\nutil.inherits(Duplex, Readable);                                                                                     // 46\n                                                                                                                     // 47\nforEach(objectKeys(Writable.prototype), function(method) {                                                           // 48\n  if (!Duplex.prototype[method])                                                                                     // 49\n    Duplex.prototype[method] = Writable.prototype[method];                                                           // 50\n});                                                                                                                  // 51\n                                                                                                                     // 52\nfunction Duplex(options) {                                                                                           // 53\n  if (!(this instanceof Duplex))                                                                                     // 54\n    return new Duplex(options);                                                                                      // 55\n                                                                                                                     // 56\n  Readable.call(this, options);                                                                                      // 57\n  Writable.call(this, options);                                                                                      // 58\n                                                                                                                     // 59\n  if (options && options.readable === false)                                                                         // 60\n    this.readable = false;                                                                                           // 61\n                                                                                                                     // 62\n  if (options && options.writable === false)                                                                         // 63\n    this.writable = false;                                                                                           // 64\n                                                                                                                     // 65\n  this.allowHalfOpen = true;                                                                                         // 66\n  if (options && options.allowHalfOpen === false)                                                                    // 67\n    this.allowHalfOpen = false;                                                                                      // 68\n                                                                                                                     // 69\n  this.once('end', onend);                                                                                           // 70\n}                                                                                                                    // 71\n                                                                                                                     // 72\n// the no-half-open enforcer                                                                                         // 73\nfunction onend() {                                                                                                   // 74\n  // if we allow half-open state, or if the writable side ended,                                                     // 75\n  // then we're ok.                                                                                                  // 76\n  if (this.allowHalfOpen || this._writableState.ended)                                                               // 77\n    return;                                                                                                          // 78\n                                                                                                                     // 79\n  // no more data can be written.                                                                                    // 80\n  // But allow more writes to happen in this tick.                                                                   // 81\n  process.nextTick(this.end.bind(this));                                                                             // 82\n}                                                                                                                    // 83\n                                                                                                                     // 84\nfunction forEach (xs, f) {                                                                                           // 85\n  for (var i = 0, l = xs.length; i < l; i++) {                                                                       // 86\n    f(xs[i], i);                                                                                                     // 87\n  }                                                                                                                  // 88\n}                                                                                                                    // 89\n                                                                                                                     // 90\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_transform.js\":[\"./_stream_duplex\",\"core-util-is\",\"inherits\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/lib/_stream_transform.js                                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n                                                                                                                     // 22\n// a transform stream is a readable/writable stream where you do                                                     // 23\n// something with the data.  Sometimes it's called a \"filter\",                                                       // 24\n// but that's not a great name for it, since that implies a thing where                                              // 25\n// some bits pass through, and others are simply ignored.  (That would                                               // 26\n// be a valid example of a transform, of course.)                                                                    // 27\n//                                                                                                                   // 28\n// While the output is causally related to the input, it's not a                                                     // 29\n// necessarily symmetric or synchronous transformation.  For example,                                                // 30\n// a zlib stream might take multiple plain-text writes(), and then                                                   // 31\n// emit a single compressed chunk some time in the future.                                                           // 32\n//                                                                                                                   // 33\n// Here's how this works:                                                                                            // 34\n//                                                                                                                   // 35\n// The Transform stream has all the aspects of the readable and writable                                             // 36\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)                                               // 37\n// internally, and returns false if there's a lot of pending writes                                                  // 38\n// buffered up.  When you call read(), that calls _read(n) until                                                     // 39\n// there's enough pending readable data buffered up.                                                                 // 40\n//                                                                                                                   // 41\n// In a transform stream, the written data is placed in a buffer.  When                                              // 42\n// _read(n) is called, it transforms the queued up data, calling the                                                 // 43\n// buffered _write cb's as it consumes chunks.  If consuming a single                                                // 44\n// written chunk would result in multiple output chunks, then the first                                              // 45\n// outputted bit calls the readcb, and subsequent chunks just go into                                                // 46\n// the read buffer, and will cause it to emit 'readable' if necessary.                                               // 47\n//                                                                                                                   // 48\n// This way, back-pressure is actually determined by the reading side,                                               // 49\n// since _read has to be called to start processing a new chunk.  However,                                           // 50\n// a pathological inflate type of transform can cause excessive buffering                                            // 51\n// here.  For example, imagine a stream where every byte of input is                                                 // 52\n// interpreted as an integer from 0-255, and then results in that many                                               // 53\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in                                               // 54\n// 1kb of data being output.  In this case, you could write a very small                                             // 55\n// amount of input, and end up with a very large amount of output.  In                                               // 56\n// such a pathological inflating mechanism, there'd be no way to tell                                                // 57\n// the system to stop doing the transform.  A single 4MB write could                                                 // 58\n// cause the system to run out of memory.                                                                            // 59\n//                                                                                                                   // 60\n// However, even in such a pathological case, only a single written chunk                                            // 61\n// would be consumed, and then the rest would wait (un-transformed) until                                            // 62\n// the results of the previous transformed chunk were consumed.                                                      // 63\n                                                                                                                     // 64\nmodule.exports = Transform;                                                                                          // 65\n                                                                                                                     // 66\nvar Duplex = require('./_stream_duplex');                                                                            // 67\n                                                                                                                     // 68\n/*<replacement>*/                                                                                                    // 69\nvar util = require('core-util-is');                                                                                  // 70\nutil.inherits = require('inherits');                                                                                 // 71\n/*</replacement>*/                                                                                                   // 72\n                                                                                                                     // 73\nutil.inherits(Transform, Duplex);                                                                                    // 74\n                                                                                                                     // 75\n                                                                                                                     // 76\nfunction TransformState(options, stream) {                                                                           // 77\n  this.afterTransform = function(er, data) {                                                                         // 78\n    return afterTransform(stream, er, data);                                                                         // 79\n  };                                                                                                                 // 80\n                                                                                                                     // 81\n  this.needTransform = false;                                                                                        // 82\n  this.transforming = false;                                                                                         // 83\n  this.writecb = null;                                                                                               // 84\n  this.writechunk = null;                                                                                            // 85\n}                                                                                                                    // 86\n                                                                                                                     // 87\nfunction afterTransform(stream, er, data) {                                                                          // 88\n  var ts = stream._transformState;                                                                                   // 89\n  ts.transforming = false;                                                                                           // 90\n                                                                                                                     // 91\n  var cb = ts.writecb;                                                                                               // 92\n                                                                                                                     // 93\n  if (!cb)                                                                                                           // 94\n    return stream.emit('error', new Error('no writecb in Transform class'));                                         // 95\n                                                                                                                     // 96\n  ts.writechunk = null;                                                                                              // 97\n  ts.writecb = null;                                                                                                 // 98\n                                                                                                                     // 99\n  if (data !== null && data !== undefined)                                                                           // 100\n    stream.push(data);                                                                                               // 101\n                                                                                                                     // 102\n  if (cb)                                                                                                            // 103\n    cb(er);                                                                                                          // 104\n                                                                                                                     // 105\n  var rs = stream._readableState;                                                                                    // 106\n  rs.reading = false;                                                                                                // 107\n  if (rs.needReadable || rs.length < rs.highWaterMark) {                                                             // 108\n    stream._read(rs.highWaterMark);                                                                                  // 109\n  }                                                                                                                  // 110\n}                                                                                                                    // 111\n                                                                                                                     // 112\n                                                                                                                     // 113\nfunction Transform(options) {                                                                                        // 114\n  if (!(this instanceof Transform))                                                                                  // 115\n    return new Transform(options);                                                                                   // 116\n                                                                                                                     // 117\n  Duplex.call(this, options);                                                                                        // 118\n                                                                                                                     // 119\n  var ts = this._transformState = new TransformState(options, this);                                                 // 120\n                                                                                                                     // 121\n  // when the writable side finishes, then flush out anything remaining.                                             // 122\n  var stream = this;                                                                                                 // 123\n                                                                                                                     // 124\n  // start out asking for a readable event once data is transformed.                                                 // 125\n  this._readableState.needReadable = true;                                                                           // 126\n                                                                                                                     // 127\n  // we have implemented the _read method, and done the other things                                                 // 128\n  // that Readable wants before the first _read call, so unset the                                                   // 129\n  // sync guard flag.                                                                                                // 130\n  this._readableState.sync = false;                                                                                  // 131\n                                                                                                                     // 132\n  this.once('finish', function() {                                                                                   // 133\n    if ('function' === typeof this._flush)                                                                           // 134\n      this._flush(function(er) {                                                                                     // 135\n        done(stream, er);                                                                                            // 136\n      });                                                                                                            // 137\n    else                                                                                                             // 138\n      done(stream);                                                                                                  // 139\n  });                                                                                                                // 140\n}                                                                                                                    // 141\n                                                                                                                     // 142\nTransform.prototype.push = function(chunk, encoding) {                                                               // 143\n  this._transformState.needTransform = false;                                                                        // 144\n  return Duplex.prototype.push.call(this, chunk, encoding);                                                          // 145\n};                                                                                                                   // 146\n                                                                                                                     // 147\n// This is the part where you do stuff!                                                                              // 148\n// override this function in implementation classes.                                                                 // 149\n// 'chunk' is an input chunk.                                                                                        // 150\n//                                                                                                                   // 151\n// Call `push(newChunk)` to pass along transformed output                                                            // 152\n// to the readable side.  You may call 'push' zero or more times.                                                    // 153\n//                                                                                                                   // 154\n// Call `cb(err)` when you are done with this chunk.  If you pass                                                    // 155\n// an error, then that'll put the hurt on the whole operation.  If you                                               // 156\n// never call cb(), then you'll never get another chunk.                                                             // 157\nTransform.prototype._transform = function(chunk, encoding, cb) {                                                     // 158\n  throw new Error('not implemented');                                                                                // 159\n};                                                                                                                   // 160\n                                                                                                                     // 161\nTransform.prototype._write = function(chunk, encoding, cb) {                                                         // 162\n  var ts = this._transformState;                                                                                     // 163\n  ts.writecb = cb;                                                                                                   // 164\n  ts.writechunk = chunk;                                                                                             // 165\n  ts.writeencoding = encoding;                                                                                       // 166\n  if (!ts.transforming) {                                                                                            // 167\n    var rs = this._readableState;                                                                                    // 168\n    if (ts.needTransform ||                                                                                          // 169\n        rs.needReadable ||                                                                                           // 170\n        rs.length < rs.highWaterMark)                                                                                // 171\n      this._read(rs.highWaterMark);                                                                                  // 172\n  }                                                                                                                  // 173\n};                                                                                                                   // 174\n                                                                                                                     // 175\n// Doesn't matter what the args are here.                                                                            // 176\n// _transform does all the work.                                                                                     // 177\n// That we got here means that the readable side wants more data.                                                    // 178\nTransform.prototype._read = function(n) {                                                                            // 179\n  var ts = this._transformState;                                                                                     // 180\n                                                                                                                     // 181\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {                                                    // 182\n    ts.transforming = true;                                                                                          // 183\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);                                             // 184\n  } else {                                                                                                           // 185\n    // mark that we need a transform, so that any data that comes in                                                 // 186\n    // will get processed, now that we've asked for it.                                                              // 187\n    ts.needTransform = true;                                                                                         // 188\n  }                                                                                                                  // 189\n};                                                                                                                   // 190\n                                                                                                                     // 191\n                                                                                                                     // 192\nfunction done(stream, er) {                                                                                          // 193\n  if (er)                                                                                                            // 194\n    return stream.emit('error', er);                                                                                 // 195\n                                                                                                                     // 196\n  // if there's nothing in the write buffer, then that means                                                         // 197\n  // that nothing more will ever be provided                                                                         // 198\n  var ws = stream._writableState;                                                                                    // 199\n  var rs = stream._readableState;                                                                                    // 200\n  var ts = stream._transformState;                                                                                   // 201\n                                                                                                                     // 202\n  if (ws.length)                                                                                                     // 203\n    throw new Error('calling transform done when ws.length != 0');                                                   // 204\n                                                                                                                     // 205\n  if (ts.transforming)                                                                                               // 206\n    throw new Error('calling transform done when still transforming');                                               // 207\n                                                                                                                     // 208\n  return stream.push(null);                                                                                          // 209\n}                                                                                                                    // 210\n                                                                                                                     // 211\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"_stream_passthrough.js\":[\"./_stream_transform\",\"core-util-is\",\"inherits\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/readable-stream/lib/_stream_passthrough.js                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n// a passthrough stream.                                                                                             // 22\n// basically just the most minimal sort of Transform stream.                                                         // 23\n// Every written chunk gets output as-is.                                                                            // 24\n                                                                                                                     // 25\nmodule.exports = PassThrough;                                                                                        // 26\n                                                                                                                     // 27\nvar Transform = require('./_stream_transform');                                                                      // 28\n                                                                                                                     // 29\n/*<replacement>*/                                                                                                    // 30\nvar util = require('core-util-is');                                                                                  // 31\nutil.inherits = require('inherits');                                                                                 // 32\n/*</replacement>*/                                                                                                   // 33\n                                                                                                                     // 34\nutil.inherits(PassThrough, Transform);                                                                               // 35\n                                                                                                                     // 36\nfunction PassThrough(options) {                                                                                      // 37\n  if (!(this instanceof PassThrough))                                                                                // 38\n    return new PassThrough(options);                                                                                 // 39\n                                                                                                                     // 40\n  Transform.call(this, options);                                                                                     // 41\n}                                                                                                                    // 42\n                                                                                                                     // 43\nPassThrough.prototype._transform = function(chunk, encoding, cb) {                                                   // 44\n  cb(null, chunk);                                                                                                   // 45\n};                                                                                                                   // 46\n                                                                                                                     // 47\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}},\"isarray\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/isarray/package.json                                                                                 //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"isarray\";                                                                                            // 1\nexports.version = \"0.0.1\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/isarray/index.js                                                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nmodule.exports = Array.isArray || function (arr) {                                                                   // 1\n  return Object.prototype.toString.call(arr) == '[object Array]';                                                    // 2\n};                                                                                                                   // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"core-util-is\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/core-util-is/package.json                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"core-util-is\";                                                                                       // 1\nexports.version = \"1.0.2\";                                                                                           // 2\nexports.main = \"lib/util.js\";                                                                                        // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"lib\":{\"util.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/core-util-is/lib/util.js                                                                             //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\n// NOTE: These type checking functions intentionally don't use `instanceof`                                          // 22\n// because it is fragile and can be easily faked with `Object.create()`.                                             // 23\n                                                                                                                     // 24\nfunction isArray(arg) {                                                                                              // 25\n  if (Array.isArray) {                                                                                               // 26\n    return Array.isArray(arg);                                                                                       // 27\n  }                                                                                                                  // 28\n  return objectToString(arg) === '[object Array]';                                                                   // 29\n}                                                                                                                    // 30\nexports.isArray = isArray;                                                                                           // 31\n                                                                                                                     // 32\nfunction isBoolean(arg) {                                                                                            // 33\n  return typeof arg === 'boolean';                                                                                   // 34\n}                                                                                                                    // 35\nexports.isBoolean = isBoolean;                                                                                       // 36\n                                                                                                                     // 37\nfunction isNull(arg) {                                                                                               // 38\n  return arg === null;                                                                                               // 39\n}                                                                                                                    // 40\nexports.isNull = isNull;                                                                                             // 41\n                                                                                                                     // 42\nfunction isNullOrUndefined(arg) {                                                                                    // 43\n  return arg == null;                                                                                                // 44\n}                                                                                                                    // 45\nexports.isNullOrUndefined = isNullOrUndefined;                                                                       // 46\n                                                                                                                     // 47\nfunction isNumber(arg) {                                                                                             // 48\n  return typeof arg === 'number';                                                                                    // 49\n}                                                                                                                    // 50\nexports.isNumber = isNumber;                                                                                         // 51\n                                                                                                                     // 52\nfunction isString(arg) {                                                                                             // 53\n  return typeof arg === 'string';                                                                                    // 54\n}                                                                                                                    // 55\nexports.isString = isString;                                                                                         // 56\n                                                                                                                     // 57\nfunction isSymbol(arg) {                                                                                             // 58\n  return typeof arg === 'symbol';                                                                                    // 59\n}                                                                                                                    // 60\nexports.isSymbol = isSymbol;                                                                                         // 61\n                                                                                                                     // 62\nfunction isUndefined(arg) {                                                                                          // 63\n  return arg === void 0;                                                                                             // 64\n}                                                                                                                    // 65\nexports.isUndefined = isUndefined;                                                                                   // 66\n                                                                                                                     // 67\nfunction isRegExp(re) {                                                                                              // 68\n  return objectToString(re) === '[object RegExp]';                                                                   // 69\n}                                                                                                                    // 70\nexports.isRegExp = isRegExp;                                                                                         // 71\n                                                                                                                     // 72\nfunction isObject(arg) {                                                                                             // 73\n  return typeof arg === 'object' && arg !== null;                                                                    // 74\n}                                                                                                                    // 75\nexports.isObject = isObject;                                                                                         // 76\n                                                                                                                     // 77\nfunction isDate(d) {                                                                                                 // 78\n  return objectToString(d) === '[object Date]';                                                                      // 79\n}                                                                                                                    // 80\nexports.isDate = isDate;                                                                                             // 81\n                                                                                                                     // 82\nfunction isError(e) {                                                                                                // 83\n  return (objectToString(e) === '[object Error]' || e instanceof Error);                                             // 84\n}                                                                                                                    // 85\nexports.isError = isError;                                                                                           // 86\n                                                                                                                     // 87\nfunction isFunction(arg) {                                                                                           // 88\n  return typeof arg === 'function';                                                                                  // 89\n}                                                                                                                    // 90\nexports.isFunction = isFunction;                                                                                     // 91\n                                                                                                                     // 92\nfunction isPrimitive(arg) {                                                                                          // 93\n  return arg === null ||                                                                                             // 94\n         typeof arg === 'boolean' ||                                                                                 // 95\n         typeof arg === 'number' ||                                                                                  // 96\n         typeof arg === 'string' ||                                                                                  // 97\n         typeof arg === 'symbol' ||  // ES6 symbol                                                                   // 98\n         typeof arg === 'undefined';                                                                                 // 99\n}                                                                                                                    // 100\nexports.isPrimitive = isPrimitive;                                                                                   // 101\n                                                                                                                     // 102\nexports.isBuffer = Buffer.isBuffer;                                                                                  // 103\n                                                                                                                     // 104\nfunction objectToString(o) {                                                                                         // 105\n  return Object.prototype.toString.call(o);                                                                          // 106\n}                                                                                                                    // 107\n                                                                                                                     // 108\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}},\"inherits\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/inherits/package.json                                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"inherits\";                                                                                           // 1\nexports.version = \"2.0.1\";                                                                                           // 2\nexports.main = \"./inherits_browser.js\";                                                                              // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"inherits_browser.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/inherits/inherits_browser.js                                                                         //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nif (typeof Object.create === 'function') {                                                                           // 1\n  // implementation from standard node.js 'util' module                                                              // 2\n  module.exports = function inherits(ctor, superCtor) {                                                              // 3\n    ctor.super_ = superCtor                                                                                          // 4\n    ctor.prototype = Object.create(superCtor.prototype, {                                                            // 5\n      constructor: {                                                                                                 // 6\n        value: ctor,                                                                                                 // 7\n        enumerable: false,                                                                                           // 8\n        writable: true,                                                                                              // 9\n        configurable: true                                                                                           // 10\n      }                                                                                                              // 11\n    });                                                                                                              // 12\n  };                                                                                                                 // 13\n} else {                                                                                                             // 14\n  // old school shim for old browsers                                                                                // 15\n  module.exports = function inherits(ctor, superCtor) {                                                              // 16\n    ctor.super_ = superCtor                                                                                          // 17\n    var TempCtor = function () {}                                                                                    // 18\n    TempCtor.prototype = superCtor.prototype                                                                         // 19\n    ctor.prototype = new TempCtor()                                                                                  // 20\n    ctor.prototype.constructor = ctor                                                                                // 21\n  }                                                                                                                  // 22\n}                                                                                                                    // 23\n                                                                                                                     // 24\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"string_decoder\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/string_decoder/package.json                                                                          //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"string_decoder\";                                                                                     // 1\nexports.version = \"0.10.31\";                                                                                         // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"buffer\",\"meteor-node-stubs/deps/buffer\",function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/string_decoder/index.js                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copyright Joyent, Inc. and other Node contributors.                                                               // 1\n//                                                                                                                   // 2\n// Permission is hereby granted, free of charge, to any person obtaining a                                           // 3\n// copy of this software and associated documentation files (the                                                     // 4\n// \"Software\"), to deal in the Software without restriction, including                                               // 5\n// without limitation the rights to use, copy, modify, merge, publish,                                               // 6\n// distribute, sublicense, and/or sell copies of the Software, and to permit                                         // 7\n// persons to whom the Software is furnished to do so, subject to the                                                // 8\n// following conditions:                                                                                             // 9\n//                                                                                                                   // 10\n// The above copyright notice and this permission notice shall be included                                           // 11\n// in all copies or substantial portions of the Software.                                                            // 12\n//                                                                                                                   // 13\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                           // 14\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                                                        // 15\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN                                         // 16\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,                                          // 17\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR                                             // 18\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE                                         // 19\n// USE OR OTHER DEALINGS IN THE SOFTWARE.                                                                            // 20\n                                                                                                                     // 21\nvar Buffer = require('buffer').Buffer;                                                                               // 22\n                                                                                                                     // 23\nvar isBufferEncoding = Buffer.isEncoding                                                                             // 24\n  || function(encoding) {                                                                                            // 25\n       switch (encoding && encoding.toLowerCase()) {                                                                 // 26\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;                                                                                      // 28\n       }                                                                                                             // 29\n     }                                                                                                               // 30\n                                                                                                                     // 31\n                                                                                                                     // 32\nfunction assertEncoding(encoding) {                                                                                  // 33\n  if (encoding && !isBufferEncoding(encoding)) {                                                                     // 34\n    throw new Error('Unknown encoding: ' + encoding);                                                                // 35\n  }                                                                                                                  // 36\n}                                                                                                                    // 37\n                                                                                                                     // 38\n// StringDecoder provides an interface for efficiently splitting a series of                                         // 39\n// buffers into a series of JS strings without breaking apart multi-byte                                             // 40\n// characters. CESU-8 is handled as part of the UTF-8 encoding.                                                      // 41\n//                                                                                                                   // 42\n// @TODO Handling all encodings inside a single object makes it very difficult                                       // 43\n// to reason about this code, so it should be split up in the future.                                                // 44\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code                                      // 45\n// points as used by CESU-8.                                                                                         // 46\nvar StringDecoder = exports.StringDecoder = function(encoding) {                                                     // 47\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');                                            // 48\n  assertEncoding(encoding);                                                                                          // 49\n  switch (this.encoding) {                                                                                           // 50\n    case 'utf8':                                                                                                     // 51\n      // CESU-8 represents each of Surrogate Pair by 3-bytes                                                         // 52\n      this.surrogateSize = 3;                                                                                        // 53\n      break;                                                                                                         // 54\n    case 'ucs2':                                                                                                     // 55\n    case 'utf16le':                                                                                                  // 56\n      // UTF-16 represents each of Surrogate Pair by 2-bytes                                                         // 57\n      this.surrogateSize = 2;                                                                                        // 58\n      this.detectIncompleteChar = utf16DetectIncompleteChar;                                                         // 59\n      break;                                                                                                         // 60\n    case 'base64':                                                                                                   // 61\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.                                                  // 62\n      this.surrogateSize = 3;                                                                                        // 63\n      this.detectIncompleteChar = base64DetectIncompleteChar;                                                        // 64\n      break;                                                                                                         // 65\n    default:                                                                                                         // 66\n      this.write = passThroughWrite;                                                                                 // 67\n      return;                                                                                                        // 68\n  }                                                                                                                  // 69\n                                                                                                                     // 70\n  // Enough space to store all bytes of a single character. UTF-8 needs 4                                            // 71\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).                                                  // 72\n  this.charBuffer = new Buffer(6);                                                                                   // 73\n  // Number of bytes received for the current incomplete multi-byte character.                                       // 74\n  this.charReceived = 0;                                                                                             // 75\n  // Number of bytes expected for the current incomplete multi-byte character.                                       // 76\n  this.charLength = 0;                                                                                               // 77\n};                                                                                                                   // 78\n                                                                                                                     // 79\n                                                                                                                     // 80\n// write decodes the given buffer and returns it as JS string that is                                                // 81\n// guaranteed to not contain any partial multi-byte characters. Any partial                                          // 82\n// character found at the end of the buffer is buffered up, and will be                                              // 83\n// returned when calling write again with the remaining bytes.                                                       // 84\n//                                                                                                                   // 85\n// Note: Converting a Buffer containing an orphan surrogate to a String                                              // 86\n// currently works, but converting a String to a Buffer (via `new Buffer`, or                                        // 87\n// Buffer#write) will replace incomplete surrogates with the unicode                                                 // 88\n// replacement character. See https://codereview.chromium.org/121173009/ .                                           // 89\nStringDecoder.prototype.write = function(buffer) {                                                                   // 90\n  var charStr = '';                                                                                                  // 91\n  // if our last write ended with an incomplete multibyte character                                                  // 92\n  while (this.charLength) {                                                                                          // 93\n    // determine how many remaining bytes this buffer has to offer for this char                                     // 94\n    var available = (buffer.length >= this.charLength - this.charReceived) ?                                         // 95\n        this.charLength - this.charReceived :                                                                        // 96\n        buffer.length;                                                                                               // 97\n                                                                                                                     // 98\n    // add the new bytes to the char buffer                                                                          // 99\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);                                                   // 100\n    this.charReceived += available;                                                                                  // 101\n                                                                                                                     // 102\n    if (this.charReceived < this.charLength) {                                                                       // 103\n      // still not enough chars in this buffer? wait for more ...                                                    // 104\n      return '';                                                                                                     // 105\n    }                                                                                                                // 106\n                                                                                                                     // 107\n    // remove bytes belonging to the current character from the buffer                                               // 108\n    buffer = buffer.slice(available, buffer.length);                                                                 // 109\n                                                                                                                     // 110\n    // get the character that was split                                                                              // 111\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);                                     // 112\n                                                                                                                     // 113\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character                                           // 114\n    var charCode = charStr.charCodeAt(charStr.length - 1);                                                           // 115\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {                                                                  // 116\n      this.charLength += this.surrogateSize;                                                                         // 117\n      charStr = '';                                                                                                  // 118\n      continue;                                                                                                      // 119\n    }                                                                                                                // 120\n    this.charReceived = this.charLength = 0;                                                                         // 121\n                                                                                                                     // 122\n    // if there are no more bytes in this buffer, just emit our char                                                 // 123\n    if (buffer.length === 0) {                                                                                       // 124\n      return charStr;                                                                                                // 125\n    }                                                                                                                // 126\n    break;                                                                                                           // 127\n  }                                                                                                                  // 128\n                                                                                                                     // 129\n  // determine and set charLength / charReceived                                                                     // 130\n  this.detectIncompleteChar(buffer);                                                                                 // 131\n                                                                                                                     // 132\n  var end = buffer.length;                                                                                           // 133\n  if (this.charLength) {                                                                                             // 134\n    // buffer the incomplete character bytes we got                                                                  // 135\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);                                         // 136\n    end -= this.charReceived;                                                                                        // 137\n  }                                                                                                                  // 138\n                                                                                                                     // 139\n  charStr += buffer.toString(this.encoding, 0, end);                                                                 // 140\n                                                                                                                     // 141\n  var end = charStr.length - 1;                                                                                      // 142\n  var charCode = charStr.charCodeAt(end);                                                                            // 143\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character                                             // 144\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {                                                                    // 145\n    var size = this.surrogateSize;                                                                                   // 146\n    this.charLength += size;                                                                                         // 147\n    this.charReceived += size;                                                                                       // 148\n    this.charBuffer.copy(this.charBuffer, size, 0, size);                                                            // 149\n    buffer.copy(this.charBuffer, 0, 0, size);                                                                        // 150\n    return charStr.substring(0, end);                                                                                // 151\n  }                                                                                                                  // 152\n                                                                                                                     // 153\n  // or just emit the charStr                                                                                        // 154\n  return charStr;                                                                                                    // 155\n};                                                                                                                   // 156\n                                                                                                                     // 157\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at                                      // 158\n// the end of the given buffer. If so, it sets this.charLength to the byte                                           // 159\n// length that character, and sets this.charReceived to the number of bytes                                          // 160\n// that are available for this character.                                                                            // 161\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {                                                    // 162\n  // determine how many bytes we have to check at the end of this buffer                                             // 163\n  var i = (buffer.length >= 3) ? 3 : buffer.length;                                                                  // 164\n                                                                                                                     // 165\n  // Figure out if one of the last i bytes of our buffer announces an                                                // 166\n  // incomplete char.                                                                                                // 167\n  for (; i > 0; i--) {                                                                                               // 168\n    var c = buffer[buffer.length - i];                                                                               // 169\n                                                                                                                     // 170\n    // See http://en.wikipedia.org/wiki/UTF-8#Description                                                            // 171\n                                                                                                                     // 172\n    // 110XXXXX                                                                                                      // 173\n    if (i == 1 && c >> 5 == 0x06) {                                                                                  // 174\n      this.charLength = 2;                                                                                           // 175\n      break;                                                                                                         // 176\n    }                                                                                                                // 177\n                                                                                                                     // 178\n    // 1110XXXX                                                                                                      // 179\n    if (i <= 2 && c >> 4 == 0x0E) {                                                                                  // 180\n      this.charLength = 3;                                                                                           // 181\n      break;                                                                                                         // 182\n    }                                                                                                                // 183\n                                                                                                                     // 184\n    // 11110XXX                                                                                                      // 185\n    if (i <= 3 && c >> 3 == 0x1E) {                                                                                  // 186\n      this.charLength = 4;                                                                                           // 187\n      break;                                                                                                         // 188\n    }                                                                                                                // 189\n  }                                                                                                                  // 190\n  this.charReceived = i;                                                                                             // 191\n};                                                                                                                   // 192\n                                                                                                                     // 193\nStringDecoder.prototype.end = function(buffer) {                                                                     // 194\n  var res = '';                                                                                                      // 195\n  if (buffer && buffer.length)                                                                                       // 196\n    res = this.write(buffer);                                                                                        // 197\n                                                                                                                     // 198\n  if (this.charReceived) {                                                                                           // 199\n    var cr = this.charReceived;                                                                                      // 200\n    var buf = this.charBuffer;                                                                                       // 201\n    var enc = this.encoding;                                                                                         // 202\n    res += buf.slice(0, cr).toString(enc);                                                                           // 203\n  }                                                                                                                  // 204\n                                                                                                                     // 205\n  return res;                                                                                                        // 206\n};                                                                                                                   // 207\n                                                                                                                     // 208\nfunction passThroughWrite(buffer) {                                                                                  // 209\n  return buffer.toString(this.encoding);                                                                             // 210\n}                                                                                                                    // 211\n                                                                                                                     // 212\nfunction utf16DetectIncompleteChar(buffer) {                                                                         // 213\n  this.charReceived = buffer.length % 2;                                                                             // 214\n  this.charLength = this.charReceived ? 2 : 0;                                                                       // 215\n}                                                                                                                    // 216\n                                                                                                                     // 217\nfunction base64DetectIncompleteChar(buffer) {                                                                        // 218\n  this.charReceived = buffer.length % 3;                                                                             // 219\n  this.charLength = this.charReceived ? 3 : 0;                                                                       // 220\n}                                                                                                                    // 221\n                                                                                                                     // 222\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"debug\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/debug/package.json                                                                                   //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"debug\";                                                                                              // 1\nexports.version = \"0.7.4\";                                                                                           // 2\nexports.main = \"./debug.js\";                                                                                         // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"debug.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/debug/debug.js                                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n                                                                                                                     // 1\n/**                                                                                                                  // 2\n * Expose `debug()` as the module.                                                                                   // 3\n */                                                                                                                  // 4\n                                                                                                                     // 5\nmodule.exports = debug;                                                                                              // 6\n                                                                                                                     // 7\n/**                                                                                                                  // 8\n * Create a debugger with the given `name`.                                                                          // 9\n *                                                                                                                   // 10\n * @param {String} name                                                                                              // 11\n * @return {Type}                                                                                                    // 12\n * @api public                                                                                                       // 13\n */                                                                                                                  // 14\n                                                                                                                     // 15\nfunction debug(name) {                                                                                               // 16\n  if (!debug.enabled(name)) return function(){};                                                                     // 17\n                                                                                                                     // 18\n  return function(fmt){                                                                                              // 19\n    fmt = coerce(fmt);                                                                                               // 20\n                                                                                                                     // 21\n    var curr = new Date;                                                                                             // 22\n    var ms = curr - (debug[name] || curr);                                                                           // 23\n    debug[name] = curr;                                                                                              // 24\n                                                                                                                     // 25\n    fmt = name                                                                                                       // 26\n      + ' '                                                                                                          // 27\n      + fmt                                                                                                          // 28\n      + ' +' + debug.humanize(ms);                                                                                   // 29\n                                                                                                                     // 30\n    // This hackery is required for IE8                                                                              // 31\n    // where `console.log` doesn't have 'apply'                                                                      // 32\n    window.console                                                                                                   // 33\n      && console.log                                                                                                 // 34\n      && Function.prototype.apply.call(console.log, console, arguments);                                             // 35\n  }                                                                                                                  // 36\n}                                                                                                                    // 37\n                                                                                                                     // 38\n/**                                                                                                                  // 39\n * The currently active debug mode names.                                                                            // 40\n */                                                                                                                  // 41\n                                                                                                                     // 42\ndebug.names = [];                                                                                                    // 43\ndebug.skips = [];                                                                                                    // 44\n                                                                                                                     // 45\n/**                                                                                                                  // 46\n * Enables a debug mode by name. This can include modes                                                              // 47\n * separated by a colon and wildcards.                                                                               // 48\n *                                                                                                                   // 49\n * @param {String} name                                                                                              // 50\n * @api public                                                                                                       // 51\n */                                                                                                                  // 52\n                                                                                                                     // 53\ndebug.enable = function(name) {                                                                                      // 54\n  try {                                                                                                              // 55\n    localStorage.debug = name;                                                                                       // 56\n  } catch(e){}                                                                                                       // 57\n                                                                                                                     // 58\n  var split = (name || '').split(/[\\s,]+/)                                                                           // 59\n    , len = split.length;                                                                                            // 60\n                                                                                                                     // 61\n  for (var i = 0; i < len; i++) {                                                                                    // 62\n    name = split[i].replace('*', '.*?');                                                                             // 63\n    if (name[0] === '-') {                                                                                           // 64\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));                                                      // 65\n    }                                                                                                                // 66\n    else {                                                                                                           // 67\n      debug.names.push(new RegExp('^' + name + '$'));                                                                // 68\n    }                                                                                                                // 69\n  }                                                                                                                  // 70\n};                                                                                                                   // 71\n                                                                                                                     // 72\n/**                                                                                                                  // 73\n * Disable debug output.                                                                                             // 74\n *                                                                                                                   // 75\n * @api public                                                                                                       // 76\n */                                                                                                                  // 77\n                                                                                                                     // 78\ndebug.disable = function(){                                                                                          // 79\n  debug.enable('');                                                                                                  // 80\n};                                                                                                                   // 81\n                                                                                                                     // 82\n/**                                                                                                                  // 83\n * Humanize the given `ms`.                                                                                          // 84\n *                                                                                                                   // 85\n * @param {Number} m                                                                                                 // 86\n * @return {String}                                                                                                  // 87\n * @api private                                                                                                      // 88\n */                                                                                                                  // 89\n                                                                                                                     // 90\ndebug.humanize = function(ms) {                                                                                      // 91\n  var sec = 1000                                                                                                     // 92\n    , min = 60 * 1000                                                                                                // 93\n    , hour = 60 * min;                                                                                               // 94\n                                                                                                                     // 95\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';                                                               // 96\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';                                                                 // 97\n  if (ms >= sec) return (ms / sec | 0) + 's';                                                                        // 98\n  return ms + 'ms';                                                                                                  // 99\n};                                                                                                                   // 100\n                                                                                                                     // 101\n/**                                                                                                                  // 102\n * Returns true if the given mode name is enabled, false otherwise.                                                  // 103\n *                                                                                                                   // 104\n * @param {String} name                                                                                              // 105\n * @return {Boolean}                                                                                                 // 106\n * @api public                                                                                                       // 107\n */                                                                                                                  // 108\n                                                                                                                     // 109\ndebug.enabled = function(name) {                                                                                     // 110\n  for (var i = 0, len = debug.skips.length; i < len; i++) {                                                          // 111\n    if (debug.skips[i].test(name)) {                                                                                 // 112\n      return false;                                                                                                  // 113\n    }                                                                                                                // 114\n  }                                                                                                                  // 115\n  for (var i = 0, len = debug.names.length; i < len; i++) {                                                          // 116\n    if (debug.names[i].test(name)) {                                                                                 // 117\n      return true;                                                                                                   // 118\n    }                                                                                                                // 119\n  }                                                                                                                  // 120\n  return false;                                                                                                      // 121\n};                                                                                                                   // 122\n                                                                                                                     // 123\n/**                                                                                                                  // 124\n * Coerce `val`.                                                                                                     // 125\n */                                                                                                                  // 126\n                                                                                                                     // 127\nfunction coerce(val) {                                                                                               // 128\n  if (val instanceof Error) return val.stack || val.message;                                                         // 129\n  return val;                                                                                                        // 130\n}                                                                                                                    // 131\n                                                                                                                     // 132\n// persist                                                                                                           // 133\n                                                                                                                     // 134\ntry {                                                                                                                // 135\n  if (window.localStorage) debug.enable(localStorage.debug);                                                         // 136\n} catch(e){}                                                                                                         // 137\n                                                                                                                     // 138\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"split-ca\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/split-ca/package.json                                                                                //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"split-ca\";                                                                                           // 1\nexports.version = \"1.0.1\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"fs\",\"meteor-node-stubs/deps/fs\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/split-ca/index.js                                                                                    //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar fs = require('fs');                                                                                              // 1\n                                                                                                                     // 2\nmodule.exports = function (filepath, split, encoding) {                                                              // 3\n  split = typeof split !== 'undefined' ? split : \"\\n\";                                                               // 4\n  encoding = typeof encoding !== 'undefined' ? encoding : \"utf8\";                                                    // 5\n                                                                                                                     // 6\n  var ca = [];                                                                                                       // 7\n  var chain = fs.readFileSync(filepath, encoding);                                                                   // 8\n  if(chain.indexOf(\"-END CERTIFICATE-\") < 0 || chain.indexOf(\"-BEGIN CERTIFICATE-\") < 0){                            // 9\n    throw Error(\"File does not contain 'BEGIN CERTIFICATE' or 'END CERTIFICATE'\");                                   // 10\n  }                                                                                                                  // 11\n  chain = chain.split(split);                                                                                        // 12\n  var cert = [];                                                                                                     // 13\n  var _i, _len;                                                                                                      // 14\n  for (_i = 0, _len = chain.length; _i < _len; _i++) {                                                               // 15\n    var line = chain[_i];                                                                                            // 16\n    if (!(line.length !== 0)) {                                                                                      // 17\n      continue;                                                                                                      // 18\n    }                                                                                                                // 19\n    cert.push(line);                                                                                                 // 20\n    if (line.match(/-END CERTIFICATE-/)) {                                                                           // 21\n      ca.push(cert.join(split));                                                                                     // 22\n      cert = [];                                                                                                     // 23\n    }                                                                                                                // 24\n  }                                                                                                                  // 25\n  return ca;                                                                                                         // 26\n}                                                                                                                    // 27\n                                                                                                                     // 28\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"JSONStream\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/JSONStream/package.json                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"JSONStream\";                                                                                         // 1\nexports.version = \"0.10.0\";                                                                                          // 2\n                                                                                                                     // 3\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"jsonparse\",\"through\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/JSONStream/index.js                                                                                  //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n                                                                                                                     // 1\n                                                                                                                     // 2\nvar Parser = require('jsonparse')                                                                                    // 3\n  , through = require('through')                                                                                     // 4\n                                                                                                                     // 5\n/*                                                                                                                   // 6\n                                                                                                                     // 7\n  the value of this.stack that creationix's jsonparse has is weird.                                                  // 8\n                                                                                                                     // 9\n  it makes this code ugly, but his problem is way harder that mine,                                                  // 10\n  so i'll forgive him.                                                                                               // 11\n                                                                                                                     // 12\n*/                                                                                                                   // 13\n                                                                                                                     // 14\nexports.parse = function (path, map) {                                                                               // 15\n                                                                                                                     // 16\n  var parser = new Parser()                                                                                          // 17\n  var stream = through(function (chunk) {                                                                            // 18\n    if('string' === typeof chunk)                                                                                    // 19\n      chunk = new Buffer(chunk)                                                                                      // 20\n    parser.write(chunk)                                                                                              // 21\n  },                                                                                                                 // 22\n  function (data) {                                                                                                  // 23\n    if(data)                                                                                                         // 24\n      stream.write(data)                                                                                             // 25\n    stream.queue(null)                                                                                               // 26\n  })                                                                                                                 // 27\n                                                                                                                     // 28\n  if('string' === typeof path)                                                                                       // 29\n    path = path.split('.').map(function (e) {                                                                        // 30\n      if (e === '*')                                                                                                 // 31\n        return true                                                                                                  // 32\n      else if (e === '') // '..'.split('.') returns an empty string                                                  // 33\n        return {recurse: true}                                                                                       // 34\n      else                                                                                                           // 35\n        return e                                                                                                     // 36\n    })                                                                                                               // 37\n                                                                                                                     // 38\n                                                                                                                     // 39\n  var count = 0, _key                                                                                                // 40\n  if(!path || !path.length)                                                                                          // 41\n    path = null                                                                                                      // 42\n                                                                                                                     // 43\n  parser.onValue = function (value) {                                                                                // 44\n    if (!this.root)                                                                                                  // 45\n      stream.root = value                                                                                            // 46\n                                                                                                                     // 47\n    if(! path) return                                                                                                // 48\n                                                                                                                     // 49\n    var i = 0 // iterates on path                                                                                    // 50\n    var j  = 0 // iterates on stack                                                                                  // 51\n    while (i < path.length) {                                                                                        // 52\n      var key = path[i]                                                                                              // 53\n      var c                                                                                                          // 54\n      j++                                                                                                            // 55\n                                                                                                                     // 56\n      if (key && !key.recurse) {                                                                                     // 57\n        c = (j === this.stack.length) ? this : this.stack[j]                                                         // 58\n        if (!c) return                                                                                               // 59\n        if (! check(key, c.key)) return                                                                              // 60\n        i++                                                                                                          // 61\n      } else {                                                                                                       // 62\n        i++                                                                                                          // 63\n        var nextKey = path[i]                                                                                        // 64\n        if (! nextKey) return                                                                                        // 65\n        while (true) {                                                                                               // 66\n          c = (j === this.stack.length) ? this : this.stack[j]                                                       // 67\n          if (!c) return                                                                                             // 68\n          if (check(nextKey, c.key)) { i++; break}                                                                   // 69\n          j++                                                                                                        // 70\n        }                                                                                                            // 71\n      }                                                                                                              // 72\n    }                                                                                                                // 73\n    if (j !== this.stack.length) return                                                                              // 74\n                                                                                                                     // 75\n    count ++                                                                                                         // 76\n    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])            // 77\n    var data = this.value[this.key]                                                                                  // 78\n    if(null != data)                                                                                                 // 79\n      if(null != (data = map ? map(data, actualPath) : data))                                                        // 80\n        stream.queue(data)                                                                                           // 81\n    delete this.value[this.key]                                                                                      // 82\n  }                                                                                                                  // 83\n  parser._onToken = parser.onToken;                                                                                  // 84\n                                                                                                                     // 85\n  parser.onToken = function (token, value) {                                                                         // 86\n    parser._onToken(token, value);                                                                                   // 87\n    if (this.stack.length === 0) {                                                                                   // 88\n      if (stream.root) {                                                                                             // 89\n        if(!path)                                                                                                    // 90\n          stream.queue(stream.root)                                                                                  // 91\n        stream.emit('root', stream.root, count)                                                                      // 92\n        count = 0;                                                                                                   // 93\n        stream.root = null;                                                                                          // 94\n      }                                                                                                              // 95\n    }                                                                                                                // 96\n  }                                                                                                                  // 97\n                                                                                                                     // 98\n  parser.onError = function (err) {                                                                                  // 99\n    stream.emit('error', err)                                                                                        // 100\n  }                                                                                                                  // 101\n                                                                                                                     // 102\n                                                                                                                     // 103\n  return stream                                                                                                      // 104\n}                                                                                                                    // 105\n                                                                                                                     // 106\nfunction check (x, y) {                                                                                              // 107\n  if ('string' === typeof x)                                                                                         // 108\n    return y == x                                                                                                    // 109\n  else if (x && 'function' === typeof x.exec)                                                                        // 110\n    return x.exec(y)                                                                                                 // 111\n  else if ('boolean' === typeof x)                                                                                   // 112\n    return x                                                                                                         // 113\n  else if ('function' === typeof x)                                                                                  // 114\n    return x(y)                                                                                                      // 115\n  return false                                                                                                       // 116\n}                                                                                                                    // 117\n                                                                                                                     // 118\nexports.stringify = function (op, sep, cl, indent) {                                                                 // 119\n  indent = indent || 0                                                                                               // 120\n  if (op === false){                                                                                                 // 121\n    op = ''                                                                                                          // 122\n    sep = '\\n'                                                                                                       // 123\n    cl = ''                                                                                                          // 124\n  } else if (op == null) {                                                                                           // 125\n                                                                                                                     // 126\n    op = '[\\n'                                                                                                       // 127\n    sep = '\\n,\\n'                                                                                                    // 128\n    cl = '\\n]\\n'                                                                                                     // 129\n                                                                                                                     // 130\n  }                                                                                                                  // 131\n                                                                                                                     // 132\n  //else, what ever you like                                                                                         // 133\n                                                                                                                     // 134\n  var stream                                                                                                         // 135\n    , first = true                                                                                                   // 136\n    , anyData = false                                                                                                // 137\n  stream = through(function (data) {                                                                                 // 138\n    anyData = true                                                                                                   // 139\n    var json = JSON.stringify(data, null, indent)                                                                    // 140\n    if(first) { first = false ; stream.queue(op + json)}                                                             // 141\n    else stream.queue(sep + json)                                                                                    // 142\n  },                                                                                                                 // 143\n  function (data) {                                                                                                  // 144\n    if(!anyData)                                                                                                     // 145\n      stream.queue(op)                                                                                               // 146\n    stream.queue(cl)                                                                                                 // 147\n    stream.queue(null)                                                                                               // 148\n  })                                                                                                                 // 149\n                                                                                                                     // 150\n  return stream                                                                                                      // 151\n}                                                                                                                    // 152\n                                                                                                                     // 153\nexports.stringifyObject = function (op, sep, cl, indent) {                                                           // 154\n  indent = indent || 0                                                                                               // 155\n  if (op === false){                                                                                                 // 156\n    op = ''                                                                                                          // 157\n    sep = '\\n'                                                                                                       // 158\n    cl = ''                                                                                                          // 159\n  } else if (op == null) {                                                                                           // 160\n                                                                                                                     // 161\n    op = '{\\n'                                                                                                       // 162\n    sep = '\\n,\\n'                                                                                                    // 163\n    cl = '\\n}\\n'                                                                                                     // 164\n                                                                                                                     // 165\n  }                                                                                                                  // 166\n                                                                                                                     // 167\n  //else, what ever you like                                                                                         // 168\n                                                                                                                     // 169\n  var first = true                                                                                                   // 170\n    , anyData = false                                                                                                // 171\n  stream = through(function (data) {                                                                                 // 172\n    anyData = true                                                                                                   // 173\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)                                 // 174\n    if(first) { first = false ; this.queue(op + json)}                                                               // 175\n    else this.queue(sep + json)                                                                                      // 176\n  },                                                                                                                 // 177\n  function (data) {                                                                                                  // 178\n    if(!anyData) this.queue(op)                                                                                      // 179\n    this.queue(cl)                                                                                                   // 180\n                                                                                                                     // 181\n    this.queue(null)                                                                                                 // 182\n  })                                                                                                                 // 183\n                                                                                                                     // 184\n  return stream                                                                                                      // 185\n}                                                                                                                    // 186\n                                                                                                                     // 187\nif(!module.parent && process.title !== 'browser') {                                                                  // 188\n  process.stdin                                                                                                      // 189\n    .pipe(exports.parse(process.argv[2]))                                                                            // 190\n    .pipe(exports.stringify('[', ',\\n', ']\\n', 2))                                                                   // 191\n    .pipe(process.stdout)                                                                                            // 192\n}                                                                                                                    // 193\n                                                                                                                     // 194\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]},\"jsonparse\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/jsonparse/package.json                                                                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"jsonparse\";                                                                                          // 1\nexports.version = \"0.0.5\";                                                                                           // 2\nexports.main = \"jsonparse.js\";                                                                                       // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"jsonparse.js\":function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/jsonparse/jsonparse.js                                                                               //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/*global Buffer*/                                                                                                    // 1\n// Named constants with unique integer values                                                                        // 2\nvar C = {};                                                                                                          // 3\n// Tokens                                                                                                            // 4\nvar LEFT_BRACE    = C.LEFT_BRACE    = 0x1;                                                                           // 5\nvar RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;                                                                           // 6\nvar LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;                                                                           // 7\nvar RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;                                                                           // 8\nvar COLON         = C.COLON         = 0x5;                                                                           // 9\nvar COMMA         = C.COMMA         = 0x6;                                                                           // 10\nvar TRUE          = C.TRUE          = 0x7;                                                                           // 11\nvar FALSE         = C.FALSE         = 0x8;                                                                           // 12\nvar NULL          = C.NULL          = 0x9;                                                                           // 13\nvar STRING        = C.STRING        = 0xa;                                                                           // 14\nvar NUMBER        = C.NUMBER        = 0xb;                                                                           // 15\n// Tokenizer States                                                                                                  // 16\nvar START   = C.START   = 0x11;                                                                                      // 17\nvar TRUE1   = C.TRUE1   = 0x21;                                                                                      // 18\nvar TRUE2   = C.TRUE2   = 0x22;                                                                                      // 19\nvar TRUE3   = C.TRUE3   = 0x23;                                                                                      // 20\nvar FALSE1  = C.FALSE1  = 0x31;                                                                                      // 21\nvar FALSE2  = C.FALSE2  = 0x32;                                                                                      // 22\nvar FALSE3  = C.FALSE3  = 0x33;                                                                                      // 23\nvar FALSE4  = C.FALSE4  = 0x34;                                                                                      // 24\nvar NULL1   = C.NULL1   = 0x41;                                                                                      // 25\nvar NULL2   = C.NULL3   = 0x42;                                                                                      // 26\nvar NULL3   = C.NULL2   = 0x43;                                                                                      // 27\nvar NUMBER1 = C.NUMBER1 = 0x51;                                                                                      // 28\nvar NUMBER2 = C.NUMBER2 = 0x52;                                                                                      // 29\nvar NUMBER3 = C.NUMBER3 = 0x53;                                                                                      // 30\nvar NUMBER4 = C.NUMBER4 = 0x54;                                                                                      // 31\nvar NUMBER5 = C.NUMBER5 = 0x55;                                                                                      // 32\nvar NUMBER6 = C.NUMBER6 = 0x56;                                                                                      // 33\nvar NUMBER7 = C.NUMBER7 = 0x57;                                                                                      // 34\nvar NUMBER8 = C.NUMBER8 = 0x58;                                                                                      // 35\nvar STRING1 = C.STRING1 = 0x61;                                                                                      // 36\nvar STRING2 = C.STRING2 = 0x62;                                                                                      // 37\nvar STRING3 = C.STRING3 = 0x63;                                                                                      // 38\nvar STRING4 = C.STRING4 = 0x64;                                                                                      // 39\nvar STRING5 = C.STRING5 = 0x65;                                                                                      // 40\nvar STRING6 = C.STRING6 = 0x66;                                                                                      // 41\n// Parser States                                                                                                     // 42\nvar VALUE   = C.VALUE   = 0x71;                                                                                      // 43\nvar KEY     = C.KEY     = 0x72;                                                                                      // 44\n// Parser Modes                                                                                                      // 45\nvar OBJECT  = C.OBJECT  = 0x81;                                                                                      // 46\nvar ARRAY   = C.ARRAY   = 0x82;                                                                                      // 47\n                                                                                                                     // 48\n// Slow code to string converter (only used when throwing syntax errors)                                             // 49\nfunction toknam(code) {                                                                                              // 50\n  var keys = Object.keys(C);                                                                                         // 51\n  for (var i = 0, l = keys.length; i < l; i++) {                                                                     // 52\n    var key = keys[i];                                                                                               // 53\n    if (C[key] === code) { return key; }                                                                             // 54\n  }                                                                                                                  // 55\n  return code && (\"0x\" + code.toString(16));                                                                         // 56\n}                                                                                                                    // 57\n                                                                                                                     // 58\n                                                                                                                     // 59\nfunction Parser() {                                                                                                  // 60\n  this.tState = START;                                                                                               // 61\n  this.value = undefined;                                                                                            // 62\n                                                                                                                     // 63\n  this.string = undefined; // string data                                                                            // 64\n  this.unicode = undefined; // unicode escapes                                                                       // 65\n                                                                                                                     // 66\n  // For number parsing                                                                                              // 67\n  this.negative = undefined;                                                                                         // 68\n  this.magnatude = undefined;                                                                                        // 69\n  this.position = undefined;                                                                                         // 70\n  this.exponent = undefined;                                                                                         // 71\n  this.negativeExponent = undefined;                                                                                 // 72\n                                                                                                                     // 73\n  this.key = undefined;                                                                                              // 74\n  this.mode = undefined;                                                                                             // 75\n  this.stack = [];                                                                                                   // 76\n  this.state = VALUE;                                                                                                // 77\n  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary        // 78\n  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read                                               // 79\n  this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n}                                                                                                                    // 81\nvar proto = Parser.prototype;                                                                                        // 82\nproto.charError = function (buffer, i) {                                                                             // 83\n  this.onError(new Error(\"Unexpected \" + JSON.stringify(String.fromCharCode(buffer[i])) + \" at position \" + i + \" in state \" + toknam(this.tState)));\n};                                                                                                                   // 85\nproto.onError = function (err) { throw err; };                                                                       // 86\nproto.write = function (buffer) {                                                                                    // 87\n  if (typeof buffer === \"string\") buffer = new Buffer(buffer);                                                       // 88\n  //process.stdout.write(\"Input: \");                                                                                 // 89\n  //console.dir(buffer.toString());                                                                                  // 90\n  var n;                                                                                                             // 91\n  for (var i = 0, l = buffer.length; i < l; i++) {                                                                   // 92\n    if (this.tState === START){                                                                                      // 93\n      n = buffer[i];                                                                                                 // 94\n      if(n === 0x7b){ this.onToken(LEFT_BRACE, \"{\"); // {                                                            // 95\n      }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, \"}\"); // }                                                     // 96\n      }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, \"[\"); // [                                                    // 97\n      }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, \"]\"); // ]                                                   // 98\n      }else if(n === 0x3a){ this.onToken(COLON, \":\");  // :                                                          // 99\n      }else if(n === 0x2c){ this.onToken(COMMA, \",\"); // ,                                                           // 100\n      }else if(n === 0x74){ this.tState = TRUE1;  // t                                                               // 101\n      }else if(n === 0x66){ this.tState = FALSE1;  // f                                                              // 102\n      }else if(n === 0x6e){ this.tState = NULL1; // n                                                                // 103\n      }else if(n === 0x22){ this.string = \"\"; this.tState = STRING1; // \"                                            // 104\n      }else if(n === 0x2d){ this.negative = true; this.tState = NUMBER1; // -                                        // 105\n      }else if(n === 0x30){ this.magnatude = 0; this.tState = NUMBER2; // 0                                          // 106\n      }else{                                                                                                         // 107\n        if (n > 0x30 && n < 0x40) { // 1-9                                                                           // 108\n          this.magnatude = n - 0x30; this.tState = NUMBER3;                                                          // 109\n        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {                                           // 110\n          // whitespace                                                                                              // 111\n        } else { this.charError(buffer, i); }                                                                        // 112\n      }                                                                                                              // 113\n    }else if (this.tState === STRING1){ // After open quote                                                          // 114\n      n = buffer[i]; // get current byte from buffer                                                                 // 115\n      // check for carry over of a multi byte char split between data chunks                                         // 116\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration      // 117\n      if (this.bytes_remaining > 0) {                                                                                // 118\n        for (var j = 0; j < this.bytes_remaining; j++) {                                                             // 119\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];    // 120\n        }                                                                                                            // 121\n        this.string += this.temp_buffs[this.bytes_in_sequence].toString();                                           // 122\n        this.bytes_in_sequence = this.bytes_remaining = 0;                                                           // 123\n        i = i + j - 1;                                                                                               // 124\n      } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;                                                    // 126\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;                                                    // 127\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;                                                    // 128\n        if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split\n          for (var k = 0; k <= (buffer.length - 1 - i); k++) {                                                       // 130\n            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk\n          }                                                                                                          // 132\n          this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;                                       // 133\n          i = buffer.length - 1;                                                                                     // 134\n        } else {                                                                                                     // 135\n          this.string += buffer.slice(i, (i + this.bytes_in_sequence)).toString();                                   // 136\n          i = i + this.bytes_in_sequence - 1;                                                                        // 137\n        }                                                                                                            // 138\n      } else if (n === 0x22) { this.tState = START; this.onToken(STRING, this.string); this.string = undefined; }    // 139\n      else if (n === 0x5c) { this.tState = STRING2; }                                                                // 140\n      else if (n >= 0x20) { this.string += String.fromCharCode(n); }                                                 // 141\n      else { this.charError(buffer, i); }                                                                            // 142\n    }else if (this.tState === STRING2){ // After backslash                                                           // 143\n      n = buffer[i];                                                                                                 // 144\n      if(n === 0x22){ this.string += \"\\\"\"; this.tState = STRING1;                                                    // 145\n      }else if(n === 0x5c){ this.string += \"\\\\\"; this.tState = STRING1;                                              // 146\n      }else if(n === 0x2f){ this.string += \"\\/\"; this.tState = STRING1;                                              // 147\n      }else if(n === 0x62){ this.string += \"\\b\"; this.tState = STRING1;                                              // 148\n      }else if(n === 0x66){ this.string += \"\\f\"; this.tState = STRING1;                                              // 149\n      }else if(n === 0x6e){ this.string += \"\\n\"; this.tState = STRING1;                                              // 150\n      }else if(n === 0x72){ this.string += \"\\r\"; this.tState = STRING1;                                              // 151\n      }else if(n === 0x74){ this.string += \"\\t\"; this.tState = STRING1;                                              // 152\n      }else if(n === 0x75){ this.unicode = \"\"; this.tState = STRING3;                                                // 153\n      }else{                                                                                                         // 154\n        this.charError(buffer, i);                                                                                   // 155\n      }                                                                                                              // 156\n    }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes\n      n = buffer[i];                                                                                                 // 158\n      // 0-9 A-F a-f                                                                                                 // 159\n      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {                           // 160\n        this.unicode += String.fromCharCode(n);                                                                      // 161\n        if (this.tState++ === STRING6) {                                                                             // 162\n          this.string += String.fromCharCode(parseInt(this.unicode, 16));                                            // 163\n          this.unicode = undefined;                                                                                  // 164\n          this.tState = STRING1;                                                                                     // 165\n        }                                                                                                            // 166\n      } else {                                                                                                       // 167\n        this.charError(buffer, i);                                                                                   // 168\n      }                                                                                                              // 169\n    }else if (this.tState === NUMBER1){ // after minus                                                               // 170\n      n = buffer[i];                                                                                                 // 171\n      if (n === 0x30) { this.magnatude = 0; this.tState = NUMBER2; }                                                 // 172\n      else if (n > 0x30 && n < 0x40) { this.magnatude = n - 0x30; this.tState = NUMBER3; }                           // 173\n      else { this.charError(buffer, i); }                                                                            // 174\n    }else if (this.tState === NUMBER2){ // * After initial zero                                                      // 175\n      n = buffer[i];                                                                                                 // 176\n      if(n === 0x2e){ // .                                                                                           // 177\n        this.position = 0.1; this.tState = NUMBER4;                                                                  // 178\n      }else if(n === 0x65 ||  n === 0x45){ // e/E                                                                    // 179\n        this.exponent = 0; this.tState = NUMBER6;                                                                    // 180\n      }else{                                                                                                         // 181\n        this.tState = START;                                                                                         // 182\n        this.onToken(NUMBER, 0);                                                                                     // 183\n        this.magnatude = undefined;                                                                                  // 184\n        this.negative = undefined;                                                                                   // 185\n        i--;                                                                                                         // 186\n      }                                                                                                              // 187\n    }else if (this.tState === NUMBER3){ // * After digit (before period)                                             // 188\n      n = buffer[i];                                                                                                 // 189\n      if(n === 0x2e){ // .                                                                                           // 190\n        this.position = 0.1; this.tState = NUMBER4;                                                                  // 191\n      }else if(n === 0x65 || n === 0x45){ // e/E                                                                     // 192\n        this.exponent = 0; this.tState = NUMBER6;                                                                    // 193\n      }else{                                                                                                         // 194\n        if (n >= 0x30 && n < 0x40) { this.magnatude = this.magnatude * 10 + n - 0x30; }                              // 195\n        else {                                                                                                       // 196\n          this.tState = START;                                                                                       // 197\n          if (this.negative) {                                                                                       // 198\n            this.magnatude = -this.magnatude;                                                                        // 199\n            this.negative = undefined;                                                                               // 200\n          }                                                                                                          // 201\n          this.onToken(NUMBER, this.magnatude);                                                                      // 202\n          this.magnatude = undefined;                                                                                // 203\n          i--;                                                                                                       // 204\n        }                                                                                                            // 205\n      }                                                                                                              // 206\n    }else if (this.tState === NUMBER4){ // After period                                                              // 207\n      n = buffer[i];                                                                                                 // 208\n      if (n >= 0x30 && n < 0x40) { // 0-9                                                                            // 209\n        this.magnatude += this.position * (n - 0x30);                                                                // 210\n        this.position /= 10;                                                                                         // 211\n        this.tState = NUMBER5;                                                                                       // 212\n      } else { this.charError(buffer, i); }                                                                          // 213\n    }else if (this.tState === NUMBER5){ // * After digit (after period)                                              // 214\n      n = buffer[i];                                                                                                 // 215\n      if (n >= 0x30 && n < 0x40) { // 0-9                                                                            // 216\n        this.magnatude += this.position * (n - 0x30);                                                                // 217\n        this.position /= 10;                                                                                         // 218\n      }                                                                                                              // 219\n      else if (n === 0x65 || n === 0x45) { this.exponent = 0; this.tState = NUMBER6; } // E/e                        // 220\n      else {                                                                                                         // 221\n        this.tState = START;                                                                                         // 222\n        if (this.negative) {                                                                                         // 223\n          this.magnatude = -this.magnatude;                                                                          // 224\n          this.negative = undefined;                                                                                 // 225\n        }                                                                                                            // 226\n        this.onToken(NUMBER, this.negative ? -this.magnatude : this.magnatude);                                      // 227\n        this.magnatude = undefined;                                                                                  // 228\n        this.position = undefined;                                                                                   // 229\n        i--;                                                                                                         // 230\n      }                                                                                                              // 231\n    }else if (this.tState === NUMBER6){ // After E                                                                   // 232\n      n = buffer[i];                                                                                                 // 233\n      if (n === 0x2b || n === 0x2d) { // +/-                                                                         // 234\n        if (n === 0x2d) { this.negativeExponent = true; }                                                            // 235\n        this.tState = NUMBER7;                                                                                       // 236\n      }                                                                                                              // 237\n      else if (n >= 0x30 && n < 0x40) {                                                                              // 238\n        this.exponent = this.exponent * 10 + (n - 0x30);                                                             // 239\n        this.tState = NUMBER8;                                                                                       // 240\n      }                                                                                                              // 241\n      else { this.charError(buffer, i); }                                                                            // 242\n    }else if (this.tState === NUMBER7){ // After +/-                                                                 // 243\n      n = buffer[i];                                                                                                 // 244\n      if (n >= 0x30 && n < 0x40) { // 0-9                                                                            // 245\n        this.exponent = this.exponent * 10 + (n - 0x30);                                                             // 246\n        this.tState = NUMBER8;                                                                                       // 247\n      }                                                                                                              // 248\n      else { this.charError(buffer, i); }                                                                            // 249\n    }else if (this.tState === NUMBER8){ // * After digit (after +/-)                                                 // 250\n      n = buffer[i];                                                                                                 // 251\n      if (n >= 0x30 && n < 0x40) { // 0-9                                                                            // 252\n        this.exponent = this.exponent * 10 + (n - 0x30);                                                             // 253\n      }                                                                                                              // 254\n      else {                                                                                                         // 255\n        if (this.negativeExponent) {                                                                                 // 256\n          this.exponent = -this.exponent;                                                                            // 257\n          this.negativeExponent = undefined;                                                                         // 258\n        }                                                                                                            // 259\n        this.magnatude *= Math.pow(10, this.exponent);                                                               // 260\n        this.exponent = undefined;                                                                                   // 261\n        if (this.negative) {                                                                                         // 262\n          this.magnatude = -this.magnatude;                                                                          // 263\n          this.negative = undefined;                                                                                 // 264\n        }                                                                                                            // 265\n        this.tState = START;                                                                                         // 266\n        this.onToken(NUMBER, this.magnatude);                                                                        // 267\n        this.magnatude = undefined;                                                                                  // 268\n        i--;                                                                                                         // 269\n      }                                                                                                              // 270\n    }else if (this.tState === TRUE1){ // r                                                                           // 271\n      if (buffer[i] === 0x72) { this.tState = TRUE2; }                                                               // 272\n      else { this.charError(buffer, i); }                                                                            // 273\n    }else if (this.tState === TRUE2){ // u                                                                           // 274\n      if (buffer[i] === 0x75) { this.tState = TRUE3; }                                                               // 275\n      else { this.charError(buffer, i); }                                                                            // 276\n    }else if (this.tState === TRUE3){ // e                                                                           // 277\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); }                                     // 278\n      else { this.charError(buffer, i); }                                                                            // 279\n    }else if (this.tState === FALSE1){ // a                                                                          // 280\n      if (buffer[i] === 0x61) { this.tState = FALSE2; }                                                              // 281\n      else { this.charError(buffer, i); }                                                                            // 282\n    }else if (this.tState === FALSE2){ // l                                                                          // 283\n      if (buffer[i] === 0x6c) { this.tState = FALSE3; }                                                              // 284\n      else { this.charError(buffer, i); }                                                                            // 285\n    }else if (this.tState === FALSE3){ // s                                                                          // 286\n      if (buffer[i] === 0x73) { this.tState = FALSE4; }                                                              // 287\n      else { this.charError(buffer, i); }                                                                            // 288\n    }else if (this.tState === FALSE4){ // e                                                                          // 289\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); }                                   // 290\n      else { this.charError(buffer, i); }                                                                            // 291\n    }else if (this.tState === NULL1){ // u                                                                           // 292\n      if (buffer[i] === 0x75) { this.tState = NULL2; }                                                               // 293\n      else { this.charError(buffer, i); }                                                                            // 294\n    }else if (this.tState === NULL2){ // l                                                                           // 295\n      if (buffer[i] === 0x6c) { this.tState = NULL3; }                                                               // 296\n      else { this.charError(buffer, i); }                                                                            // 297\n    }else if (this.tState === NULL3){ // l                                                                           // 298\n      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); }                                     // 299\n      else { this.charError(buffer, i); }                                                                            // 300\n    }                                                                                                                // 301\n  }                                                                                                                  // 302\n};                                                                                                                   // 303\nproto.onToken = function (token, value) {                                                                            // 304\n  // Override this to get events                                                                                     // 305\n};                                                                                                                   // 306\n                                                                                                                     // 307\nproto.parseError = function (token, value) {                                                                         // 308\n  this.onError(new Error(\"Unexpected \" + toknam(token) + (value ? (\"(\" + JSON.stringify(value) + \")\") : \"\") + \" in state \" + toknam(this.state)));\n};                                                                                                                   // 310\nproto.onError = function (err) { throw err; };                                                                       // 311\nproto.push = function () {                                                                                           // 312\n  this.stack.push({value: this.value, key: this.key, mode: this.mode});                                              // 313\n};                                                                                                                   // 314\nproto.pop = function () {                                                                                            // 315\n  var value = this.value;                                                                                            // 316\n  var parent = this.stack.pop();                                                                                     // 317\n  this.value = parent.value;                                                                                         // 318\n  this.key = parent.key;                                                                                             // 319\n  this.mode = parent.mode;                                                                                           // 320\n  this.emit(value);                                                                                                  // 321\n  if (!this.mode) { this.state = VALUE; }                                                                            // 322\n};                                                                                                                   // 323\nproto.emit = function (value) {                                                                                      // 324\n  if (this.mode) { this.state = COMMA; }                                                                             // 325\n  this.onValue(value);                                                                                               // 326\n};                                                                                                                   // 327\nproto.onValue = function (value) {                                                                                   // 328\n  // Override me                                                                                                     // 329\n};                                                                                                                   // 330\nproto.onToken = function (token, value) {                                                                            // 331\n  //console.log(\"OnToken: state=%s token=%s %s\", toknam(this.state), toknam(token), value?JSON.stringify(value):\"\");\n  if(this.state === VALUE){                                                                                          // 333\n    if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){                 // 334\n      if (this.value) {                                                                                              // 335\n        this.value[this.key] = value;                                                                                // 336\n      }                                                                                                              // 337\n      this.emit(value);                                                                                              // 338\n    }else if(token === LEFT_BRACE){                                                                                  // 339\n      this.push();                                                                                                   // 340\n      if (this.value) {                                                                                              // 341\n        this.value = this.value[this.key] = {};                                                                      // 342\n      } else {                                                                                                       // 343\n        this.value = {};                                                                                             // 344\n      }                                                                                                              // 345\n      this.key = undefined;                                                                                          // 346\n      this.state = KEY;                                                                                              // 347\n      this.mode = OBJECT;                                                                                            // 348\n    }else if(token === LEFT_BRACKET){                                                                                // 349\n      this.push();                                                                                                   // 350\n      if (this.value) {                                                                                              // 351\n        this.value = this.value[this.key] = [];                                                                      // 352\n      } else {                                                                                                       // 353\n        this.value = [];                                                                                             // 354\n      }                                                                                                              // 355\n      this.key = 0;                                                                                                  // 356\n      this.mode = ARRAY;                                                                                             // 357\n      this.state = VALUE;                                                                                            // 358\n    }else if(token === RIGHT_BRACE){                                                                                 // 359\n      if (this.mode === OBJECT) {                                                                                    // 360\n        this.pop();                                                                                                  // 361\n      } else {                                                                                                       // 362\n        this.parseError(token, value);                                                                               // 363\n      }                                                                                                              // 364\n    }else if(token === RIGHT_BRACKET){                                                                               // 365\n      if (this.mode === ARRAY) {                                                                                     // 366\n        this.pop();                                                                                                  // 367\n      } else {                                                                                                       // 368\n        this.parseError(token, value);                                                                               // 369\n      }                                                                                                              // 370\n    }else{                                                                                                           // 371\n      this.parseError(token, value);                                                                                 // 372\n    }                                                                                                                // 373\n  }else if(this.state === KEY){                                                                                      // 374\n    if (token === STRING) {                                                                                          // 375\n      this.key = value;                                                                                              // 376\n      this.state = COLON;                                                                                            // 377\n    } else if (token === RIGHT_BRACE) {                                                                              // 378\n      this.pop();                                                                                                    // 379\n    } else {                                                                                                         // 380\n      this.parseError(token, value);                                                                                 // 381\n    }                                                                                                                // 382\n  }else if(this.state === COLON){                                                                                    // 383\n    if (token === COLON) { this.state = VALUE; }                                                                     // 384\n    else { this.parseError(token, value); }                                                                          // 385\n  }else if(this.state === COMMA){                                                                                    // 386\n    if (token === COMMA) {                                                                                           // 387\n      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }                                                   // 388\n      else if (this.mode === OBJECT) { this.state = KEY; }                                                           // 389\n                                                                                                                     // 390\n    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {    // 391\n      this.pop();                                                                                                    // 392\n    } else {                                                                                                         // 393\n      this.parseError(token, value);                                                                                 // 394\n    }                                                                                                                // 395\n  }else{                                                                                                             // 396\n    this.parseError(token, value);                                                                                   // 397\n  }                                                                                                                  // 398\n};                                                                                                                   // 399\n                                                                                                                     // 400\nmodule.exports = Parser;                                                                                             // 401\n                                                                                                                     // 402\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}},\"through\":{\"package.json\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/through/package.json                                                                                 //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nexports.name = \"through\";                                                                                            // 1\nexports.version = \"2.3.8\";                                                                                           // 2\nexports.main = \"index.js\";                                                                                           // 3\n                                                                                                                     // 4\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"index.js\":[\"stream\",\"meteor-node-stubs/deps/stream\",function(require,exports,module){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// node_modules/through/index.js                                                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar Stream = require('stream')                                                                                       // 1\n                                                                                                                     // 2\n// through                                                                                                           // 3\n//                                                                                                                   // 4\n// a stream that does nothing but re-emit the input.                                                                 // 5\n// useful for aggregating a series of changing but not ending streams into one stream)                               // 6\n                                                                                                                     // 7\nexports = module.exports = through                                                                                   // 8\nthrough.through = through                                                                                            // 9\n                                                                                                                     // 10\n//create a readable writable stream.                                                                                 // 11\n                                                                                                                     // 12\nfunction through (write, end, opts) {                                                                                // 13\n  write = write || function (data) { this.queue(data) }                                                              // 14\n  end = end || function () { this.queue(null) }                                                                      // 15\n                                                                                                                     // 16\n  var ended = false, destroyed = false, buffer = [], _ended = false                                                  // 17\n  var stream = new Stream()                                                                                          // 18\n  stream.readable = stream.writable = true                                                                           // 19\n  stream.paused = false                                                                                              // 20\n                                                                                                                     // 21\n//  stream.autoPause   = !(opts && opts.autoPause   === false)                                                       // 22\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)                                                         // 23\n                                                                                                                     // 24\n  stream.write = function (data) {                                                                                   // 25\n    write.call(this, data)                                                                                           // 26\n    return !stream.paused                                                                                            // 27\n  }                                                                                                                  // 28\n                                                                                                                     // 29\n  function drain() {                                                                                                 // 30\n    while(buffer.length && !stream.paused) {                                                                         // 31\n      var data = buffer.shift()                                                                                      // 32\n      if(null === data)                                                                                              // 33\n        return stream.emit('end')                                                                                    // 34\n      else                                                                                                           // 35\n        stream.emit('data', data)                                                                                    // 36\n    }                                                                                                                // 37\n  }                                                                                                                  // 38\n                                                                                                                     // 39\n  stream.queue = stream.push = function (data) {                                                                     // 40\n//    console.error(ended)                                                                                           // 41\n    if(_ended) return stream                                                                                         // 42\n    if(data === null) _ended = true                                                                                  // 43\n    buffer.push(data)                                                                                                // 44\n    drain()                                                                                                          // 45\n    return stream                                                                                                    // 46\n  }                                                                                                                  // 47\n                                                                                                                     // 48\n  //this will be registered as the first 'end' listener                                                              // 49\n  //must call destroy next tick, to make sure we're after any                                                        // 50\n  //stream piped from here.                                                                                          // 51\n  //this is only a problem if end is not emitted synchronously.                                                      // 52\n  //a nicer way to do this is to make sure this is the last listener for 'end'                                       // 53\n                                                                                                                     // 54\n  stream.on('end', function () {                                                                                     // 55\n    stream.readable = false                                                                                          // 56\n    if(!stream.writable && stream.autoDestroy)                                                                       // 57\n      process.nextTick(function () {                                                                                 // 58\n        stream.destroy()                                                                                             // 59\n      })                                                                                                             // 60\n  })                                                                                                                 // 61\n                                                                                                                     // 62\n  function _end () {                                                                                                 // 63\n    stream.writable = false                                                                                          // 64\n    end.call(stream)                                                                                                 // 65\n    if(!stream.readable && stream.autoDestroy)                                                                       // 66\n      stream.destroy()                                                                                               // 67\n  }                                                                                                                  // 68\n                                                                                                                     // 69\n  stream.end = function (data) {                                                                                     // 70\n    if(ended) return                                                                                                 // 71\n    ended = true                                                                                                     // 72\n    if(arguments.length) stream.write(data)                                                                          // 73\n    _end() // will emit or queue                                                                                     // 74\n    return stream                                                                                                    // 75\n  }                                                                                                                  // 76\n                                                                                                                     // 77\n  stream.destroy = function () {                                                                                     // 78\n    if(destroyed) return                                                                                             // 79\n    destroyed = true                                                                                                 // 80\n    ended = true                                                                                                     // 81\n    buffer.length = 0                                                                                                // 82\n    stream.writable = stream.readable = false                                                                        // 83\n    stream.emit('close')                                                                                             // 84\n    return stream                                                                                                    // 85\n  }                                                                                                                  // 86\n                                                                                                                     // 87\n  stream.pause = function () {                                                                                       // 88\n    if(stream.paused) return                                                                                         // 89\n    stream.paused = true                                                                                             // 90\n    return stream                                                                                                    // 91\n  }                                                                                                                  // 92\n                                                                                                                     // 93\n  stream.resume = function () {                                                                                      // 94\n    if(stream.paused) {                                                                                              // 95\n      stream.paused = false                                                                                          // 96\n      stream.emit('resume')                                                                                          // 97\n    }                                                                                                                // 98\n    drain()                                                                                                          // 99\n    //may have become paused again,                                                                                  // 100\n    //as drain emits 'data'.                                                                                         // 101\n    if(!stream.paused)                                                                                               // 102\n      stream.emit('drain')                                                                                           // 103\n    return stream                                                                                                    // 104\n  }                                                                                                                  // 105\n  return stream                                                                                                      // 106\n}                                                                                                                    // 107\n                                                                                                                     // 108\n                                                                                                                     // 109\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}]}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/modules/client.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.modules = exports, {\n  meteorInstall: meteorInstall,\n  Buffer: Buffer,\n  process: process\n});\n\n})();\n","servePath":"/packages/modules.js","sourceMap":{"version":3,"sources":["/packages/modules/client.js","/packages/modules/buffer.js","/packages/modules/css.js","/packages/modules/install-packages.js","/packages/modules/process.js","/packages/modules/stubs.js","node_modules/meteor/modules/node_modules/reify/lib/runtime.js","node_modules/meteor/modules/node_modules/reify/lib/entry.js","node_modules/meteor/modules/node_modules/reify/lib/utils.js","node_modules/dockerode/package.json","node_modules/dockerode/lib/docker.js","node_modules/dockerode/lib/container.js","node_modules/dockerode/lib/util.js","node_modules/dockerode/lib/exec.js","node_modules/dockerode/lib/image.js","node_modules/dockerode/lib/volume.js","node_modules/dockerode/lib/network.js","node_modules/docker-modem/package.json","node_modules/docker-modem/lib/modem.js","node_modules/docker-modem/lib/http_duplex.js","node_modules/follow-redirects/package.json","node_modules/follow-redirects/index.js","node_modules/underscore/package.json","node_modules/underscore/underscore.js","node_modules/readable-stream/package.json","node_modules/readable-stream/readable.js","node_modules/readable-stream/lib/_stream_readable.js","node_modules/readable-stream/lib/_stream_writable.js","node_modules/readable-stream/lib/_stream_duplex.js","node_modules/readable-stream/lib/_stream_transform.js","node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/isarray/package.json","node_modules/isarray/index.js","node_modules/core-util-is/package.json","node_modules/core-util-is/lib/util.js","node_modules/inherits/package.json","node_modules/inherits/inherits_browser.js","node_modules/string_decoder/package.json","node_modules/string_decoder/index.js","node_modules/debug/package.json","node_modules/debug/debug.js","node_modules/split-ca/package.json","node_modules/split-ca/index.js","node_modules/JSONStream/package.json","node_modules/JSONStream/index.js","node_modules/jsonparse/package.json","node_modules/jsonparse/jsonparse.js","node_modules/through/package.json","node_modules/through/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;ACPA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC9CA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC/lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACtoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACtHA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC7UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AClDA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC7GA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H;;;;;;;;;;;AC5gDA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACt9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AClYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC9CA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC3GA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;ACvBA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;AC7NA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACzIA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;AC3BA;AACA;AACA,yH;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACjMA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACjZA;AACA;AACA;AACA,yH;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H","file":"/packages/modules.js","sourcesContent":["require(\"./install-packages.js\");\nrequire(\"./stubs.js\");\nrequire(\"./buffer.js\");\nrequire(\"./process.js\");\nrequire(\"reify/lib/runtime\").enable(module.constructor);\n\nexports.addStyles = require(\"./css\").addStyles;\n","try {\n  Buffer = global.Buffer || require(\"buffer\").Buffer;\n} catch (noBuffer) {}\n","var doc = document;\nvar head = doc.getElementsByTagName(\"head\").item(0);\n\nexports.addStyles = function (css) {\n  var style = doc.createElement(\"style\");\n\n  style.setAttribute(\"type\", \"text/css\");\n\n  // https://msdn.microsoft.com/en-us/library/ms535871(v=vs.85).aspx\n  var internetExplorerSheetObject =\n    style.sheet || // Edge/IE11.\n    style.styleSheet; // Older IEs.\n\n  if (internetExplorerSheetObject) {\n    internetExplorerSheetObject.cssText = css;\n  } else {\n    style.appendChild(doc.createTextNode(css));\n  }\n\n  return head.appendChild(style);\n};\n","function install(name, mainModule) {\n  var meteorDir = {};\n\n  // Given a package name <name>, install a stub module in the\n  // /node_modules/meteor directory called <name>.js, so that\n  // require.resolve(\"meteor/<name>\") will always return\n  // /node_modules/meteor/<name>.js instead of something like\n  // /node_modules/meteor/<name>/index.js, in the rare but possible event\n  // that the package contains a file called index.js (#6590).\n\n  if (mainModule) {\n    meteorDir[name + \".js\"] = [mainModule, function (require, e, module) {\n      module.exports = require(mainModule);\n    }];\n  } else {\n    // back compat with old Meteor packages\n    meteorDir[name + \".js\"] = function (r, e, module) {\n      module.exports = Package[name];\n    };\n  }\n\n  meteorInstall({\n    node_modules: {\n      meteor: meteorDir\n    }\n  });\n}\n\n// This file will be modified during computeJsOutputFilesMap to include\n// install(<name>) calls for every Meteor package.\n\ninstall(\"underscore\");\ninstall(\"meteor\");\ninstall(\"meteor-base\");\ninstall(\"mobile-experience\");\ninstall(\"modules-runtime\");\ninstall(\"modules\", \"meteor/modules/client.js\");\ninstall(\"es5-shim\", \"meteor/es5-shim/client.js\");\ninstall(\"promise\", \"meteor/promise/client.js\");\ninstall(\"ecmascript-runtime\", \"meteor/ecmascript-runtime/runtime.js\");\ninstall(\"babel-compiler\");\ninstall(\"ecmascript\");\ninstall(\"base64\");\ninstall(\"ejson\");\ninstall(\"id-map\");\ninstall(\"ordered-dict\");\ninstall(\"tracker\");\ninstall(\"babel-runtime\");\ninstall(\"random\");\ninstall(\"mongo-id\");\ninstall(\"diff-sequence\");\ninstall(\"geojson-utils\", \"meteor/geojson-utils/main.js\");\ninstall(\"minimongo\");\ninstall(\"check\", \"meteor/check/match.js\");\ninstall(\"retry\");\ninstall(\"ddp-common\");\ninstall(\"reload\");\ninstall(\"ddp-client\");\ninstall(\"ddp\");\ninstall(\"ddp-server\");\ninstall(\"allow-deny\");\ninstall(\"insecure\");\ninstall(\"mongo\");\ninstall(\"blaze-html-templates\");\ninstall(\"reactive-var\");\ninstall(\"jquery\", \"meteor/jquery/main.js\");\ninstall(\"standard-minifier-css\");\ninstall(\"standard-minifier-js\");\ninstall(\"autopublish\");\ninstall(\"webapp\");\ninstall(\"livedata\");\ninstall(\"hot-code-push\");\ninstall(\"deps\");\ninstall(\"htmljs\");\ninstall(\"observe-sequence\");\ninstall(\"blaze\");\ninstall(\"spacebars\");\ninstall(\"templating\");\ninstall(\"launch-screen\");\ninstall(\"ui\");\ninstall(\"autoupdate\");\n","try {\n  // The application can run `npm install process` to provide its own\n  // process stub; otherwise this module will provide a partial stub.\n  process = global.process || require(\"process\");\n} catch (noProcess) {\n  process = {};\n}\n\nif (Meteor.isServer) {\n  // Make require(\"process\") work on the server in all versions of Node.\n  meteorInstall({\n    node_modules: {\n      \"process.js\": function (r, e, module) {\n        module.exports = process;\n      }\n    }\n  });\n} else {\n  process.platform = \"browser\";\n  process.nextTick = process.nextTick || Meteor._setImmediate;\n}\n\nif (typeof process.env !== \"object\") {\n  process.env = {};\n}\n\n_.extend(process.env, meteorEnv);\n","try {\n  // When meteor-node-stubs is installed in the application's root\n  // node_modules directory, requiring it here installs aliases for stubs\n  // for all Node built-in modules, such as fs, util, and http.\n  require(\"meteor-node-stubs\");\n} catch (noStubs) {}\n","var Entry = require(\"./entry.js\").Entry;\nvar utils = require(\"./utils.js\");\n\nexports.enable = function (Module) {\n  var Mp = Module.prototype;\n\n  if (typeof Mp.import === \"function\" &&\n      typeof Mp.export === \"function\") {\n    // If the Mp.{import,export} methods have already been\n    // defined, abandon reification immediately.\n    return Module;\n  }\n\n  // Platform-specific code should implement this method however\n  // appropriate. Module.prototype.resolve(id) should return an absolute\n  // version of the given module identifier, like require.resolve.\n  Mp.resolve = Mp.resolve || function resolve(id) {\n    throw new Error(\"Module.prototype.resolve not implemented\");\n  };\n\n  // Platform-specific code should find a way to call this method whenever\n  // the module system is about to return module.exports from require. This\n  // might happen more than once per module, in case of dependency cycles,\n  // so we want Module.prototype.runModuleSetters to run each time.\n  Mp.runModuleSetters = function runModuleSetters(valueToPassThrough) {\n    var entry = Entry.get(this.id);\n    if (entry) {\n      entry.runModuleSetters(this);\n    }\n\n    // Assignments to exported local variables get wrapped with calls to\n    // module.runModuleSetters, so module.runModuleSetters returns the\n    // valueToPassThrough parameter to allow the value of the original\n    // expression to pass through. For example,\n    //\n    //   export var a = 1;\n    //   console.log(a += 3);\n    //\n    // becomes\n    //\n    //   module.export(\"a\", () => a);\n    //   var a = 1;\n    //   console.log(module.runModuleSetters(a += 3));\n    //\n    // This ensures module.runModuleSetters runs immediately after the\n    // assignment, and does not interfere with the larger computation.\n    return valueToPassThrough;\n  };\n\n  function setESModule(module) {\n    var exports = module.exports;\n    if (exports && typeof exports === \"object\") {\n      exports.__esModule = true;\n    }\n  }\n\n  Mp.import = function (id, setters) {\n    var module = this;\n    setESModule(module);\n\n    var absoluteId = module.resolve(id);\n\n    if (setters && typeof setters === \"object\") {\n      var entry = Entry.getOrCreate(absoluteId);\n      entry.addSetters(module, setters);\n    }\n\n    var countBefore = entry && entry.runCount;\n    var exports = typeof module.require === \"function\"\n      ? module.require(absoluteId)\n      : require(absoluteId);\n\n    if (entry && entry.runCount === countBefore) {\n      // If require(absoluteId) didn't run any setters for this entry,\n      // perhaps because it's not the first time this module has been\n      // required, run the setters now using an object that passes as the\n      // real module object.\n      entry.runModuleSetters({\n        id: absoluteId,\n        exports: exports,\n        getExportByName: Mp.getExportByName\n      });\n    }\n  };\n\n  // Register getter functions for local variables in the scope of an\n  // export statement. The keys of the getters object are exported names,\n  // and the values are functions that return local values.\n  Mp.export = function (getters) {\n    var module = this;\n    setESModule(module);\n\n    if (utils.isPlainObject(getters)) {\n      Entry.getOrCreate(module.id).addGetters(getters);\n    }\n\n    if (module.loaded) {\n      // If the module has already been evaluated, then we need to trigger\n      // another round of entry.runModuleSetters calls, which begins by\n      // calling entry.runModuleGetters(module).\n      module.runModuleSetters();\n    }\n  };\n\n  // This method can be overridden by client code to implement custom export\n  // naming logic. The current implementation works well with Babel's\n  // __esModule convention.\n  Mp.getExportByName = function (name) {\n    var exports = this.exports;\n\n    if (name === \"*\") {\n      return exports;\n    }\n\n    if (name === \"default\" &&\n        ! (exports &&\n           typeof exports === \"object\" &&\n           exports.__esModule &&\n           \"default\" in exports)) {\n      return exports;\n    }\n\n    return exports && exports[name];\n  };\n\n  return Module;\n};\n","var hasOwn = Object.prototype.hasOwnProperty;\nvar entryMap = Object.create(null);\nvar utils = require(\"./utils.js\");\n\nfunction Entry(id) {\n  // Same as module.id for this module.\n  this.id = id;\n  // The number of times this.runModuleSetters has been called.\n  this.runCount = 0;\n  // Setters for assigning to local variables in parent modules.\n  this.setters = Object.create(null);\n  // Getters for local variables exported from this module.\n  this.getters = Object.create(null);\n}\n\nvar Ep = Entry.prototype;\n\nEntry.get = function (id) {\n  return entryMap[id] || null;\n};\n\nEntry.getOrCreate = function (id) {\n  return entryMap[id] = entryMap[id] || new Entry(id);\n};\n\nEp.addSetters = function (parent, setters) {\n  var entry = this;\n\n  Object.keys(setters).forEach(function (name) {\n    var setter = setters[name];\n    if (typeof setter === \"function\" &&\n        // Ignore any requests for the exports.__esModule property.\"\n        name !== \"__esModule\") {\n      setter.parent = parent;\n      (entry.setters[name] =\n       entry.setters[name] || []\n      ).push(setter);\n    }\n  });\n};\n\nEp.addGetters = function (getters) {\n  var entry = this;\n  Object.keys(getters).forEach(function (name) {\n    var getter = getters[name];\n    if (typeof getter === \"function\" &&\n        // Ignore any requests for the exports.__esModule property.\"\n        name !== \"__esModule\") {\n      // Should this throw if hasOwn.call(this.getters, name)?\n      entry.getters[name] = getter;\n    }\n  });\n};\n\nfunction runModuleSetters(module) {\n  var entry = entryMap[module.id];\n  if (entry) {\n    entry.runModuleSetters(module);\n  }\n}\n\nfunction runModuleGetters(module) {\n  var entry = entryMap[module.id];\n  return entry ? entry.runModuleGetters(module) : 0;\n}\n\nEp.runModuleGetters = function (module) {\n  var entry = this;\n  var changeCount = 0;\n\n  Object.keys(entry.getters).forEach(function (name) {\n    if (entry.runGetter(module, name)) {\n      ++changeCount;\n    }\n  });\n\n  return changeCount;\n};\n\n// Returns true iff the getter updated module.exports with a new value.\nEp.runGetter = function (module, name) {\n  if (! hasOwn.call(this.getters, name)) {\n    return false;\n  }\n\n  var getter = this.getters[name];\n  try {\n    var value = getter.call(module);\n  } catch (e) {}\n  var exports = module.exports;\n\n  if (! hasOwn.call(exports, name) ||\n      exports[name] !== value) {\n    // We update module.exports[name] with the current value so that\n    // CommonJS require calls remain consistent with module.import.\n    exports[name] = value;\n    return true;\n  }\n\n  return false;\n};\n\n// Called whenever module.exports might have changed, to trigger any\n// setters associated with the newly exported values.\nEp.runModuleSetters = function (module) {\n  var entry = this;\n  var names = Object.keys(entry.setters);\n\n  // Make sure module.exports is up to date before we call\n  // module.getExportByName(name).\n  entry.runModuleGetters(module);\n\n  // Invoke the given callback once for every (setter, value, name) triple\n  // that needs to be called. Note that forEachSetter does not call any\n  // setters itself, only the given callback.\n  function forEachSetter(callback, context) {\n    names.forEach(function (name) {\n      entry.setters[name].forEach(function (setter) {\n        var value = module.getExportByName(name);\n        if (name === \"*\") {\n          Object.keys(value).forEach(function (name) {\n            call(setter, value[name], name);\n          });\n        } else {\n          call(setter, value, name);\n        }\n      });\n    });\n\n    function call(setter, value, name) {\n      if (name === \"__esModule\") {\n        // Ignore setters asking for module.exports.__esModule.\n        return;\n      }\n\n      setter.last = setter.last || Object.create(null);\n\n      if (! hasOwn.call(setter.last, name) ||\n          setter.last[name] !== value) {\n        // Only invoke the callback if we have not called this setter\n        // (with a value of this name) before, or the current value is\n        // different from the last value we passed to this setter.\n        return callback.apply(context, arguments);\n      }\n    }\n  }\n\n  // Every three elements of this list form a (setter, value, name) triple\n  // that needs to be invoked.\n  var settersToCall = [];\n\n  // Lazily-initialized objects mapping parent module identifiers to\n  // relevant parent module objects and snapshots of their exports.\n  var relevantParents;\n  var parentSnapshots;\n\n  // Take snapshots of setter.parent.exports for any setters that we are\n  // planning to call, so that we can later determine if calling the\n  // setters modified any of those exports objects.\n  forEachSetter(function (setter, value, name) {\n    var parent = setter.parent;\n    parentSnapshots = parentSnapshots || Object.create(null);\n    if (! hasOwn.call(parentSnapshots, parent.id)) {\n      relevantParents = relevantParents || Object.create(null);\n      relevantParents[parent.id] = parent;\n      if (utils.isPlainObject(parent.exports)) {\n        // If parent.exports is an object, make a shallow clone of it so\n        // that we can see if it changes as a result of calling setters.\n        parentSnapshots[parent.id] = utils.assign({}, parent.exports);\n      } else {\n        // If parent.exports is not an object, the \"snapshot\" is just the\n        // value of parent.exports.\n        parentSnapshots[parent.id] = parent.exports;\n      }\n    }\n\n    // Push three elements at a time to avoid creating wrapper arrays for\n    // each (setter, value, name) triple. Note the i += 3 below.\n    settersToCall.push(setter, value, name);\n  });\n\n  // Now call all the setters that we decided we need to call.\n  for (var i = 0; i < settersToCall.length; i += 3) {\n    var setter = settersToCall[i];\n    var value = settersToCall[i + 1];\n    var name = settersToCall[i + 2];\n    setter.call(module, setter.last[name] = value, name);\n  }\n\n  ++entry.runCount;\n\n  if (! relevantParents) {\n    // If we never called takeSnapshot, then we can avoid checking\n    // relevantParents and parentSnapshots below.\n    return;\n  }\n\n  // If any of the setters updated the module.exports of a parent module,\n  // or updated local variables that are exported by that parent module,\n  // then we must re-run any setters registered by that parent module.\n  Object.keys(relevantParents).forEach(function (id) {\n    var parent = relevantParents[id];\n\n    if (runModuleGetters(parent) > 0) {\n      return runModuleSetters(parent);\n    }\n\n    var exports = parent.exports;\n    var snapshot = parentSnapshots[parent.id];\n    if (utils.shallowObjEqual(exports, snapshot)) {\n      // If parent.exports have not changed since we took the snapshot,\n      // then we do not need to run the parent's setters.\n      return;\n    }\n\n    runModuleSetters(parent);\n  });\n};\n\nexports.Entry = Entry;\n","var hasOwn = Object.prototype.hasOwnProperty;\nvar objToStr = Object.prototype.toString;\nvar objStr = objToStr.call({});\n\nfunction isPlainObject(value) {\n  return objToStr.call(value) === objStr;\n}\nexports.isPlainObject = isPlainObject;\n\nexports.assign = Object.assign || function (obj) {\n  var argc = arguments.length;\n  for (var i = 1; i < argc; ++i) {\n    var arg = arguments[i];\n    if (arg && typeof arg === \"object\") {\n      var keys = Object.keys(arg);\n      for (var k = 0; k < keys.length; ++k) {\n        var key = keys[k];\n        obj[key] = arg[key];\n      }\n    }\n  }\n  return obj;\n};\n\nexports.shallowObjEqual = function(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (! isPlainObject(a) ||\n      ! isPlainObject(b)) {\n    return false;\n  }\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  return aKeys.every(function (key) {\n    return hasOwn.call(b, key) &&\n      a[key] === b[key];\n  });\n};\n","exports.name = \"dockerode\";\nexports.version = \"2.2.10\";\nexports.main = \"./lib/docker\";\n","var EventEmitter = require('events').EventEmitter,\r\n  Modem = require('docker-modem'),\r\n  Container = require('./container'),\r\n  Image = require('./image'),\r\n  Volume = require('./volume'),\r\n  Network = require('./network'),\r\n  Exec = require('./exec'),\r\n  util = require('./util'),\r\n  extend = util.extend;\r\n\r\nvar Docker = function(opts) {\r\n  if (!(this instanceof Docker)) return new Docker(opts);\r\n  this.modem = new Modem(opts);\r\n};\r\n\r\n/**\r\n * Creates a new container\r\n * @param {Object}   opts     Create options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.createContainer = function(opts, callback) {\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/containers/create?',\r\n    method: 'POST',\r\n    options: opts,\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      404: 'no such container',\r\n      406: 'impossible to attach',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    if (err) return callback(err, data);\r\n    callback(err, self.getContainer(data.Id));\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a new image\r\n * @param {Object}   auth     Authentication (optional)\r\n * @param {Object}   opts     Create options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.createImage = function(auth, opts, callback) {\r\n  if (!callback && typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = auth;\r\n    auth = opts.authconfig || undefined;\r\n  }\r\n\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/images/create?',\r\n    method: 'POST',\r\n    options: opts,\r\n    authconfig: auth,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Load image\r\n * @param {String}   file     File\r\n * @param {Object}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.loadImage = function(file, opts, callback) {\r\n  if (!callback && typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = null;\r\n  }\r\n\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/images/load?',\r\n    method: 'POST',\r\n    options: opts,\r\n    file: file,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Import image from a tar archive\r\n * @param {String}   file     File\r\n * @param {Object}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.importImage = function(file, opts, callback) {\r\n  if (!callback && typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  }\r\n\r\n  opts.fromSrc = '-'\r\n\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/images/create?',\r\n    method: 'POST',\r\n    options: opts,\r\n    file: file,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Verifies auth\r\n * @param {Object}   opts     Options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.checkAuth = function(opts, callback) {\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/auth',\r\n    method: 'POST',\r\n    options: opts,\r\n    statusCodes: {\r\n      200: true,\r\n      204: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Builds an image\r\n * @param {String}   file     File\r\n * @param {Object}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.buildImage = function(file, opts, callback) {\r\n  if (!callback && typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = null;\r\n  }\r\n\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/build?',\r\n    method: 'POST',\r\n    file: file,\r\n    options: opts,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  if (opts) {\r\n    if (opts.registryconfig) {\r\n      optsf.registryconfig = optsf.options.registryconfig;\r\n      delete optsf.options.registryconfig;\r\n    }\r\n\r\n    //undocumented?\r\n    if (opts.authconfig) {\r\n      optsf.authconfig = optsf.options.authconfig;\r\n      delete optsf.options.authconfig;\r\n    }\r\n  }\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Fetches a Container by ID\r\n * @param {String} id Container's ID\r\n */\r\nDocker.prototype.getContainer = function(id) {\r\n  return new Container(this.modem, id);\r\n};\r\n\r\n/**\r\n * Fetches an Image by name\r\n * @param {String} name Image's name\r\n */\r\nDocker.prototype.getImage = function(name) {\r\n  return new Image(this.modem, name);\r\n};\r\n\r\n/**\r\n * Fetches a Volume by name\r\n * @param {String} name Volume's name\r\n */\r\nDocker.prototype.getVolume = function(name) {\r\n  return new Volume(this.modem, name);\r\n};\r\n\r\n/**\r\n * Fetches a Network by id\r\n * @param {String} id network's id\r\n */\r\nDocker.prototype.getNetwork = function(id) {\r\n  return new Network(this.modem, id);\r\n};\r\n\r\n/**\r\n * Fetches an Exec instance by ID\r\n * @param {String} id Exec instance's ID\r\n */\r\nDocker.prototype.getExec = function(id) {\r\n  return new Exec(this.modem, id);\r\n};\r\n\r\n/**\r\n * Lists containers\r\n * @param {Options}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.listContainers = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/containers/json?',\r\n    method: 'GET',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Lists images\r\n * @param {Options}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.listImages = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/images/json?',\r\n    method: 'GET',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a new volume\r\n * @param {Object}   opts     Create options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.createVolume = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/volumes/create?',\r\n    method: 'POST',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    if (err) return args.callback(err, data);\r\n    args.callback(err, self.getVolume(data.Name));\r\n  });\r\n};\r\n\r\n/**\r\n * Lists volumes\r\n * @param {Options}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.listVolumes = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/volumes?',\r\n    method: 'GET',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a new network\r\n * @param {Object}   opts     Create options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.createNetwork = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/networks/create?',\r\n    method: 'POST',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      404: 'driver not found',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    if (err) return args.callback(err, data);\r\n    args.callback(err, self.getNetwork(data.Id));\r\n  });\r\n};\r\n\r\n/**\r\n * Lists networkss\r\n * @param {Options}   opts     Options (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.listNetworks = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/networks?',\r\n    method: 'GET',\r\n    options: args.opts,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Search images\r\n * @param {Object}   opts     Options\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.searchImages = function(opts, callback) {\r\n  var optsf = {\r\n    path: '/images/search?',\r\n    method: 'GET',\r\n    options: opts,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Info\r\n * @param  {Function} callback Callback with info\r\n */\r\nDocker.prototype.info = function(callback) {\r\n  var opts = {\r\n    path: '/info',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(opts, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Version\r\n * @param  {Function} callback Callback\r\n */\r\nDocker.prototype.version = function(callback) {\r\n  var opts = {\r\n    path: '/version',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(opts, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Ping\r\n * @param  {Function} callback Callback\r\n */\r\nDocker.prototype.ping = function(callback) {\r\n  if (!callback && typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = null;\r\n  }\r\n\r\n  var optsf = {\r\n    path: '/_ping',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Events\r\n * @param {Object}   opts     Events options, like 'since' (optional)\r\n * @param {Function} callback Callback\r\n */\r\nDocker.prototype.getEvents = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/events?',\r\n    method: 'GET',\r\n    options: args.opts,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Pull is a wrapper around parsing out the tag from the image\r\n * (which create image cannot do but run can for whatever reasons) and create image overloading.\r\n * @param  {String}   repoTag  Repository tag\r\n * @param  {Object}   opts     Options (optional)\r\n * @param  {Function} callback Callback\r\n * @param  {Object}   auth     Authentication (optional)\r\n * @return {Object}            Image\r\n */\r\nDocker.prototype.pull = function(repoTag, opts, callback, auth) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var imageSrc = util.parseRepositoryTag(repoTag);\r\n  args.opts.fromImage = imageSrc.repository;\r\n  args.opts.tag = imageSrc.tag;\r\n\r\n  var argsf = [args.opts, args.callback];\r\n  if (auth) {\r\n    argsf = [auth, args.opts, args.callback];\r\n  }\r\n  return this.createImage.apply(this, argsf);\r\n};\r\n\r\n/**\r\n * Like run command from Docker's CLI\r\n * @param  {String}   image         Image name to be used.\r\n * @param  {Array}   cmd           Command to run in array format.\r\n * @param  {Object}   streamo       Output stream\r\n * @param  {Object}   createOptions Container create options (optional)\r\n * @param  {Object}   startOptions  Container start options (optional)\r\n * @param  {Function} callback      Callback\r\n * @return {Object}                 EventEmitter\r\n */\r\nDocker.prototype.run = function(image, cmd, streamo, createOptions, startOptions, callback) {\r\n  if (!callback && typeof createOptions === 'function') {\r\n    callback = createOptions;\r\n    createOptions = {};\r\n    startOptions = {};\r\n  } else if (!callback && typeof startOptions === 'function') {\r\n    callback = startOptions;\r\n    startOptions = {};\r\n  }\r\n\r\n  var hub = new EventEmitter();\r\n\r\n  function handler(err, container) {\r\n    if (err) return callback(err, null, container);\r\n\r\n    hub.emit('container', container);\r\n\r\n    container.attach({\r\n      stream: true,\r\n      stdout: true,\r\n      stderr: true\r\n    }, function handler(err, stream) {\r\n      if (err) return callback(err, null, container);\r\n\r\n      hub.emit('stream', stream);\r\n\r\n      if (streamo) {\r\n        if (streamo instanceof Array) {\r\n          stream.on('end', function() {\r\n            try {\r\n              streamo[0].end();\r\n            } catch (e) {}\r\n            try {\r\n              streamo[1].end();\r\n            } catch (e) {}\r\n          });\r\n          container.modem.demuxStream(stream, streamo[0], streamo[1]);\r\n        } else {\r\n          stream.setEncoding('utf8');\r\n          stream.pipe(streamo, {\r\n            end: true\r\n          });\r\n        }\r\n      }\r\n\r\n      container.start(startOptions, function(err, data) {\r\n        if (err) return callback(err, data, container);\r\n\r\n        container.wait(function(err, data) {\r\n          hub.emit('data', data);\r\n          callback(err, data, container);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  var optsc = {\r\n    'Hostname': '',\r\n    'User': '',\r\n    'AttachStdin': false,\r\n    'AttachStdout': true,\r\n    'AttachStderr': true,\r\n    'Tty': true,\r\n    'OpenStdin': false,\r\n    'StdinOnce': false,\r\n    'Env': null,\r\n    'Cmd': cmd,\r\n    'Image': image,\r\n    'Volumes': {},\r\n    'VolumesFrom': []\r\n  };\r\n\r\n  extend(optsc, createOptions);\r\n\r\n  this.createContainer(optsc, handler);\r\n\r\n  return hub;\r\n};\r\n\r\nmodule.exports = Docker;\r\n","var extend = require('./util').extend,\r\n  Exec = require('./exec'),\r\n  util = require('./util');\r\n\r\n/**\r\n * Represents a Container\r\n * @param {Object} modem docker-modem\r\n * @param {String} id    Container's ID\r\n */\r\nvar Container = function(modem, id) {\r\n  this.modem = modem;\r\n  this.id = id;\r\n\r\n  this.defaultOptions = {\r\n    top: {},\r\n    start: {},\r\n    commit: {},\r\n    stop: {},\r\n    pause: {},\r\n    unpause: {},\r\n    restart: {},\r\n    resize: {},\r\n    attach: {},\r\n    remove: {},\r\n    copy: {},\r\n    kill: {},\r\n    exec: {},\r\n    rename: {},\r\n    log: {},\r\n    stats: {},\r\n    getArchive: {},\r\n    infoArchive: {},\r\n    putArchive: {},\r\n    update: {}\r\n  };\r\n};\r\n\r\n/**\r\n * Inspect\r\n * @param  {Options}  opts     Options (optional)\r\n * @param  {Function} callback Callback, if supplied will query Docker.\r\n * @return {Object}            ID only and only if callback isn't supplied.\r\n */\r\nContainer.prototype.inspect = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  if (typeof args.callback === 'function') {\r\n    var optsf = {\r\n      path: '/containers/' + this.id + '/json?',\r\n      method: 'GET',\r\n      options: args.opts,\r\n      statusCodes: {\r\n        200: true,\r\n        404: 'no such container',\r\n        500: 'server error'\r\n      }\r\n    };\r\n\r\n    this.modem.dial(optsf, function(err, data) {\r\n      args.callback(err, data);\r\n    });\r\n  } else {\r\n    return JSON.stringify({\r\n      id: this.id\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Rename\r\n * @param  {Object}   opts     Rename options\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.rename = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.rename);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/rename?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      204: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Update\r\n * @param  {Object}   opts     Update options\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.update = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.update);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/update',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      204: true,\r\n      400: 'bad parameter',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Top\r\n * @param  {Object}   Options like 'ps_args' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.top = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.top);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/top?',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Containers changes\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.changes = function(callback) {\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/changes',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Export\r\n * @param  {Function} callback Callback with the octet-stream.\r\n */\r\nContainer.prototype.export = function(callback) {\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/export',\r\n    method: 'GET',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Start\r\n * @param  {Object}   opts     Container start options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.start = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.start);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/start',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      304: 'container already started',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Pause\r\n * @param  {Object}   opts     Pause options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.pause = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.pause);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/pause',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Unpause\r\n * @param  {Object}   opts     Unpause options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.unpause = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.unpause);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/unpause',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Setup an exec call to a running container\r\n *\r\n * @param {object} opts\r\n * @param {function} callback\r\n */\r\nContainer.prototype.exec = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.exec);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/exec',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  var self = this;\r\n  this.modem.dial(optsf, function(err, data) {\r\n    if (err) return args.callback(err, data);\r\n    args.callback(err, new Exec(self.modem, data.Id));\r\n  });\r\n};\r\n\r\n/**\r\n * Commit\r\n * @param  {Object}   opts     Commit options like 'Hostname' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.commit = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.commit);\r\n\r\n  args.opts.container = this.id;\r\n\r\n  var optsf = {\r\n    path: '/commit?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Stop\r\n * @param  {Object}   opts     Container stop options, like 't' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.stop = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.stop);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/stop?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      304: 'container already stopped',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Restart\r\n * @param  {Object}   opts     Container restart options, like 't' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.restart = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.restart);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/restart',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Kill\r\n * @param  {Object}   opts     Container kill options, like 'signal' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.kill = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.kill);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/kill?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Container resize\r\n * @param  {[type]}   opts     Resize options. (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.resize = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.resize);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/resize?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Attach\r\n * @param  {Object}   opts     Attach options, like 'logs' (optional)\r\n * @param  {Function} callback Callback with stream.\r\n */\r\nContainer.prototype.attach = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.attach);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/attach?',\r\n    method: 'POST',\r\n    isStream: true,\r\n    hijack: args.opts.hijack,\r\n    openStdin: args.opts.stdin,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, stream) {\r\n    args.callback(err, stream);\r\n  });\r\n};\r\n\r\n/**\r\n * Waits for a container to end.\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.wait = function(callback) {\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/wait',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'bad parameter',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Removes a container\r\n * @param  {Object}   opts     Remove options, like 'force' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nContainer.prototype.remove = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.remove);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '?',\r\n    method: 'DELETE',\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      204: true,\r\n      400: 'bad parameter',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Copy (WARNING: DEPRECATED since RAPI v1.20)\r\n * @param  {Object}   opts     Copy options, like 'Resource' (optional)\r\n * @param  {Function} callback Callback with stream.\r\n */\r\nContainer.prototype.copy = function(opts, callback) {\r\n  console.log('container.copy is deprecated since Docker v1.8.x');\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.copy);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/copy',\r\n    method: 'POST',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * getArchive\r\n * @param  {Object}   opts     Archive options, like 'path'\r\n * @param  {Function} callback Callback with stream.\r\n */\r\nContainer.prototype.getArchive = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.getArchive);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/archive?',\r\n    method: 'GET',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'client error, bad parameters',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * infoArchive\r\n * @param  {Object}   opts     Archive options, like 'path'\r\n * @param  {Function} callback Callback with stream.\r\n */\r\nContainer.prototype.infoArchive = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.infoArchive);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/archive?',\r\n    method: 'HEAD',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'client error, bad parameters',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * putArchive\r\n * @param  {Object}   opts     Archive options, like 'path'\r\n * @param  {Function} callback Callback with stream.\r\n */\r\nContainer.prototype.putArchive = function(file, opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.putArchive);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/archive?',\r\n    method: 'PUT',\r\n    file: file,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      400: 'client error, bad parameters',\r\n      403: 'client error, permission denied',\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Container logs\r\n * @param  {Object}   opts     Logs options. (optional)\r\n * @param  {Function} callback Callback with data\r\n */\r\nContainer.prototype.logs = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.log);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/logs?',\r\n    method: 'GET',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Container stats\r\n * @param  {Object}   opts     Stats options. (optional)\r\n * @param  {Function} callback Callback with data\r\n */\r\nContainer.prototype.stats = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback, this.defaultOptions.stats);\r\n\r\n  var optsf = {\r\n    path: '/containers/' + this.id + '/stats?',\r\n    method: 'GET',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such container',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\nmodule.exports = Container;\r\n","// https://github.com/HenrikJoreteg/extend-object/blob/v0.1.0/extend-object.js\n\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\n\nmodule.exports.extend = function(obj) {\n  each.call(slice.call(arguments, 1), function(source) {\n    if (source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n};\n\nmodule.exports.processArgs = function(opts, callback, defaultOpts) {\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n  return {\n    callback: callback,\n    opts: module.exports.extend({}, defaultOpts, opts)\n  };\n};\n\n/**\n * Parse the given repo tag name (as a string) and break it out into repo/tag pair.\n * // if given the input http://localhost:8080/woot:latest\n * {\n *   repository: 'http://localhost:8080/woot',\n *   tag: 'latest'\n * }\n * @param {String} input Input e.g: 'repo/foo', 'ubuntu', 'ubuntu:latest'\n * @return {Object} input parsed into the repo and tag.\n */\nmodule.exports.parseRepositoryTag = function(input) {\n  var separatorPos;\n  var digestPos = input.indexOf('@');\n  var colonPos = input.lastIndexOf(':');\n  // @ symbol is more important\n  if (digestPos >= 0) {\n    separatorPos = digestPos;\n  } else if (colonPos >= 0) {\n    separatorPos = colonPos;\n  } else {\n    // no colon nor @\n    return {\n      repository: input\n    };\n  }\n\n  // last colon is either the tag (or part of a port designation)\n  var tag = input.slice(separatorPos + 1);\n\n  // if it contains a / its not a tag and is part of the url\n  if (tag.indexOf('/') === -1) {\n    return {\n      repository: input.slice(0, separatorPos),\n      tag: tag\n    };\n  }\n\n  return {\n    repository: input\n  };\n};\n","var util = require('./util');\r\n\r\n/**\r\n * Represents an Exec\r\n * @param {Object} modem docker-modem\r\n * @param {String} id    Exec's ID\r\n */\r\nvar Exec = function(modem, id) {\r\n  this.modem = modem;\r\n  this.id = id;\r\n};\r\n\r\n/**\r\n * Start the exec call that was setup.\r\n *\r\n * @param {object} options\r\n * @param {function} callback\r\n */\r\nExec.prototype.start = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/exec/' + this.id + '/start',\r\n    method: 'POST',\r\n    isStream: true,\r\n    hijack: args.opts.hijack,\r\n    openStdin: args.opts.stdin,\r\n    statusCodes: {\r\n      200: true,\r\n      204: true,\r\n      404: 'no such exec',\r\n      409: 'container stopped/paused',\r\n      500: 'container not running'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Resize the exec call that was setup.\r\n *\r\n * @param {object} options\r\n * @param {function} callback\r\n */\r\nExec.prototype.resize = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/exec/' + this.id + '/resize?',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such exec',\r\n      500: 'container not running'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Get low-level information about the exec call.\r\n *\r\n * @param {function} callback\r\n */\r\nExec.prototype.inspect = function(callback) {\r\n  var optsf = {\r\n    path: '/exec/' + this.id + '/json',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such exec',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n\r\nmodule.exports = Exec;\r\n","var util = require('./util');\r\n\r\n/**\r\n * Represents an image\r\n * @param {Object} modem docker-modem\r\n * @param {String} name  Image's name\r\n */\r\nvar Image = function(modem, name) {\r\n  this.modem = modem;\r\n  this.name = name;\r\n};\r\n\r\n/**\r\n * Inspect\r\n * @param  {Function} callback Callback, if specified Docker will be queried.\r\n * @return {Object}            Name only if callback isn't specified.\r\n */\r\nImage.prototype.inspect = function(callback) {\r\n  if (typeof callback === 'function') {\r\n    var opts = {\r\n      path: '/images/' + this.name + '/json',\r\n      method: 'GET',\r\n      statusCodes: {\r\n        200: true,\r\n        404: 'no such image',\r\n        500: 'server error'\r\n      }\r\n    };\r\n\r\n    this.modem.dial(opts, function(err, data) {\r\n      callback(err, data);\r\n    });\r\n  } else {\r\n    return JSON.stringify({name: this.name});\r\n  }\r\n};\r\n\r\n/**\r\n * History\r\n * @param  {Function} callback Callback\r\n */\r\nImage.prototype.history = function(callback) {\r\n  var opts = {\r\n    path: '/images/' + this.name + '/history',\r\n    method: 'GET',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such image',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(opts, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Get\r\n * @param  {Function} callback Callback with data stream.\r\n */\r\nImage.prototype.get = function(callback) {\r\n  var opts = {\r\n    path: '/images/' + this.name + '/get',\r\n    method: 'GET',\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(opts, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Push\r\n * @param  {Object}   opts     Push options, like 'registry' (optional)\r\n * @param  {Function} callback Callback with stream.\r\n * @param  {Object}   auth     Registry authentication\r\n */\r\nImage.prototype.push = function(opts, callback, auth) {\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/images/' + this.name + '/push?',\r\n    method: 'POST',\r\n    options: opts,\r\n    authconfig: opts.authconfig || auth,\r\n    isStream: true,\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such image',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  delete optsf.options.authconfig;\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Tag\r\n * @param  {Object}   opts     Tag options, like 'repo' (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nImage.prototype.tag = function(opts, callback) {\r\n  var self = this;\r\n  var optsf = {\r\n    path: '/images/' + this.name + '/tag?',\r\n    method: 'POST',\r\n    options: opts,\r\n    statusCodes: {\r\n      200: true, // unofficial, but proxies may return it\r\n      201: true,\r\n      400: 'bad parameter',\r\n      404: 'no such image',\r\n      409: 'conflict',\r\n      500: 'server error'\r\n    }\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Removes the image\r\n * @param  {[Object]}   opts     Remove options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nImage.prototype.remove = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n\r\n  var optsf = {\r\n    path: '/images/' + this.name + '?',\r\n    method: 'DELETE',\r\n    statusCodes: {\r\n      200: true,\r\n      404: 'no such image',\r\n      409: 'conflict',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\nmodule.exports = Image;\r\n","var util = require('./util');\r\n\r\n/**\r\n * Represents an volume\r\n * @param {Object} modem docker-modem\r\n * @param {String} name  Volume's name\r\n */\r\nvar Volume = function(modem, name) {\r\n  this.modem = modem;\r\n  this.name = name;\r\n};\r\n\r\n/**\r\n * Inspect\r\n * @param  {Function} callback Callback, if specified Docker will be queried.\r\n * @return {Object}            Name only if callback isn't specified.\r\n */\r\nVolume.prototype.inspect = function(callback) {\r\n  if (typeof callback === 'function') {\r\n    var opts = {\r\n      path: '/volumes/' + this.name,\r\n      method: 'GET',\r\n      statusCodes: {\r\n        200: true,\r\n        404: 'no such volume',\r\n        500: 'server error'\r\n      }\r\n    };\r\n\r\n    this.modem.dial(opts, function(err, data) {\r\n      callback(err, data);\r\n    });\r\n  } else {\r\n    return JSON.stringify({name: this.name});\r\n  }\r\n};\r\n\r\n/**\r\n * Removes the volume\r\n * @param  {[Object]}   opts     Remove options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nVolume.prototype.remove = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/volumes/' + this.name,\r\n    method: 'DELETE',\r\n    statusCodes: {\r\n      204: true,\r\n      404: 'no such volume',\r\n      409: 'conflict',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\nmodule.exports = Volume;\r\n","var util = require('./util');\r\n\r\n/**\r\n * Represents an network\r\n * @param {Object} modem docker-modem\r\n * @param {String} id  Network's id\r\n */\r\nvar Network = function(modem, id) {\r\n  this.modem = modem;\r\n  this.id = id;\r\n};\r\n\r\n/**\r\n * Inspect\r\n * @param  {Function} callback Callback, if specified Docker will be queried.\r\n * @return {Object}            Id only if callback isn't specified.\r\n */\r\nNetwork.prototype.inspect = function(callback) {\r\n  if (typeof callback === 'function') {\r\n    var opts = {\r\n      path: '/networks/' + this.id,\r\n      method: 'GET',\r\n      statusCodes: {\r\n        200: true,\r\n        404: 'no such network',\r\n        500: 'server error'\r\n      }\r\n    };\r\n\r\n    this.modem.dial(opts, function(err, data) {\r\n      callback(err, data);\r\n    });\r\n  } else {\r\n    return JSON.stringify({Id: this.id});\r\n  }\r\n};\r\n\r\n/**\r\n * Removes the network\r\n * @param  {[Object]}   opts     Remove options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nNetwork.prototype.remove = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/networks/' + this.id,\r\n    method: 'DELETE',\r\n    statusCodes: {\r\n      200: true,\r\n      204: true,\r\n      404: 'no such network',\r\n      409: 'conflict',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n/**\r\n * Connects a container to a network\r\n * @param  {[Object]}   opts     Connect options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nNetwork.prototype.connect = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/networks/' + this.id + '/connect',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      201: true,\r\n      404: 'network or container is not found',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Disconnects a container from a network\r\n * @param  {[Object]}   opts     Disconnect options (optional)\r\n * @param  {Function} callback Callback\r\n */\r\nNetwork.prototype.disconnect = function(opts, callback) {\r\n  var args = util.processArgs(opts, callback);\r\n\r\n  var optsf = {\r\n    path: '/networks/' + this.id + '/disconnect',\r\n    method: 'POST',\r\n    statusCodes: {\r\n      200: true,\r\n      201: true,\r\n      404: 'network or container is not found',\r\n      500: 'server error'\r\n    },\r\n    options: args.opts\r\n  };\r\n\r\n  this.modem.dial(optsf, function(err, data) {\r\n    args.callback(err, data);\r\n  });\r\n};\r\n\r\n\r\n\r\n\r\nmodule.exports = Network;\r\n","exports.name = \"docker-modem\";\nexports.version = \"0.3.1\";\nexports.main = \"./lib/modem\";\n","var querystring = require('querystring'),\r\n  http = require('follow-redirects'),\r\n  fs = require('fs'),\r\n  path = require('path'),\r\n  url = require('url'),\r\n  stream = require('readable-stream'),\r\n  HttpDuplex = require('./http_duplex'),\r\n  debug = require('debug')('modem'),\r\n  util = require('util'),\r\n  splitca = require('split-ca'),\r\n  JSONStream = require('JSONStream');\r\n\r\nvar defaultOpts = function() {\r\n  var split;\r\n  var opts = {};\r\n\r\n  if (!process.env.DOCKER_HOST) {\r\n    opts.socketPath = '/var/run/docker.sock';\r\n  } else if (process.env.DOCKER_HOST.indexOf('unix://') === 0) {\r\n    // Strip off unix://, fall back to default of /var/run/docker.sock if\r\n    // unix:// was passed without a path\r\n    opts.socketPath = process.env.DOCKER_HOST.substring(7) || '/var/run/docker.sock';\r\n  } else {\r\n    split = /(?:tcp:\\/\\/)?(.*?):([0-9]+)/g.exec(process.env.DOCKER_HOST);\r\n\r\n    if (!split || split.length !== 3) {\r\n      throw new Error('DOCKER_HOST env variable should be something like tcp://localhost:1234');\r\n    }\r\n\r\n    opts.port = split[2];\r\n\r\n    if (process.env.DOCKER_TLS_VERIFY === '1' || opts.port === '2376') {\r\n      opts.protocol = 'https';\r\n    } else {\r\n      opts.protocol = 'http';\r\n    }\r\n\r\n    opts.host = split[1];\r\n\r\n    if (process.env.DOCKER_CERT_PATH) {\r\n      opts.ca = splitca(path.join(process.env.DOCKER_CERT_PATH, 'ca.pem'));\r\n      opts.cert = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'cert.pem'));\r\n      opts.key = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'key.pem'));\r\n    }\r\n  }\r\n\r\n  return opts;\r\n};\r\n\r\nvar Modem = function(opts) {\r\n  if (!opts) {\r\n    opts = defaultOpts();\r\n  }\r\n\r\n  this.socketPath = opts.socketPath;\r\n  this.host = opts.host;\r\n  this.port = opts.port;\r\n  this.version = opts.version;\r\n  this.key = opts.key;\r\n  this.cert = opts.cert;\r\n  this.ca = opts.ca;\r\n  this.timeout = opts.timeout;\r\n  this.checkServerIdentity = opts.checkServerIdentity;\r\n\r\n  if (this.key && this.cert && this.ca) {\r\n    this.protocol = 'https';\r\n  }\r\n  this.protocol = opts.protocol || this.protocol || 'http';\r\n};\r\n\r\nModem.prototype.dial = function(options, callback) {\r\n  var opts, address, data;\r\n  var self = this;\r\n\r\n  if (options.options) {\r\n    opts = options.options;\r\n  }\r\n\r\n  if (this.version) {\r\n    options.path = '/' + this.version + options.path;\r\n  }\r\n\r\n  if (this.host) {\r\n    var parsed = url.parse(self.host);\r\n    address = url.format({\r\n      'protocol': parsed.protocol || self.protocol,\r\n      'hostname': parsed.hostname || self.host,\r\n      'port': self.port\r\n    });\r\n    address = url.resolve(address, options.path);\r\n  } else {\r\n    address = options.path;\r\n  }\r\n\r\n  if (options.path.indexOf('?') !== -1) {\r\n    if (opts && Object.keys(opts).length > 0) {\r\n      address += this.buildQuerystring(opts);\r\n    } else {\r\n      address = address.substring(0, address.length - 1);\r\n    }\r\n  }\r\n\r\n  var optionsf = {\r\n    path: address,\r\n    method: options.method,\r\n    headers: options.headers || {},\r\n    key: self.key,\r\n    cert: self.cert,\r\n    ca: self.ca\r\n  };\r\n\r\n  if (this.checkServerIdentity) {\r\n    optionsf.checkServerIdentity = this.checkServerIdentity;\r\n  }\r\n\r\n  if (options.authconfig) {\r\n    optionsf.headers['X-Registry-Auth'] = options.authconfig.key || options.authconfig.base64 ||\r\n      new Buffer(JSON.stringify(options.authconfig)).toString('base64');\r\n  }\r\n\r\n  if (options.registryconfig) {\r\n    optionsf.headers['X-Registry-Config'] = options.registryconfig.base64 ||\r\n      new Buffer(JSON.stringify(options.registryconfig)).toString('base64');\r\n  }\r\n\r\n  if (options.file) {\r\n    if (typeof options.file === 'string') {\r\n      data = fs.readFileSync(path.resolve(options.file));\r\n    } else {\r\n      data = options.file;\r\n    }\r\n    optionsf.headers['Content-Type'] = 'application/tar';\r\n  } else if (opts && options.method === 'POST') {\r\n    data = JSON.stringify(opts);\r\n    optionsf.headers['Content-Type'] = 'application/json';\r\n  }\r\n\r\n  if (typeof data === \"string\") {\r\n    optionsf.headers['Content-Length'] = Buffer.byteLength(data);\r\n  } else if (Buffer.isBuffer(data) === true) {\r\n    optionsf.headers['Content-Length'] = data.length;\r\n  }\r\n\r\n  if (options.hijack) {\r\n    optionsf.headers.Connection = 'Upgrade';\r\n    optionsf.headers.Upgrade = 'tcp';\r\n  }\r\n\r\n  if (this.socketPath) {\r\n    optionsf.socketPath = this.socketPath;\r\n  } else {\r\n    var urlp = url.parse(address);\r\n    optionsf.hostname = urlp.hostname;\r\n    optionsf.port = urlp.port;\r\n    optionsf.path = urlp.path;\r\n  }\r\n\r\n  this.buildRequest(optionsf, options, data, callback);\r\n};\r\n\r\nModem.prototype.buildRequest = function(options, context, data, callback) {\r\n  var self = this;\r\n  var req = http[self.protocol].request(options, function() {});\r\n\r\n  debug('Sending: %s', util.inspect(options, {\r\n    showHidden: true,\r\n    depth: null\r\n  }));\r\n\r\n  if (self.timeout) {\r\n    req.on('socket', function(socket) {\r\n      socket.setTimeout(self.timeout);\r\n      socket.on('timeout', function() {\r\n        debug('Timeout of %s ms exceeded', self.timeout);\r\n        req.abort();\r\n      });\r\n    });\r\n  }\r\n\r\n  if (context.hijack === true) {\r\n    req.on('upgrade', function(res, sock, head) {\r\n      return callback(null, sock);\r\n    });\r\n  }\r\n\r\n  req.on('response', function(res) {\r\n    if (context.isStream === true) {\r\n      self.buildPayload(null, context.isStream, context.statusCodes, context.openStdin, req, res, null, callback);\r\n    } else {\r\n      var chunks = '';\r\n      res.on('data', function(chunk) {\r\n        chunks += chunk;\r\n      });\r\n\r\n      res.on('end', function() {\r\n        debug('Received: %s', chunks);\r\n\r\n        var json;\r\n        try {\r\n          json = JSON.parse(chunks);\r\n        } catch (e) {\r\n          json = chunks;\r\n        }\r\n        self.buildPayload(null, context.isStream, context.statusCodes, false, req, res, json, callback);\r\n      });\r\n    }\r\n  });\r\n\r\n  req.on('error', function(error) {\r\n    self.buildPayload(error, context.isStream, context.statusCodes, false, {}, {}, null, callback);\r\n  });\r\n\r\n  if (typeof data === \"string\" || Buffer.isBuffer(data)) {\r\n    req.write(data);\r\n  } else if (data) {\r\n    data.pipe(req);\r\n  }\r\n\r\n  if (!context.hijack && !context.openStdin && (typeof data === \"string\" || data === undefined || Buffer.isBuffer(data))) {\r\n    req.end();\r\n  }\r\n};\r\n\r\nModem.prototype.buildPayload = function(err, isStream, statusCodes, openStdin, req, res, json, cb) {\r\n  if (err) return cb(err, null);\r\n\r\n  if (statusCodes[res.statusCode] !== true) {\r\n    getCause(isStream, res, json, function(err, cause) {\r\n      var msg = new Error(\r\n        '(HTTP code ' + res.statusCode + ') ' +\r\n        (statusCodes[res.statusCode] || 'unexpected') + ' - ' +\r\n        (cause.message || cause) + ' '\r\n      );\r\n      msg.reason = statusCodes[res.statusCode];\r\n      msg.statusCode = res.statusCode;\r\n      msg.json = json;\r\n      cb(msg, null);\r\n    });\r\n  } else {\r\n    if (openStdin) {\r\n      cb(null, new HttpDuplex(req, res));\r\n    } else if (isStream) {\r\n      cb(null, res);\r\n    } else {\r\n      cb(null, json);\r\n    }\r\n  }\r\n\r\n  function getCause(isStream, res, json, callback) {\r\n    var chunks = '';\r\n    if (isStream) {\r\n      res.on('data', function(chunk) {\r\n        chunks += chunk;\r\n      });\r\n      res.on('end', function() {\r\n        callback(null, chunks);\r\n      });\r\n    } else {\r\n      callback(null, json);\r\n    }\r\n  }\r\n};\r\n\r\nModem.prototype.demuxStream = function(stream, stdout, stderr) {\r\n  var header = null;\r\n\r\n  stream.on('readable', function() {\r\n    header = header || stream.read(8);\r\n    while (header !== null) {\r\n      var type = header.readUInt8(0);\r\n      var payload = stream.read(header.readUInt32BE(4));\r\n      if (payload === null) break;\r\n      if (type == 2) {\r\n        stderr.write(payload);\r\n      } else {\r\n        stdout.write(payload);\r\n      }\r\n      header = stream.read(8);\r\n    }\r\n  });\r\n};\r\n\r\nModem.prototype.followProgress = function(stream, onFinished, onProgress) {\r\n  var parser = JSONStream.parse(),\r\n    output = [];\r\n\r\n  parser.on('root', onStreamEvent);\r\n  parser.on('error', onStreamError);\r\n  parser.on('end', onStreamEnd);\r\n\r\n  stream.pipe(parser);\r\n\r\n  function onStreamEvent(evt) {\r\n    if (!(evt instanceof Object)) {\r\n      evt = {};\r\n    }\r\n\r\n    output.push(evt);\r\n\r\n    if (evt.error) {\r\n      return onStreamError(evt.error);\r\n    }\r\n\r\n    if (onProgress) {\r\n      onProgress(evt);\r\n    }\r\n  }\r\n\r\n  function onStreamError(err) {\r\n    parser.removeListener('root', onStreamEvent);\r\n    parser.removeListener('error', onStreamError);\r\n    parser.removeListener('end', onStreamEnd);\r\n    onFinished(err, output);\r\n  }\r\n\r\n  function onStreamEnd() {\r\n    onFinished(null, output);\r\n  }\r\n};\r\n\r\nModem.prototype.buildQuerystring = function(opts) {\r\n  var clone = {};\r\n\r\n  // serialize map values as JSON strings, else querystring truncates.\r\n  Object.keys(opts).map(function(key, i) {\r\n    clone[key] = (opts[key] && typeof opts[key] === 'object') ?\r\n      JSON.stringify(opts[key]) : opts[key];\r\n  });\r\n\r\n  return querystring.stringify(clone);\r\n};\r\n\r\nmodule.exports = Modem;\r\n","module.exports = HttpDuplex;\n\nvar util = require('util'),\n  stream = require('readable-stream');\n\nutil.inherits(HttpDuplex, stream.Duplex);\n\nfunction HttpDuplex(req, res, options) {\n  var self = this;\n\n  if (!(self instanceof HttpDuplex)) return new HttpDuplex(req, res);\n\n  stream.Duplex.call(self, options);\n  self._output = null;\n\n  self.connect(req, res);\n}\n\nHttpDuplex.prototype.connect = function(req, res) {\n  var self = this;\n  self.req = req;\n  self._output = res;\n  self.emit('response', res);\n\n  res.on('data', function(c) {\n    if (!self.push(c)) self._output.pause();\n  });\n  res.on('end', function() {\n    self.push(null);\n  });\n};\n\nHttpDuplex.prototype._read = function(n) {\n  if (this._output) this._output.resume();\n};\n\nHttpDuplex.prototype._write = function(chunk, encoding, cb) {\n  this.req.write(chunk, encoding);\n  cb();\n};\n\nHttpDuplex.prototype.end = function(chunk, encoding, cb) {\n  this._output.socket.destroy();\n  return this.req.end(chunk, encoding, cb);\n};\n\nHttpDuplex.prototype.destroy = function() {\n  this.req.destroy();\n  this._output.socket.destroy();\n};\n","exports.name = \"follow-redirects\";\nexports.version = \"0.0.3\";\nexports.main = \"index.js\";\n","var nativeHttps = require('https'),\n  nativeHttp = require('http'),\n  url = require('url'),\n  _ = require('underscore');\n\nvar maxRedirects = module.exports.maxRedirects = 5;\n\nvar protocols = {\n  https: nativeHttps,\n  http: nativeHttp\n};\n\n// Only use GETs on redirects\nfor (var protocol in protocols) {\n  // h is either our cloned http or https object\n  var h =  function() {};\n  h.prototype = protocols[protocol];\n  h = new h();\n\n  module.exports[protocol] = h;\n\n  h.request = function (h) {\n    return function (options, callback, redirectOptions) {\n\n      redirectOptions = redirectOptions || {};\n\n      var max = (typeof options === 'object' && 'maxRedirects' in options) ? options.maxRedirects : exports.maxRedirects;\n\n      var redirect = _.extend({\n        count: 0,\n        max: max,\n        clientRequest: null,\n        userCallback: callback\n      }, redirectOptions);\n\n      //console.log(redirect.count);\n      //console.log(redirect.max);\n      /**\n       * Emit error if too many redirects\n       */\n      if (redirect.count > redirect.max) {\n        var err = new Error('Max redirects exceeded. To allow more redirects, pass options.maxRedirects property.');\n        redirect.clientRequest.emit('error', err);\n        return redirect.clientRequest;\n      }\n\n      redirect.count++;\n\n      /**\n       * Parse URL from options\n       */\n      var reqUrl;\n      if (typeof options === 'string') {\n        reqUrl = options;\n      }\n      else {\n        reqUrl = url.format(_.extend({ protocol: protocol }, options));\n      }\n\n      /*\n       * Build client request\n       */\n      var clientRequest = h.__proto__.request(options, redirectCallback(reqUrl, redirect));\n\n      // Save user's clientRequest so we can emit errors later\n      if (!redirect.clientRequest) redirect.clientRequest = clientRequest;\n\n      /**\n       * ClientRequest callback for redirects\n       */\n      function redirectCallback (reqUrl, redirect) {\n        return function (res) {\n          // status must be 300-399 for redirects\n          if (res.statusCode < 300 || res.statusCode > 399) {\n            //console.log('[' + res.statusCode + '] callback user on url ' + reqUrl);\n            return redirect.userCallback(res);\n          }\n\n          // no `Location:` header => nowhere to redirect\n          if (!('location' in res.headers)) {\n            //console.log('[no location header] callback user on url ' + reqUrl);\n            return redirect.userCallback(res);\n          }\n\n          // save the original clientRequest to our redirectOptions so we can emit errors later\n\n          // need to use url.resolve() in case location is a relative URL\n          var redirectUrl = url.resolve(reqUrl, res.headers['location']);\n          // we need to call the right api (http vs https) depending on protocol\n          var proto = url.parse(redirectUrl).protocol;\n          proto = proto.substr(0, proto.length - 1);\n          //console.log('Redirecting from ' + reqUrl + ' to ' + redirectUrl);\n          return module.exports[proto].get(redirectUrl, redirectCallback(reqUrl, redirect), redirect);\n        };\n      }\n\n      return clientRequest;\n    }\n  }(h);\n\n  // see https://github.com/joyent/node/blob/master/lib/http.js#L1623\n  h.get = function (h) {\n    return function (options, cb, redirectOptions) {\n      var req = h.request(options, cb, redirectOptions);\n      req.end();\n      return req;\n    };\n  }(h);\n}\n","exports.name = \"underscore\";\nexports.version = \"1.8.3\";\nexports.main = \"underscore.js\";\n","//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result — either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n","exports.name = \"readable-stream\";\nexports.version = \"1.0.34\";\nexports.main = \"readable.js\";\n","var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nif (!process.browser && process.env.READABLE_STREAM === 'disable') {\n  module.exports = require('stream');\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = false;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // In streams that never have any data, and do push(null) right away,\n  // the consumer can miss the 'end' event if they do some I/O before\n  // consuming the stream.  So, we don't emit('end') until some reading\n  // happens.\n  this.calledRead = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (typeof chunk === 'string' && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null || chunk === undefined) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      // update the buffer info.\n      state.length += state.objectMode ? 1 : chunk.length;\n      if (addToFront) {\n        state.buffer.unshift(chunk);\n      } else {\n        state.reading = false;\n        state.buffer.push(chunk);\n      }\n\n      if (state.needReadable)\n        emitReadable(stream);\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  var state = this._readableState;\n  state.calledRead = true;\n  var nOrig = n;\n  var ret;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    ret = null;\n\n    // In cases where the decoder did not receive enough data\n    // to produce a full chunk, then immediately received an\n    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].\n    // howMuchToRead will see this and coerce the amount to\n    // read to zero (because it's looking at the length of the\n    // first <Buffer > in state.buffer), and we'll end up here.\n    //\n    // This can only happen via state.decoder -- no other venue\n    // exists for pushing a zero-length chunk into state.buffer\n    // and triggering this behavior. In this case, we return our\n    // remaining data and end the stream, if appropriate.\n    if (state.length > 0 && state.decoder) {\n      ret = fromList(n, state);\n      state.length -= ret.length;\n    }\n\n    if (state.length === 0)\n      endReadable(this);\n\n    return ret;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length - n <= state.highWaterMark)\n    doRead = true;\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading)\n    doRead = false;\n\n  if (doRead) {\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read called its callback synchronously, then `reading`\n  // will be false, and we need to re-evaluate how much data we\n  // can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we happened to read() exactly the remaining amount in the\n  // buffer, and the EOF has been seen at this point, then make sure\n  // that we emit 'end' on the very next tick.\n  if (state.ended && !state.endEmitted && state.length === 0)\n    endReadable(this);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // if we've ended and we have some data left, then emit\n  // 'readable' now to make sure it gets picked up.\n  if (state.length > 0)\n    emitReadable(stream);\n  else\n    endReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (state.emittedReadable)\n    return;\n\n  state.emittedReadable = true;\n  if (state.sync)\n    process.nextTick(function() {\n      emitReadable_(stream);\n    });\n  else\n    emitReadable_(stream);\n}\n\nfunction emitReadable_(stream) {\n  stream.emit('readable');\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    if (readable !== src) return;\n    cleanup();\n  }\n\n  function onend() {\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (!dest._writableState || dest._writableState.needDrain)\n      ondrain();\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    // the handler that waits for readable events after all\n    // the data gets sucked out in flow.\n    // This would be easier to follow with a .once() handler\n    // in flow(), but that is too slow.\n    this.on('readable', pipeOnReadable);\n\n    state.flowing = true;\n    process.nextTick(function() {\n      flow(src);\n    });\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var dest = this;\n    var state = src._readableState;\n    state.awaitDrain--;\n    if (state.awaitDrain === 0)\n      flow(src);\n  };\n}\n\nfunction flow(src) {\n  var state = src._readableState;\n  var chunk;\n  state.awaitDrain = 0;\n\n  function write(dest, i, list) {\n    var written = dest.write(chunk);\n    if (false === written) {\n      state.awaitDrain++;\n    }\n  }\n\n  while (state.pipesCount && null !== (chunk = src.read())) {\n\n    if (state.pipesCount === 1)\n      write(state.pipes, 0, null);\n    else\n      forEach(state.pipes, write);\n\n    src.emit('data', chunk);\n\n    // if anyone needs a drain, then we have to wait for that.\n    if (state.awaitDrain > 0)\n      return;\n  }\n\n  // if every destination was unpiped, either before entering this\n  // function, or in the while loop, then stop flowing.\n  //\n  // NB: This is a pretty rare edge case.\n  if (state.pipesCount === 0) {\n    state.flowing = false;\n\n    // if there were data event listeners added, then switch to old mode.\n    if (EE.listenerCount(src, 'data') > 0)\n      emitDataEvents(src);\n    return;\n  }\n\n  // at this point, no one needed a drain, so we just ran out of data\n  // on the next readable event, start it over again.\n  state.ranOut = true;\n}\n\nfunction pipeOnReadable() {\n  if (this._readableState.ranOut) {\n    this._readableState.ranOut = false;\n    flow(this);\n  }\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data' && !this._readableState.flowing)\n    emitDataEvents(this);\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        this.read(0);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  emitDataEvents(this);\n  this.read(0);\n  this.emit('resume');\n};\n\nReadable.prototype.pause = function() {\n  emitDataEvents(this, true);\n  this.emit('pause');\n};\n\nfunction emitDataEvents(stream, startPaused) {\n  var state = stream._readableState;\n\n  if (state.flowing) {\n    // https://github.com/isaacs/readable-stream/issues/16\n    throw new Error('Cannot switch to old mode now.');\n  }\n\n  var paused = startPaused || false;\n  var readable = false;\n\n  // convert to an old-style stream.\n  stream.readable = true;\n  stream.pipe = Stream.prototype.pipe;\n  stream.on = stream.addListener = Stream.prototype.on;\n\n  stream.on('readable', function() {\n    readable = true;\n\n    var c;\n    while (!paused && (null !== (c = stream.read())))\n      stream.emit('data', c);\n\n    if (c === null) {\n      readable = false;\n      stream._readableState.needReadable = true;\n    }\n  });\n\n  stream.pause = function() {\n    paused = true;\n    this.emit('pause');\n  };\n\n  stream.resume = function() {\n    paused = false;\n    if (readable)\n      process.nextTick(function() {\n        stream.emit('readable');\n      });\n    else\n      this.read(0);\n    this.emit('resume');\n  };\n\n  // now make it start, just in case it hadn't already.\n  stream.emit('readable');\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    //if (state.objectMode && util.isNullOrUndefined(chunk))\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (typeof stream[i] === 'function' &&\n        typeof this[i] === 'undefined') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted && state.calledRead) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb))\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\n  return ret;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      cb(er);\n    });\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished && !state.bufferProcessing && state.buffer.length)\n      clearBuffer(stream, state);\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  cb();\n  if (finished)\n    finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  for (var c = 0; c < state.buffer.length; c++) {\n    var entry = state.buffer[c];\n    var chunk = entry.chunk;\n    var encoding = entry.encoding;\n    var cb = entry.callback;\n    var len = state.objectMode ? 1 : chunk.length;\n\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n    // if we didn't call the onwrite immediately, then\n    // it means that we need to wait until it does.\n    // also, that means that the chunk and cb are currently\n    // being processed, so move the buffer counter past them.\n    if (state.writing) {\n      c++;\n      break;\n    }\n  }\n\n  state.bufferProcessing = false;\n  if (c < state.buffer.length)\n    state.buffer = state.buffer.slice(c);\n  else\n    state.buffer.length = 0;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (typeof chunk !== 'undefined' && chunk !== null)\n    this.write(chunk, encoding);\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    state.finished = true;\n    stream.emit('finish');\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  var ts = this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('finish', function() {\n    if ('function' === typeof this._flush)\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var rs = stream._readableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n","exports.name = \"isarray\";\nexports.version = \"0.0.1\";\nexports.main = \"index.js\";\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","exports.name = \"core-util-is\";\nexports.version = \"1.0.2\";\nexports.main = \"lib/util.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","exports.name = \"inherits\";\nexports.version = \"2.0.1\";\nexports.main = \"./inherits_browser.js\";\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","exports.name = \"string_decoder\";\nexports.version = \"0.10.31\";\nexports.main = \"index.js\";\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n","exports.name = \"debug\";\nexports.version = \"0.7.4\";\nexports.main = \"./debug.js\";\n","\n/**\n * Expose `debug()` as the module.\n */\n\nmodule.exports = debug;\n\n/**\n * Create a debugger with the given `name`.\n *\n * @param {String} name\n * @return {Type}\n * @api public\n */\n\nfunction debug(name) {\n  if (!debug.enabled(name)) return function(){};\n\n  return function(fmt){\n    fmt = coerce(fmt);\n\n    var curr = new Date;\n    var ms = curr - (debug[name] || curr);\n    debug[name] = curr;\n\n    fmt = name\n      + ' '\n      + fmt\n      + ' +' + debug.humanize(ms);\n\n    // This hackery is required for IE8\n    // where `console.log` doesn't have 'apply'\n    window.console\n      && console.log\n      && Function.prototype.apply.call(console.log, console, arguments);\n  }\n}\n\n/**\n * The currently active debug mode names.\n */\n\ndebug.names = [];\ndebug.skips = [];\n\n/**\n * Enables a debug mode by name. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} name\n * @api public\n */\n\ndebug.enable = function(name) {\n  try {\n    localStorage.debug = name;\n  } catch(e){}\n\n  var split = (name || '').split(/[\\s,]+/)\n    , len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    name = split[i].replace('*', '.*?');\n    if (name[0] === '-') {\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));\n    }\n    else {\n      debug.names.push(new RegExp('^' + name + '$'));\n    }\n  }\n};\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\ndebug.disable = function(){\n  debug.enable('');\n};\n\n/**\n * Humanize the given `ms`.\n *\n * @param {Number} m\n * @return {String}\n * @api private\n */\n\ndebug.humanize = function(ms) {\n  var sec = 1000\n    , min = 60 * 1000\n    , hour = 60 * min;\n\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';\n  if (ms >= sec) return (ms / sec | 0) + 's';\n  return ms + 'ms';\n};\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\ndebug.enabled = function(name) {\n  for (var i = 0, len = debug.skips.length; i < len; i++) {\n    if (debug.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (var i = 0, len = debug.names.length; i < len; i++) {\n    if (debug.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Coerce `val`.\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n// persist\n\ntry {\n  if (window.localStorage) debug.enable(localStorage.debug);\n} catch(e){}\n","exports.name = \"split-ca\";\nexports.version = \"1.0.1\";\nexports.main = \"index.js\";\n","var fs = require('fs');\n\nmodule.exports = function (filepath, split, encoding) {\n  split = typeof split !== 'undefined' ? split : \"\\n\";\n  encoding = typeof encoding !== 'undefined' ? encoding : \"utf8\";\n\n  var ca = [];\n  var chain = fs.readFileSync(filepath, encoding);\n  if(chain.indexOf(\"-END CERTIFICATE-\") < 0 || chain.indexOf(\"-BEGIN CERTIFICATE-\") < 0){\n    throw Error(\"File does not contain 'BEGIN CERTIFICATE' or 'END CERTIFICATE'\");\n  }\n  chain = chain.split(split);\n  var cert = [];\n  var _i, _len;\n  for (_i = 0, _len = chain.length; _i < _len; _i++) {\n    var line = chain[_i];\n    if (!(line.length !== 0)) {\n      continue;\n    }\n    cert.push(line);\n    if (line.match(/-END CERTIFICATE-/)) {\n      ca.push(cert.join(split));\n      cert = [];\n    }\n  }\n  return ca;\n}\n","exports.name = \"JSONStream\";\nexports.version = \"0.10.0\";\n","\n\nvar Parser = require('jsonparse')\n  , through = require('through')\n\n/*\n\n  the value of this.stack that creationix's jsonparse has is weird.\n\n  it makes this code ugly, but his problem is way harder that mine,\n  so i'll forgive him.\n\n*/\n\nexports.parse = function (path, map) {\n\n  var parser = new Parser()\n  var stream = through(function (chunk) {\n    if('string' === typeof chunk)\n      chunk = new Buffer(chunk)\n    parser.write(chunk)\n  },\n  function (data) {\n    if(data)\n      stream.write(data)\n    stream.queue(null)\n  })\n\n  if('string' === typeof path)\n    path = path.split('.').map(function (e) {\n      if (e === '*')\n        return true\n      else if (e === '') // '..'.split('.') returns an empty string\n        return {recurse: true}\n      else\n        return e\n    })\n\n\n  var count = 0, _key\n  if(!path || !path.length)\n    path = null\n\n  parser.onValue = function (value) {\n    if (!this.root)\n      stream.root = value\n\n    if(! path) return\n\n    var i = 0 // iterates on path\n    var j  = 0 // iterates on stack\n    while (i < path.length) {\n      var key = path[i]\n      var c\n      j++\n\n      if (key && !key.recurse) {\n        c = (j === this.stack.length) ? this : this.stack[j]\n        if (!c) return\n        if (! check(key, c.key)) return\n        i++\n      } else {\n        i++\n        var nextKey = path[i]\n        if (! nextKey) return\n        while (true) {\n          c = (j === this.stack.length) ? this : this.stack[j]\n          if (!c) return\n          if (check(nextKey, c.key)) { i++; break}\n          j++\n        }\n      }\n    }\n    if (j !== this.stack.length) return\n\n    count ++\n    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])\n    var data = this.value[this.key]\n    if(null != data)\n      if(null != (data = map ? map(data, actualPath) : data))\n        stream.queue(data)\n    delete this.value[this.key]\n  }\n  parser._onToken = parser.onToken;\n\n  parser.onToken = function (token, value) {\n    parser._onToken(token, value);\n    if (this.stack.length === 0) {\n      if (stream.root) {\n        if(!path)\n          stream.queue(stream.root)\n        stream.emit('root', stream.root, count)\n        count = 0;\n        stream.root = null;\n      }\n    }\n  }\n\n  parser.onError = function (err) {\n    stream.emit('error', err)\n  }\n\n\n  return stream\n}\n\nfunction check (x, y) {\n  if ('string' === typeof x)\n    return y == x\n  else if (x && 'function' === typeof x.exec)\n    return x.exec(y)\n  else if ('boolean' === typeof x)\n    return x\n  else if ('function' === typeof x)\n    return x(y)\n  return false\n}\n\nexports.stringify = function (op, sep, cl, indent) {\n  indent = indent || 0\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n\n    op = '[\\n'\n    sep = '\\n,\\n'\n    cl = '\\n]\\n'\n\n  }\n\n  //else, what ever you like\n\n  var stream\n    , first = true\n    , anyData = false\n  stream = through(function (data) {\n    anyData = true\n    var json = JSON.stringify(data, null, indent)\n    if(first) { first = false ; stream.queue(op + json)}\n    else stream.queue(sep + json)\n  },\n  function (data) {\n    if(!anyData)\n      stream.queue(op)\n    stream.queue(cl)\n    stream.queue(null)\n  })\n\n  return stream\n}\n\nexports.stringifyObject = function (op, sep, cl, indent) {\n  indent = indent || 0\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n\n    op = '{\\n'\n    sep = '\\n,\\n'\n    cl = '\\n}\\n'\n\n  }\n\n  //else, what ever you like\n\n  var first = true\n    , anyData = false\n  stream = through(function (data) {\n    anyData = true\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)\n    if(first) { first = false ; this.queue(op + json)}\n    else this.queue(sep + json)\n  },\n  function (data) {\n    if(!anyData) this.queue(op)\n    this.queue(cl)\n\n    this.queue(null)\n  })\n\n  return stream\n}\n\nif(!module.parent && process.title !== 'browser') {\n  process.stdin\n    .pipe(exports.parse(process.argv[2]))\n    .pipe(exports.stringify('[', ',\\n', ']\\n', 2))\n    .pipe(process.stdout)\n}\n","exports.name = \"jsonparse\";\nexports.version = \"0.0.5\";\nexports.main = \"jsonparse.js\";\n","/*global Buffer*/\n// Named constants with unique integer values\nvar C = {};\n// Tokens\nvar LEFT_BRACE    = C.LEFT_BRACE    = 0x1;\nvar RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;\nvar LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;\nvar RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;\nvar COLON         = C.COLON         = 0x5;\nvar COMMA         = C.COMMA         = 0x6;\nvar TRUE          = C.TRUE          = 0x7;\nvar FALSE         = C.FALSE         = 0x8;\nvar NULL          = C.NULL          = 0x9;\nvar STRING        = C.STRING        = 0xa;\nvar NUMBER        = C.NUMBER        = 0xb;\n// Tokenizer States\nvar START   = C.START   = 0x11;\nvar TRUE1   = C.TRUE1   = 0x21;\nvar TRUE2   = C.TRUE2   = 0x22;\nvar TRUE3   = C.TRUE3   = 0x23;\nvar FALSE1  = C.FALSE1  = 0x31;\nvar FALSE2  = C.FALSE2  = 0x32;\nvar FALSE3  = C.FALSE3  = 0x33;\nvar FALSE4  = C.FALSE4  = 0x34;\nvar NULL1   = C.NULL1   = 0x41;\nvar NULL2   = C.NULL3   = 0x42;\nvar NULL3   = C.NULL2   = 0x43;\nvar NUMBER1 = C.NUMBER1 = 0x51;\nvar NUMBER2 = C.NUMBER2 = 0x52;\nvar NUMBER3 = C.NUMBER3 = 0x53;\nvar NUMBER4 = C.NUMBER4 = 0x54;\nvar NUMBER5 = C.NUMBER5 = 0x55;\nvar NUMBER6 = C.NUMBER6 = 0x56;\nvar NUMBER7 = C.NUMBER7 = 0x57;\nvar NUMBER8 = C.NUMBER8 = 0x58;\nvar STRING1 = C.STRING1 = 0x61;\nvar STRING2 = C.STRING2 = 0x62;\nvar STRING3 = C.STRING3 = 0x63;\nvar STRING4 = C.STRING4 = 0x64;\nvar STRING5 = C.STRING5 = 0x65;\nvar STRING6 = C.STRING6 = 0x66;\n// Parser States\nvar VALUE   = C.VALUE   = 0x71;\nvar KEY     = C.KEY     = 0x72;\n// Parser Modes\nvar OBJECT  = C.OBJECT  = 0x81;\nvar ARRAY   = C.ARRAY   = 0x82;\n\n// Slow code to string converter (only used when throwing syntax errors)\nfunction toknam(code) {\n  var keys = Object.keys(C);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    if (C[key] === code) { return key; }\n  }\n  return code && (\"0x\" + code.toString(16));\n}\n\n\nfunction Parser() {\n  this.tState = START;\n  this.value = undefined;\n\n  this.string = undefined; // string data\n  this.unicode = undefined; // unicode escapes\n\n  // For number parsing\n  this.negative = undefined;\n  this.magnatude = undefined;\n  this.position = undefined;\n  this.exponent = undefined;\n  this.negativeExponent = undefined;\n  \n  this.key = undefined;\n  this.mode = undefined;\n  this.stack = [];\n  this.state = VALUE;\n  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n  this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n}\nvar proto = Parser.prototype;\nproto.charError = function (buffer, i) {\n  this.onError(new Error(\"Unexpected \" + JSON.stringify(String.fromCharCode(buffer[i])) + \" at position \" + i + \" in state \" + toknam(this.tState)));\n};\nproto.onError = function (err) { throw err; };\nproto.write = function (buffer) {\n  if (typeof buffer === \"string\") buffer = new Buffer(buffer);\n  //process.stdout.write(\"Input: \");\n  //console.dir(buffer.toString());\n  var n;\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    if (this.tState === START){\n      n = buffer[i];\n      if(n === 0x7b){ this.onToken(LEFT_BRACE, \"{\"); // {\n      }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, \"}\"); // }\n      }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, \"[\"); // [\n      }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, \"]\"); // ]\n      }else if(n === 0x3a){ this.onToken(COLON, \":\");  // :\n      }else if(n === 0x2c){ this.onToken(COMMA, \",\"); // ,\n      }else if(n === 0x74){ this.tState = TRUE1;  // t\n      }else if(n === 0x66){ this.tState = FALSE1;  // f\n      }else if(n === 0x6e){ this.tState = NULL1; // n\n      }else if(n === 0x22){ this.string = \"\"; this.tState = STRING1; // \"\n      }else if(n === 0x2d){ this.negative = true; this.tState = NUMBER1; // -\n      }else if(n === 0x30){ this.magnatude = 0; this.tState = NUMBER2; // 0\n      }else{\n        if (n > 0x30 && n < 0x40) { // 1-9\n          this.magnatude = n - 0x30; this.tState = NUMBER3;\n        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {\n          // whitespace\n        } else { this.charError(buffer, i); }\n      }\n    }else if (this.tState === STRING1){ // After open quote\n      n = buffer[i]; // get current byte from buffer\n      // check for carry over of a multi byte char split between data chunks\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n      if (this.bytes_remaining > 0) {\n        for (var j = 0; j < this.bytes_remaining; j++) {\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];\n        }\n        this.string += this.temp_buffs[this.bytes_in_sequence].toString();\n        this.bytes_in_sequence = this.bytes_remaining = 0;\n        i = i + j - 1;\n      } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;\n        if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split\n          for (var k = 0; k <= (buffer.length - 1 - i); k++) {\n            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk\n          }\n          this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;\n          i = buffer.length - 1;\n        } else {\n          this.string += buffer.slice(i, (i + this.bytes_in_sequence)).toString();\n          i = i + this.bytes_in_sequence - 1;\n        }\n      } else if (n === 0x22) { this.tState = START; this.onToken(STRING, this.string); this.string = undefined; }\n      else if (n === 0x5c) { this.tState = STRING2; }\n      else if (n >= 0x20) { this.string += String.fromCharCode(n); }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === STRING2){ // After backslash\n      n = buffer[i];\n      if(n === 0x22){ this.string += \"\\\"\"; this.tState = STRING1;\n      }else if(n === 0x5c){ this.string += \"\\\\\"; this.tState = STRING1; \n      }else if(n === 0x2f){ this.string += \"\\/\"; this.tState = STRING1; \n      }else if(n === 0x62){ this.string += \"\\b\"; this.tState = STRING1; \n      }else if(n === 0x66){ this.string += \"\\f\"; this.tState = STRING1; \n      }else if(n === 0x6e){ this.string += \"\\n\"; this.tState = STRING1; \n      }else if(n === 0x72){ this.string += \"\\r\"; this.tState = STRING1; \n      }else if(n === 0x74){ this.string += \"\\t\"; this.tState = STRING1; \n      }else if(n === 0x75){ this.unicode = \"\"; this.tState = STRING3;\n      }else{ \n        this.charError(buffer, i); \n      }\n    }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes\n      n = buffer[i];\n      // 0-9 A-F a-f\n      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {\n        this.unicode += String.fromCharCode(n);\n        if (this.tState++ === STRING6) {\n          this.string += String.fromCharCode(parseInt(this.unicode, 16));\n          this.unicode = undefined;\n          this.tState = STRING1; \n        }\n      } else {\n        this.charError(buffer, i);\n      }\n    }else if (this.tState === NUMBER1){ // after minus\n      n = buffer[i];\n      if (n === 0x30) { this.magnatude = 0; this.tState = NUMBER2; }\n      else if (n > 0x30 && n < 0x40) { this.magnatude = n - 0x30; this.tState = NUMBER3; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === NUMBER2){ // * After initial zero\n      n = buffer[i];\n      if(n === 0x2e){ // .\n        this.position = 0.1; this.tState = NUMBER4;\n      }else if(n === 0x65 ||  n === 0x45){ // e/E\n        this.exponent = 0; this.tState = NUMBER6;\n      }else{\n        this.tState = START;\n        this.onToken(NUMBER, 0);\n        this.magnatude = undefined;\n        this.negative = undefined;\n        i--;\n      }\n    }else if (this.tState === NUMBER3){ // * After digit (before period)\n      n = buffer[i];\n      if(n === 0x2e){ // .\n        this.position = 0.1; this.tState = NUMBER4;\n      }else if(n === 0x65 || n === 0x45){ // e/E\n        this.exponent = 0; this.tState = NUMBER6;\n      }else{\n        if (n >= 0x30 && n < 0x40) { this.magnatude = this.magnatude * 10 + n - 0x30; }\n        else {\n          this.tState = START; \n          if (this.negative) {\n            this.magnatude = -this.magnatude;\n            this.negative = undefined;\n          }\n          this.onToken(NUMBER, this.magnatude); \n          this.magnatude = undefined;\n          i--;\n        }\n      }\n    }else if (this.tState === NUMBER4){ // After period\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.magnatude += this.position * (n - 0x30);\n        this.position /= 10;\n        this.tState = NUMBER5; \n      } else { this.charError(buffer, i); }\n    }else if (this.tState === NUMBER5){ // * After digit (after period)\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.magnatude += this.position * (n - 0x30);\n        this.position /= 10;\n      }\n      else if (n === 0x65 || n === 0x45) { this.exponent = 0; this.tState = NUMBER6; } // E/e\n      else {\n        this.tState = START; \n        if (this.negative) {\n          this.magnatude = -this.magnatude;\n          this.negative = undefined;\n        }\n        this.onToken(NUMBER, this.negative ? -this.magnatude : this.magnatude); \n        this.magnatude = undefined;\n        this.position = undefined;\n        i--; \n      }\n    }else if (this.tState === NUMBER6){ // After E\n      n = buffer[i];\n      if (n === 0x2b || n === 0x2d) { // +/-\n        if (n === 0x2d) { this.negativeExponent = true; }\n        this.tState = NUMBER7;\n      }\n      else if (n >= 0x30 && n < 0x40) {\n        this.exponent = this.exponent * 10 + (n - 0x30);\n        this.tState = NUMBER8;\n      }\n      else { this.charError(buffer, i); }  \n    }else if (this.tState === NUMBER7){ // After +/-\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.exponent = this.exponent * 10 + (n - 0x30);\n        this.tState = NUMBER8;\n      }\n      else { this.charError(buffer, i); }  \n    }else if (this.tState === NUMBER8){ // * After digit (after +/-)\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.exponent = this.exponent * 10 + (n - 0x30);\n      }\n      else {\n        if (this.negativeExponent) {\n          this.exponent = -this.exponent;\n          this.negativeExponent = undefined;\n        }\n        this.magnatude *= Math.pow(10, this.exponent);\n        this.exponent = undefined;\n        if (this.negative) { \n          this.magnatude = -this.magnatude;\n          this.negative = undefined;\n        }\n        this.tState = START;\n        this.onToken(NUMBER, this.magnatude);\n        this.magnatude = undefined;\n        i--; \n      } \n    }else if (this.tState === TRUE1){ // r\n      if (buffer[i] === 0x72) { this.tState = TRUE2; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === TRUE2){ // u\n      if (buffer[i] === 0x75) { this.tState = TRUE3; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === TRUE3){ // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === FALSE1){ // a\n      if (buffer[i] === 0x61) { this.tState = FALSE2; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === FALSE2){ // l\n      if (buffer[i] === 0x6c) { this.tState = FALSE3; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === FALSE3){ // s\n      if (buffer[i] === 0x73) { this.tState = FALSE4; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === FALSE4){ // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === NULL1){ // u\n      if (buffer[i] === 0x75) { this.tState = NULL2; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === NULL2){ // l\n      if (buffer[i] === 0x6c) { this.tState = NULL3; }\n      else { this.charError(buffer, i); }\n    }else if (this.tState === NULL3){ // l\n      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); }\n      else { this.charError(buffer, i); }\n    }\n  }\n};\nproto.onToken = function (token, value) {\n  // Override this to get events\n};\n\nproto.parseError = function (token, value) {\n  this.onError(new Error(\"Unexpected \" + toknam(token) + (value ? (\"(\" + JSON.stringify(value) + \")\") : \"\") + \" in state \" + toknam(this.state)));\n};\nproto.onError = function (err) { throw err; };\nproto.push = function () {\n  this.stack.push({value: this.value, key: this.key, mode: this.mode});\n};\nproto.pop = function () {\n  var value = this.value;\n  var parent = this.stack.pop();\n  this.value = parent.value;\n  this.key = parent.key;\n  this.mode = parent.mode;\n  this.emit(value);\n  if (!this.mode) { this.state = VALUE; }\n};\nproto.emit = function (value) {\n  if (this.mode) { this.state = COMMA; }\n  this.onValue(value);\n};\nproto.onValue = function (value) {\n  // Override me\n};  \nproto.onToken = function (token, value) {\n  //console.log(\"OnToken: state=%s token=%s %s\", toknam(this.state), toknam(token), value?JSON.stringify(value):\"\");\n  if(this.state === VALUE){\n    if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){\n      if (this.value) {\n        this.value[this.key] = value;\n      }\n      this.emit(value);  \n    }else if(token === LEFT_BRACE){\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = {};\n      } else {\n        this.value = {};\n      }\n      this.key = undefined;\n      this.state = KEY;\n      this.mode = OBJECT;\n    }else if(token === LEFT_BRACKET){\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = [];\n      } else {\n        this.value = [];\n      }\n      this.key = 0;\n      this.mode = ARRAY;\n      this.state = VALUE;\n    }else if(token === RIGHT_BRACE){\n      if (this.mode === OBJECT) {\n        this.pop();\n      } else {\n        this.parseError(token, value);\n      }\n    }else if(token === RIGHT_BRACKET){\n      if (this.mode === ARRAY) {\n        this.pop();\n      } else {\n        this.parseError(token, value);\n      }\n    }else{\n      this.parseError(token, value);\n    }\n  }else if(this.state === KEY){\n    if (token === STRING) {\n      this.key = value;\n      this.state = COLON;\n    } else if (token === RIGHT_BRACE) {\n      this.pop();\n    } else {\n      this.parseError(token, value);\n    }\n  }else if(this.state === COLON){\n    if (token === COLON) { this.state = VALUE; }\n    else { this.parseError(token, value); }\n  }else if(this.state === COMMA){\n    if (token === COMMA) { \n      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }\n      else if (this.mode === OBJECT) { this.state = KEY; }\n\n    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {\n      this.pop();\n    } else {\n      this.parseError(token, value);\n    }\n  }else{\n    this.parseError(token, value);\n  }\n};\n\nmodule.exports = Parser;\n","exports.name = \"through\";\nexports.version = \"2.3.8\";\nexports.main = \"index.js\";\n","var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n"]}}]